\documentclass{article}

\usepackage{verbatim}

\usepackage{amssymb}

\usepackage{makeidx}

\makeindex

\pagestyle{myheadings}

\markright{Version of 2/4/2015 4:45 PM yes, there are isomorphisms!  [somewhat less rough])}

\title{NF is consistent}

\author{M. Randall Holmes}

\begin{document}

\maketitle

\noindent {\bf version notes}  

2/4/2015  My previous version note was much too optimistic;  the previous version had a lot wrong with it.   This one has been overhauled.   There were a lot of glitches in the previous version caused by repeated major changes in the document not being consistently applied everywhere, and the crucial argument that code types $\{\alpha,\beta\}$ are sets was not presented accurately.   I believe the assertions made on 1/28/2015 can now be made of this version.

Crucially, it does appear that the elementary embeddings of the previous series between analogous types expected to have the same theories can be replaced by isomorphisms in this version, which is a serious gain in comprehensibility.

1/28/2015  4:45 PM:  This version is messy, but may in principle be complete (and simplified).   There is a lot of cleanup to do, however.

It appears that we really do get isomorphisms for elementary embeddings; this is going to be genuinely simpler than previous series.   This draft is rather disorganized because certain essential parts of it (which turn out to be rather different for this version of the structure) have just been written down for the first time, and other parts will need to be revised to reflect the changes.   It appears that if everything is correctly organized it really does fall out that the elementarily equivalent initial segments of interpretations of TSTU$_n$ with enough types (something like four) actually are isomorphic externally in a way which is rather easy to describe.

My earlier ``discovery" that I didn't get isomorphisms was due to another error in the then version of the construction which has been fixed (trying to make the parent sets too large).

1/28/2015:  added the requirement that allowable permutations fix parents of seed litters directly when seed litters are introduced, rather than as a formally complex additional clause to the original definition.

1/27/2015  Changed ``seed parent codes" to ``seed litter codes", which is more accurate.   Corrected the action of allowable permutations on these, which I hadn't thought through properly when they changed from parents to litters.  Once again, the parents of seed litters are not moved by allowable permutations (but the seed litters themselves are, being litters).

The current status of this document is that it is not a complete proof (sethood of the collection of codes and elementarity need to be tidied up) but I can see how these proofs go and expect to supply them shortly.  I believe this will be a complete alternative version of the proof shortly, and I think the approach here is usefully simpler.

1/24/2015  My remark that codes won't surpass rank $\lambda + \kappa+$ is incorrect, I believe.  The possible codes do make up a set, but for deeper reasons.   The difficulty is that the $T$ component of a precode can be quite complex, independently of the complexity of the atoms appearing in its support closure.

1/23/2015  another stupidity.   $\Pi(B)$ should not be the size of type $B$, but the size of the disjoint union of the types $B \cup \{\beta\}$ where the members of $B$ dominate $\beta$.
For certainly type $B$ is as large as the power set of $\Pi(B)$, which is a collection of disjoint sets.   This changes the technicalities in the elementarity argument again (but the indiscernibles are still clearly indiscernible).   It causes the typing of parents of atoms in codes to be different, and hopefully I made the repairs consistently.

1/23/2015  Changing my approach to precodes for sets.  I think it is better to have the most general definition of set precodes and lemmas proving that any set that has
a code has codes of the optimal forms, rather than making the optimal conditions (which are quite complicated) part of the definition.  I also switched back to allowing allowable permutations to move seed litters.  It is looking quite good at the moment.   The end of the argument for elementarity is not yet supplied, but it will go through in essentially the same way as in older versions (though the details of what the indiscernibles are are quite different in this version).

1/22/2015 5 PM:  Cleanup and revision of this approach.  Still an early draft.   The definition of strong support had to be restated (this applies to the intermediate version as well, but
I am not changing that).   The use of transitive closures to describe conditions on set precodes had to be restated in terms of a new notion of support closure (I had not thought about the problem of members of codes as opposed to precodes).  I outline the approach to the elementarity proof but it is not complete (I know how it works in general terms but I have to check details).

 The version of 1/20/2015 is a massive revision and simplification, which makes this version considerably different from the previous series.
One now needs clans only as base types (there are no additional clans associated with the non-base types).  Further (actually earlier, but this revision has not been seen in a posted version), the approach to presentation of the coding has been revised, by applying much tighter control to the set theoretical ranks at which codes are introduced, which allows for example a much easier demonstration that the possible codes make up a set.   An indication of how much better this is than earlier versions is that the elementary equivalence between interpretations of TSTU$_n$ which is needed at the final step turns out to be an isomorphism in this version.

This version no longer involves one of the signature features of earlier versions, the embedding of clans into the parent sets of other clans.   All clans are now base types.

\newpage

\tableofcontents

\newpage

\section{Notes for readers of earlier versions}

There are no tangled webs of cardinals here (or not explicitly).  What is indexed by nonempty finite subsets of $\lambda$ are types in a complex structure from which interpretations of TSTU (not TST) can be extracted, and to which a Jensen-style proof of the consistency of NFU + ``there are no more urelements than sets" will eventually apply.   However, the cardinalities
of these types as seen internally to the interpretations of TSTU (which do cohere) will make up a tangled web of cardinals in the sense defined in earlier versions.  It should be noted in the version of 1/19/2015 that we have restricted which finite subsets of $\lambda$ are type indices in such a way to ensure that every type lives in a model of TSTU$_n$ with $n \geq 3$.

There are no atoms here in the sense of ZFA.  The word atom is used to refer to objects of base type in the interleaved type structure.   There is an FM interpretation in the sense of the interpretations
of type theory in the type structure; it is quite easy to show that an instance of comprehension with symmetric parameters in type theory is witnessed by a symmetric set.   It would also be possible to replace the elements of the base types in the interleaved type structure with atoms in the sense of ZFA and do an FM interpretation of the usual sort.

The coding is of the new variety introduced in another set of intermediate documents sent out to the Cambridge reading group.  The only objects built directly from codes are
the elements of base types (the atoms).

In the version of 1/19/2015, all elements of clans are atoms (which sounds more familiar to readers of the earlier series) but they are all of base type (which was not true in the previous series).   This is a massive simplification (to me it is visible that this is related to the collapse of ambiguous TST to ambiguous TST$_4$, but I am in a privileged position).   In this version it is no longer the case that clans will appear included in parent sets of other clans.   Each parent set has a collection of $\kappa$ anonymous ``seed" elements, but in general elements of parent sets are simply images of sets that we construct under the maps $f_B$.   This does mean that the relationship of this scheme to the previous series will seem much more oblique, as there are no longer clans associated with all type indices.  I am seeing here the real payoff from passing to these ``fused type structures"  as a representation.

The use of TSTU rather than TST just comes from the fact that it is easier to work with a disjoint union of power sets than to try to figure out how to identify power sets in different type hierarchies.   It turns out to be harmless as one wants each of the power sets to be just as large as the disjoint union, so we are working toward NFU with no more urelements than sets, which we know is equivalent to NF.

\newpage

\section{Theoretical Background}

In this document, we will prove that Quine's ``New Foundations" is consistent.

Simple type theory\index{type theory} with urelements\index{urelements},  or TSTU\index{TSTU}, is the first order many sorted theory with sorts indexed by the natural numbers, primitive predicates of equality, membership and sethood with all well-formed atomic sentences of the forms $x^i=y^i$, $x^i \in y^{i+1}$ and ${\tt set}(x^{i+1})$,  axiom schemes of comprehension $(\exists A.{\tt set}(A) \wedge (x \in A \leftrightarrow \phi))$, extensionality
$$(\forall ab.{\tt set}(a) \wedge {\tt set}(b) \rightarrow a=b \leftrightarrow (\forall x.x \in a \leftrightarrow y \in a))$$ and sethood $x \in a \rightarrow {\tt set}(a)$.   There are no explicit type indices in the axiom schemes:  they are asserted with all assignments of types to variables which give well-formed formulas.  Objects of type 0 whose members we would never talk about are called {\em atoms}\index{atoms}; objects of positive types which are not sets and so have no elements are called {\em urelements}\index{urelements}.

TSTU$_n$\index{TSTU$_n$} is the subset of TSTU whose language contains variables only of types less than $n$, with its axioms being the axioms of TSTU expressible in that language.

NFU\index{NFU} is the first order one-sorted theory with primitive predicates of equality, membership and sethood and axiom schemes of stratified comprehension $(\exists A.{\tt set}(A) \wedge (x \in A \leftrightarrow \phi))$, where $\phi$ must be a formula of the language of NFU obtained from a formula of the language of TSTU by dropping type distinctions between variables (without introducing identifications of variables; such formulas are said to be stratified), extensionality
$$(\forall ab.{\tt set}(a) \wedge {\tt set}(b) \rightarrow a=b \leftrightarrow (\forall x.x \in a \leftrightarrow y \in a))$$ and sethood $x \in a \rightarrow {\tt set}(a)$.

NF\index{NF} is the theory obtained from NFU by dropping the sethood predicate and strengthening extensionality to $(\forall ab.a=b \leftrightarrow (\forall x.x \in a \leftrightarrow y \in a))$.   Equivalently, it is NFU + ``everything is a set".   Of course NF is historically prior (defined by Quine in \cite{nf}) and NFU was obtained by modifying NF (by Jensen, who defined this theory and proved its consistency in \cite{nfu}, 1969), but NFU has hitherto been the better understood theory of the two.

If we associate with any variable $x$ in our language a variable $x^+$ of type one higher in a bijective manner, we can inductively define an operation acting on any formula $\phi$ to obtain a formula
$\phi^+$ of the same logical form with types of each variable raised by one.   It is clear that if we can prove $\phi$ in TSTU, we can prove $\phi^+$.   The Ambiguity\index{Ambiguity Scheme} Scheme asserts
$\phi \leftrightarrow \phi^+$ for all sentences $\phi$.   It is a theorem of Specker (\cite{specker}, 1962) that the existence of a model of TSTU + Ambiguity implies the existence of a model of NFU
with the same theory (after dropping type distinctions between variables).  Specker actually proved this for NF,  but his proof technique applies to NFU as well (and was used thus by Jensen in \cite{nfu}).

Maurice Boffa showed in \cite{boffaperms} that NF is equiconsistent with NFU + ``the set of sets has the same cardinality as the universe"  (there are no more urelements than sets).  Our strategy for proving the consistency of NF will in fact be to prove consistency of TSTU + Ambiguity + ``the set of sets has the same cardinality as the universe" (a typed version of this says that there are as many sets in each positive type as objects in that type).

\newpage

\section{Interleaved interpretations of TSTU$_n$'s in fused type structures}

We work in the usual set theory ZFC.

We begin by giving a general description of a kind of structure from which many structures for the language of an initial segment of TSTU (simple type theory with urelements
in each type) can be extracted.

Fix a limit ordinal $\lambda$.\index{$\lambda$, parameter of the construction}

A finite subset $A$ of $\lambda$ such that ${\tt min}(A)+|A| \geq 3$ is called a {\em type index\/}\index{type index}\index{index, type}.  For any type index $A$ with at least two elements we define $A_1$ as $A \setminus \{{\tt min}(A)\}$ (note that $A_1$ will still be a type index, as its cardinality is one less than that of $A$ and its minimal element is at least one greater than the minimal element of $A$), $A_0$ as $A$,
and $A_{i+1}$ as $(A_i)_1$ where this is defined.   A type index which contains 0 as an element is called a {\em base type index}.  Note that a base type index will have at least three elements.\index{base type index}\index{type index, base}

\begin{description}

\item[Definition:]   A fused type structure (FTS) [of order $\lambda$] is a function $\tau$ from the type indices to sets with the following properties.\index{fused type structure}\index{FTS}

\begin{enumerate}

\item  For distinct type indices $A, B$, $\tau(A)$ and $\tau(B)$ are disjoint sets. 

\item  Each element of a $\tau(A)$ where $A$ is not a base type index is of the form $(B,S)$, where $B_1=A$ and $S \subseteq \tau(B)$.  There is no claim that
all such pairs $(B,S)$ belong to $\tau(A)$.

\end{enumerate}

\end{description}

We will usually consider a fixed FTS $\tau$ and refer to $\tau(A)$ as ``type $A$".   Elements of types whose index is a base type index will be called atoms and will not be viewed as having extensions in the interpretations of the language of TSTU which we will give, and types indexed by base type indices will be referred to as base types.\index{base type}\index{type, base}

Notice that we have arranged for a non-base type to be a disjoint union of subcollections of the power sets of the types whose indices extend its index by one downward.  Notice that a general typed set $(S,A)$ is of type $A_1$ and $S$ has elements of type $A$.

With each type index $A$ (usually but not necessarily a base type index) we associate an interpretation of the language of TSTU$_{|A|}$ in which type $i$ will be realized as type $A_i$ of our fused type structure and $x^i \in y^{i+1}$ will be interpreted
as $x^i \in \pi_1(y^{i+1})$.    Sethood assertions ${\tt set}(x^{i+1})$ will be interpreted as $\pi_2(x)=A_i$.   Objects $(S,B)$ where $B$ is an $A_{i+1} \cup \{\beta\} \neq A_i$ are interpreted as urelements of the positive type $i+1$ (we reserve the term ``atom" in this context for elements of type $A$).   Of course our intention is eventually
that these will give not just structures for the language of TSTU$_n$'s but actual interpretations of TSTU$_n$'s.\index{interpretations of (the language of) TSTS$_n$'s}

For each type index $A$ (again, often but not necessarily a base type index) we can associate a partial map $\rho_A$ sending certain elements of each $\tau(A_i)$ to elements of
${\cal P}^i(\tau(A))$:  $\rho_A$ is the identity on $\tau(A)$ and maps each object $(S,A_i)$ in each $\tau(A_{i+1})$ to $\rho_A``S$.    $\rho_A$ is defined exactly at the atoms
and pure sets of the interpretation of TSTU$_{|A|}$ described in the previous paragraph (undefined at the urelements or at any set with an urelement among its iterated elements).  We can say that an element $X$ of some ${\cal P}^i(\tau(A))$ is implemented in type $A_i$ iff there is an element $Y$ of type $A_i$ with $\rho_A(Y)=X$.   In this case we say that $Y$ implements $X$ in type $A_i$.

\newpage

\section{Fused type structures with clans}

Fix an uncountable regular cardinal $\kappa$.\index{$\kappa$, parameter of the construction}  Sets of size $<\kappa$ will be called small\index{small sets} and all other sets will be called large\index{large sets}.

We now define a particular kind of FTS, called an FTS with clans, which is the only kind of FTS we will consider henceforth.   It will continue to be the case that we are usually considering a fixed FTS given in the context.

\begin{description}

\item[Definition:]   We define the notion of an FTS with clans.\index{FTS with clans}  An FTS with clans is an FTS $\tau$ with the following additional features.  (In the following discussion, the name $\tau$ of the FTS seldom appears explicitly:  the phrase type $A$ refers to $\tau(A)$ as usual).

With each base type index $A$, a large collection ${\tt clan}(A)$ is associated.  These collections are called {\em clans\/}.\index{clans introduced}   Each clan is the union of a collection of pairwise disjoint sets called {\em litters\/}.\index{litters introduced}
With each litter $L$ we will associate an object $a$ called the parent of the litter $L$\index{parent of a litter, introduced} and a bijection $i_L$ from $\kappa$ to $L$, and introduce the notation
$a_{\alpha}$ to represent $i_L(\alpha)$  [the notation $i_L$ is never used again].  When the parent $a$ of a litter $L$ is known, the litter $L$ may be denoted by ${\tt litter}(a) = \{a_{\alpha}:\alpha<\kappa\}$.  The collection of parents of elements of ${\tt clan}(A)$ will be denoted by $\Pi(A)$ and will be called the parent set of the clan ${\tt clan}(A,B)$.\index{parent set introduced}

We say that elements of clans and litters have parents:  $a$ is the parent of ${\tt litter}(a)$ and of each $a_{\alpha}$.\index{parent of a litter}\index{parent of an atom}\index{clans}


${\tt clan}(A)$ coincides with the base type indexed by $A$ (the clans are exactly the base types of the FTS and the elements of clans are exactly the atoms of the FTS).

Where $L$ is a litter included in a clan ${\tt clan}(A)$, we define $L^{\Delta}$ as the set of all subsets of ${\tt clan}(A)$ with small symmetric difference from $L$.

Where $L$ is a litter included in a clan ${\tt clan}(A)$, the parent of $L$ is the unique $a$ in type $A_2$ (note that any base type index has at least three elements, so $A_2$ is a type index) such that $\rho_{A}(a)=L^{\Delta}$.  This of course implies that each of the elements of $L^{\Delta}$ and $L^{\Delta}$ itself are actually implemented in our FTS.

In the interpretations of TSTU$_n$'s that we consider, litters will be $\kappa$-amorphous sets (they will be seen to have only small and co-small subsets) and the parent of the litter in this case turns out to be the usual implementation of the cardinality of the litter (Frege-Russell cardinals are usually used in simple type theory).

Define $\iota``(\tau(A))$ as the type $A_1$ set of all $(\{a\},A)$ for $a \in \tau(A)$.

Further, we provide that for each base type index $B$ there is a bijection $f_B$ from $\Pi(B)$ (a subcollection of type $B_2$) onto the union of the sets $\iota``(\tau(C))$ for $C$ such that
$C_1=B_2$. The intention here is that the $f_B$'s will be used as a device to ensure that in each interpretation of TSTU$_n$ in our structure there will be no more urelements than sets in each type where this is a consideration:  
we will arrange for the $f_B$'s to be implemented as functions in the interpretations, and of course all elements of parent sets are sets of the interpretations.  The elements of the set $\Pi(B)$ are disjoint, so if we have a genuine interpretation of TSTU we will have each element of type $B_2$ correlated with a subset of a type $B_2 \cup \{\beta\}$ which will be correlated with
a subset of $\iota``(\tau(B_2 \cup \{\beta\}))$ which will correlate elementwise with a subset of $\Pi(B)$ whose union will be uniquely correlated with the original arbitrary element of type $B_2$:
every element of type $B_2$ will be correlated with an element of type $B$ with type $B_1$ elements  in a way which will be represented internally in interpretations of TSTU$_n$.

\end{description}

The last condition in the definition makes it quite clear that the positive types of the interpretations of (the language of) TSTU$_n$'s in an FTS with clans cannot in general implement the full power sets of the types just below.

NOTE:  deleted the description of the minimal FTS with clans, which requires considerable correction.  It will reappear when I have retuned it.

\newpage

\section{Allowable permutations and symmetry}

A near-litter is defined as a subset of a clan with small symmetric difference from a litter.   An anomalous element for a near-litter is an element of the small symmetric difference between the near-litter and the litter from which it has small symmetric difference.   The parent of a near-litter is the same as the parent of the litter from which the near-litter has small symmetric difference.
\index{near-litter}\index{parent of a near-litter}\index{anomalous element for a near-litter}

An allowable permutation is a permutation $\pi$ acting on atoms (elements of base types), extended to each object $(S,A)$ of non-base type by $\pi(S,A)=(\pi``S,A)$ and on elements $S$ of subsets of types (and singletons of such subsets)
by $\pi(S)=\pi``S$, with further properties that $\pi$ sends each ${\tt litter}(a)$ to a near-litter with small symmetric difference from ${\tt litter}(\pi(a))$ and $\pi$ commutes with each of the maps $f_B$.\index{allowable permutation}  We will impose an additional condition on allowable permutations below, to the effect that they fix certain special parents.

An exception of an allowable permutation is an atom $a_{\alpha}$ such that $\pi(a_{\alpha})=b_{\beta}$ where $b \neq \pi(a)$.\index{exception of an allowable permutation}

A support set is a small collection of atoms and near-litters in which distinct near-litters are disjoint.  A subset $A$ of a type is symmetric iff there is a support set $S$ (which we call a support of $A$) such that all allowable permutations which
fix each element of $S$ also fix $A$.\index{support set}\index{symmetric set}\index{support of a set}  (NOTE:  making near-litters in supports disjoint if distinct is harmless and may give sensible minimal supports).

The intention is that the objects $(S,A\cup \{\beta\})$ which appear in type $A$ in the FTS with clans which we aim to construct will be exactly those for which $S$ is symmetric.  (I do not need to say hereditarily symmetric, because the elements
of $S$ are already taken care of by the same condition).  Our construction is thus a variant of the Frankel-Mostowski construction usually used to prove the independence of Choice from ZFA.  However, this is not something that can be stipulated directly:  it needs to be set up.

Note that a representation of any map of the maps $f_B$ in the normal set theoretic way as a set of Kuratowski pairs in an interpretation of TSTU$_n$ in our FST will be symmetric with empty support.

\newpage

\section{Codes with semantics}

We now begin a precise description of what objects there are.   This will involve some coding of symmetric sets.  

\begin{description}

\item[Definition (codes and precodes):]

We presuppose an FTS with clans.  We define codes, precodes, and referents $\delta(x)$ of each code and precode $x$.

Each object $(\alpha,B,\kappa+\lambda)$ is a precode, where $\alpha$ is a small ordinal and $B$ is a base type index.   These are called seed litter precodes.  We say that this precode is of code type $B_1$.  $(\alpha,B,0)$  will usually be written for precodes of this kind.  It is useful to note that the code for $\delta((\alpha,B,\kappa+\lambda))$ is $\{(\alpha,B,\kappa+\lambda)\}$
and $\delta(\{(\alpha,B,\kappa+\lambda)\})$ is the same as $\delta((\alpha,B,\kappa+\lambda))$.   This is a special case of the general definition of codes for non-atoms, but we have occasion to use it before the general definition is stated.

Each object $(\alpha,p,B,\kappa+\lambda+1)$, where $B$ is a base type index and $p$ is a code with $\delta(p)$ of a code type $C$ with $C_1=B_2$, is a precode and $\delta(\alpha,p,B,\kappa+\lambda+1)=f_B^{-1}((\{\delta(p)\},C))_{\alpha}$.  We say that this precode is of code type $B$.  Because (as we will see) each object has at most one code, an atom has only one precode.  These are called atom precodes (and they are also the atom codes).  The precode $(\alpha,p,B,\kappa+\lambda+1)$ may conventionally be written $(\alpha,p,B,1)$

For any $B$, define ${\tt clan}^*(B)$ as the set of all codes $(\alpha,p,B,\kappa+\lambda+1)$ for $\alpha<\kappa$ and $p$ a code of any code type $C$ with $C_1=B_2$.
For any code $p$ of such a code type $C$, define ${\tt litter}^*(p)_B$ as the collection $\{(\alpha,p,B,\kappa+\lambda+1):\alpha<\kappa\}$.
%Define ${\tt litter}^*(p)^{\Delta}_B$, where $p$ is of such a code type $C$, as the set of all pairs $(S,B)$ where $S$ is the symmetric difference of ${\tt litter}^*(p)_B \subseteq {\tt clan}^*(B)$ and a small subset of ${\tt clan}^*(B)$.   
$\delta((\alpha,B,\kappa+\lambda)) = ({\tt litter}^*(\{(\alpha,B,\kappa+\lambda)\})_B,B)$.   The referents of seed litter precodes are called seed litters.  Notice that we are implicitly stipulating that there are at least $\kappa$ parents in each $\Pi(B)$ whose images under $f_B$ are precisely the typed singletons of their litter elements (any parent contains a single litter as an element).

A nonce precode for a near-litter is the collection of precodes for its elements.   If $N$ is a nonce precode, $\delta(N) = \delta``N$.

A triple $(T,\Sigma,A,\kappa+\lambda+2)$ is a precode if
$\delta``\Sigma$ is a support set and $T$ is a subset of $\delta^{-1}``(\tau(A))$ with the property that each element of $T$ of the form $(T',\Sigma',A',\kappa+\lambda+2)$
has $\Sigma \subseteq \Sigma'$ (this is an essential condition, as it avoids phenomena analogous to bound variable capture).   This code is of code type $A_1$.  We call these set precodes.  The referent  $\delta((T,\Sigma,A,\kappa+\lambda+2))$
is then the pair whose first projection is the collection of all $\pi(\delta(t))$ where $t \in T$ and $\pi$ is an allowable permutation fixing all elements of $\delta``\Sigma$ and whose second projection is $A$.  The precode $(T,\Sigma,A,\kappa+\lambda+2)$
may be conventionally written $(T,\Sigma,A,2)$.

A code for an atom is its sole precode.

For any element $x$ of a non-base type, the unique code $c$ such that $\delta(c)=x$ is the collection of all precodes $y$ such that $\delta(y)=x$ which are of the smallest possible set theoretical rank.   $\delta(c)$ for any such code $c$ is the sole element of $\delta``c$.

All codes and precodes are constructed in this way.

\end{description}

We will need a lemma asserting the existence of  a large collection of codes for elements of any ${\tt clan}(B)$ at the minimal set theoretical rank at which such codes appear, and moreover that the minimal rank does not depend on $B$.   This is direct, because the lowest rank precodes for elements of ${\tt clan}(B)$ are evidently those of the form $(\beta,(\alpha,B,\kappa+\lambda),B,\kappa+\lambda+1)$,
there are a large collection of these and they are all actually of the same rank (independent of $B$).

Notice that any FTS which has all elements of types and parent sets coded is isomorphic to one in which the base type objects actually coincide with their codes, as we stipulate henceforth.   We assume henceforth that the FTS in which we work has all elements of types and parent sets coded, and that each atom in the FTS coincides with its code.
So we can assume $\delta((\alpha,p,B,1))  =  (\alpha,p,B,1)$  for each base type index $B$;  a base type element is identical to its code, and to its sole precode.

We describe the action of an allowable permutation on a coded object in terms of an action on codes.   We will stipulate that we require in addition to the conditions stated above that allowable permutations fix all parents of seed litters.  We define an action $\pi^*$ on codes
such that if $c$ is a code or precode denoting $x$, $\pi^*(c)$ will be a code or precode denoting $\pi(x)$.   The action of $\pi^*$ on a code  $(\alpha,B,0)$ takes its referent
(a litter) to its elementwise image under $\pi^*$, a litter with the same parent (by the stipulation).
The action of $\pi^*$ on a code $(T,\alpha,B,1)$ for a non-exception will send it to $(\pi^*(T),\alpha',B,1)$, where the mapping of indices $\alpha$ to $\alpha'$ is a feature
of $\pi$ and $T$, and of course the action of $\pi^*$ on a code $(T,\alpha,B,1)$ for an exception will take it to some apparently unrelated $(U,\beta,B,1)$.
The action of $\pi^*$ on $(T,\Sigma,A,2)$ can be taken to be elementwise on $T$ and on $\Sigma$ (acting further elementwise on precodes for near-litters).  Finally,
the action of $\pi^*$ on a code will be to send a code containing $c$ to the set of codes with the same referent as $\pi^*(c)$ of minimal set theoretical rank.

The data we need to compute $\pi^*$ is the action of $\pi$ on its exceptions and the action of
$\pi$ on indices of atoms for each nonexception, associated with the code for the parent.
It is useful to note that we can construct an allowable permutation on the basis of proposed values at a locally small collection of exceptions (only a small number of exceptions in each litter);  seed litters map to a litter with the same parent elementwise; 
we can then supply the map on indices for  nonexceptions in each litter (list the nonexceptions in a litter in order of index
and the objects which are not images of exceptions in the target litter (we assume that we know the target litter because we have already computed the permutation on its parent; we know the exceptions and the images of exceptions at the outset) and map the first set to the second in a monotone way by index).  So we can compute an allowable permutation
extending any locally small injective map on atoms which respects clans, and the extended map will have no exceptions other than as dictated by the locally small map we start with.  Such an allowable permutation is called a substitution extension of the underlying locally small map.\index{locally small map}\index{computation of allowable permutations via codes}
\index{substitution extension}

Note that  if $\delta((T,\Sigma,A,2))=x$ and $\Sigma \subseteq \Sigma'$ we can easily get $\delta((T',\Sigma',A,2))=x$ for some $T'$:  let $T'$ be the set of all precodes for
images of referents of elements of $T$ under allowable permutations fixing the elements of $\Sigma$.

We define a strong support set $\Sigma$ as a support set in which each element has a code, and for each near-litter element $N$ of $\Sigma$  which is not a seed litter there is a subset of $\Sigma$ which is the support component of a set precode $p$ such that $\delta(p)$ is the parent of $N$ and $p$ is of minimal set theoretical rank among such precodes, and in addition all anomalous elements for $N$ belong to $\Sigma$. \index{strong support defined}\index{support, strong, defined}  Of course, any support set can be extended to a strong support set.  A strong support below type $A$ is a support set obtained by cutting down a strong support set to its elements of types downward extending $A$.

Here are two important lemmas.

\begin{description}

\item[Lemma 1:]  Let $\pi$ be an allowable permutation and let $u$ be an object of non-base type with a given strong support [below type $A$].  Let $\pi'$ be the substitution extension of the restriction of $\pi$ to atomic strong support elements of $u$
and exceptions of $\pi$ belonging to or mapped by $\pi$ into near-litters in the given strong support [below type $A$] of $u$ and possibly the identity map on some further collection of atoms.  Then $\pi'(u)=\pi(u)$.    We show this by showing that $\pi' \circ \pi^{-1}$ moves no element of the given strong support [below type $A$] of $u$.   Clearly it moves no atomic element of the support of $u$.  If it moved a near-litter element, consider one with a precode of the smallest possible set theoretical rank.  Without loss of generality, this precode can have strong support component.  It would fix
the parent of this near-litter, as otherwise it would have to move an element of each strong support of the parent including the one which is included in the strong support of $u$ and all elements of which have codes of smaller set theoretical rank [in the case of a strong support below $A$, a litter will only have its parent moved if its parent has in each of its strong supports some atomic element of a type downward extending $A$ which is moved; and some such moved object would be in the support we are using (substitution extensions don't act nontrivially on a code unless they act nontrivially on some element of some one of its strong supports)].    So $\pi' \circ \pi^{-1}$ must map an object into or out of the litter while fixing the parent of the litter.   But this is impossible, because $\pi$ and $\pi'$ have the same
action on any exception or image of an exception of either map in a near-litter in the strong support (and they both fix all anomalous elements for near-litter elements of the strong support, and additional exceptions which are fixed by the substitution extension will not be mapped into or out of litters).

\item[Lemma 2:]  We discuss a further simplification of support components of codes for elements of our interpreted type structure.  We claim that if $a$ belongs to the interpreted type structure
and has strong support $\Sigma$, it also has support $\Sigma'$, where $\Sigma'$ is the set of all elements of $\Sigma$ of types whose index extends $A$ downward.   This is obviously true for seed litters and for atoms.   Let $a$ be a set and let $\pi$ be an allowable permutation fixing all elements of $\Sigma'$.   We need to show that it fixes $a$.   Let $b \in a$ be of type $A'$.  By ind hyp $b$ has a support $\Sigma_2$ which is the restriction of a strong support extending $\Sigma$ to types downward extending $A'$.  Let $\pi'$
be a substitution extension of the union of the identity on atomic elements of $\Sigma \setminus \Sigma'$ and the restriction of $\pi$ to atomic elements of $\Sigma_2$ and exceptions of $\pi$ mapped into or out of elements of $\Sigma_2$.   The values $\pi(b)$ and $\pi'(b)$ agree by the Lemma as extended to strong supports below a type $A$, and $\pi'$ fixes $a$
because it fixes all atomic elements of its given strong support and so fixes all elements of its strong support, so $\pi$ (and similarly $\pi^{-1}$) sends elements of $a$ to elements of $a$ and so fixes $a$, and $\Sigma'$ is a support for $a$.

\end{description}

Substitution extensions can be used to control the complexity of the first component $T$ of a precode $(T,\Sigma,A,2)$ relative to the rank of $\Sigma$.  The referent of the code will not be changed if
actions of substitution extensions are applied to each code for an element of $T$ which move each atomic support component element of a $t \in T$ which is not either an element of $\Sigma$ or
an element of an element of $\Sigma$ to a code of minimal set theoretical rank (among codes for elements of the same clan).   We can do this because there is a large collection of atoms of minimal rank in each clan.  This may be supposed to have been done already for each (lower rank) element of $T$.   This process can be used to extend the support component of a set precode with a more economical effect on the first component.

We define the support closure of a set precode as the union of its support component and the support closures of all elements and parents of elements of its first component.  An atom code is the only element of its support closure.   A seed litter code has itself as the sole element of its support closure.

Every referent of a code has an optimal precode (not unique) whose support component is a strong support [below the type of its referent, if desired], and whose support closure contains only elements of its support component,
elements of elements of its support component, and atoms minimal in their clans.

We aim similarly to show that having the same referent is computable.   Equivalent reference of codes $(\alpha,B,0)$ is equality.   Equivalent reference of codes  $(T,\alpha,B,1)$
is computable if equivalent reference of the simpler objects $T$ is computable.   Equivalent reference of codes is computable iff equivalent reference of their elements is computable.
Everything hinges on computability of equivalent reference of set precodes.  $(T,\Sigma,A,2)$  is equivalent in reference to $(T',\Sigma',A,2)$ iff every image of the referent of
an element of $T$ under an allowable permutation fixing the elements of $\Sigma$ is equal to the image of some element of $T'$ under an allowable permutation fixing the
elements of $\Sigma'$.  We can further restrict to images under the substitution extensions described above, because the action of $\pi$ on a specific object will always coincide with its action on the substitution extension of its restriction to atomic strong support elements of the object and exceptions of $\pi$ which are in or mapped by $\pi$ into near-litter strong support elements of the object.\index{computation of equivalence of reference of codes}  We can further restrict to permutations whose exceptions are of rank less than the maximum of the ranks of the two precodes:  if a substitution extension of higher rank fixing all elements of $\Sigma$ mapped an element of $T$ to something which was not an image
of any element of $T'$ under a substitution extension fixing all elements of $\Sigma'$, the same result would be achieved by replacing all the exceptions and images of exceptions of the substitution extension serving as counterexample which are of too high rank with members of the same clans of the lowest possible rank.

Thus we can compute actions of formally represented allowable permutations
on codes without appealing to direct information about their referents, because the ability to compute equivalence of reference allows us to identify the codes of smallest set theoretical rank equivalent to a given code without complete information about its referent.

Membership of the referent of a code  in the referent of a set code in one of the interpretations of TSTU$_n$'s is also computable;  one computes whether the coded member
is the image under an allowable permutation of an element of the first component of the set code which fixes the items coded in the support component of the set code.

\newpage

\section{Constructing our target FTS from codes}

In this section we construct an FTS with clans from objects intended to be codes for its elements, as described in the previous section, but of course the construction of the codes needs to be recapitulated in a way which can be seen not to depend on the intended semantics.   The point being made here has already been made in the previous section, but it is better to lay it out clearly.

\begin{description}

\item[Definition (codes and precodes, independent of semantics):]

For any $\beta<\kappa$ and base type index $B$,  $(\alpha,B,\kappa+\lambda)$ (conventionally written $(\alpha,B,0)$) is a code of code type $B_1$.  These may be called seed litter codes.

For any code $T$ of code type $C$ with $C_1=B_2$ and $\alpha<\kappa$, $(\alpha,T,B,\kappa+\lambda+1)$ is a precode (conventionally written $(\alpha,T,B,1)$).   The code type of $(\alpha,B,1)$ is $B$.  These precodes are called atom codes.

We define ${\tt clan}^*(B)$ as the set of all precodes $(\alpha,T,B,1)$.  Define ${\tt litter}^*(T)_B$ as $\{(\alpha,T,B,1):\alpha<\kappa\}$ (when the elements are well-formed codes).

We define a near-litter code as a set of the form $\{(\alpha,T,B,1):\alpha<\kappa\} \Delta C$, where $C$ is a small subset of ${\tt clan}^*(B)$.  $x$ is called the parent of the near-litter code.  An element of $C$ is called an anomalous element for the near-litter code in question.  The code type of this code is $B_1$.

We define a coded support set as a small set of atom codes and near-litter codes.

The notion of set precode is defined by a mutual recursion on set theoretical rank with an equivalence relation on precodes and a notion of action of coded allowable permutations on precodes.

A strong coded support set is a coded support set $\Sigma$ such that if the parent code $x$ of a near-litter element of $\Sigma$ has elements of the form
$(T,\Sigma',A',2)$, then some such $\Sigma'$ is a subset of $\Sigma$, and any anomalous element for a near-litter element of $\Sigma$ belongs to $\Sigma$.

A tuple $(T,\Sigma,A,2)$ where $A$ is a type index, $\Sigma$ is a strong coded support set with elements with code type downward extending $A$,  and $T$ is a set of precodes of code type $A$  such that 
$(T',\Sigma',A',2) \in T$ implies $\Sigma \subseteq \Sigma'$, is a precode of code type $A_1$.  The support closure of  $(T,\Sigma,A,2)$ is the union of $\Sigma$ and all support closures of elements of $T$ (an atom code is the only element of its own support closure, and the same is true for a seed litter code).  [Lemma 2 above tells us that the restriction on support components will be removable if our structure turns out to be an FTS].

The code associated with a precode $x$ is either the precode $x$ itself if it is of the form $(\alpha,T,B,1)$ or the set of precodes of minimal set theoretical rank in the equivalence class
of $x$ under the equivalence relation to be introduced next.

We need to formally define an equivalence relation on precodes (intended to implement the relation of having the same referent, but we do not presuppose the semantics).  To do this, we first need to define the action of a coded allowable permutation on a precode.   A coded allowable permutation $\pi$ is determined by an injective map $\pi_0$ on codes of the shape $(\alpha,T,B,\kappa+\lambda+1)$, conventionally written $(\alpha,T,B,1)$ which maps
elements of each ${\tt clan}^*(B)$ to elements of the same ${\tt clan}^*(B)$ (it respects clans) and whose domain and range have small intersection with each set ${\tt litter}^*(T)$ (this property is called ``local smallness").

$\pi(\alpha,B,0) = (\alpha,B,0)$ if no $(\beta, (\alpha,B,0),B,1)$ is moved by $\pi$, and otherwise $\pi({\tt litter}^*(\alpha,B,0),\{{\tt litter}^*(\alpha,B,0)\},B,2)$.

$\pi(\alpha,T,B,1) = \pi_0(\alpha,T,B,1)$ if this is defined, and otherwise $(\alpha',\pi(T),B,1)$.  We describe the computation of $\alpha'$:  the elements
of ${\tt litter}^*(T)$ which are not in the domain of $\pi_0$ are mapped to the elements of ${\tt litter}^*(\pi(T))$ which are not in the range of $\pi_0$ bijectively in order of increasing index.  Both of these collections are of size $\kappa$, so this succeeds.

$\pi(T,\Sigma,A,2) = (\pi``T,\pi``\Sigma,A,2)$, with the added remark that if $L$ is a near litter code we define $\pi(L)$ as $\pi``L$.

The image under $\pi$ of a code $c$ which is an equivalence class of precodes is the collection of precodes of minimal rank equivalent to the image under $\pi$ of a selected element of $c$ (so we have some choice function for codes of this kind in the background;  it turns out not to  matter which one we select, but it is important to select just one so that we are assured that the image of a code is a code).

We now define equivalence of precodes. 

We define $u \in^* (T,\Sigma,A,2)$ as holding iff $u$ is of code type $A$ and there is $t \in T$ and $\pi$ a coded allowable permutation fixing each element of $\Sigma$ such that $\pi(t)$ is equivalent to $u$.

Precodes of this form are equivalent iff both are atom codes and are equal or both are not atom codes and their preimages under $\in^*$ have the same elements of rank lower than the maximum of the ranks of the two precodes (which implies in fact that the full preimages have the same elements).   

The preimage under $\in^*$ of codes $(\alpha,B,0)$ needs to be defined to complete this:  a precode stands in the relation $\in^*$ to  $(\alpha,B,0)$ iff
it is an atom code with $\{(\alpha,B,0)\}$ as parent.

One then takes the elements of ${\tt clan}^*(B)$ to be the elements of type $B$ for each base type index $B$, and defines the referents of each precode and code as in the previous section, to obtain our target FTS, the elements of each type with non-base index being exactly the elements of the range of $\delta$ thus defined. 

One needs to verify that the codes of each code type make up a set, not a proper class.

There are $\kappa$ elements given initially in each non-base code type (seed litter codes).  Any element of a non-base type $A$ determines $\kappa$ elements of the type $A \cup \{0\}$ (atom precodes = atom codes).   An element of any non-base type $A$ (a set precode, correlated many-to-one with set codes)  is determined by an arbitrary collection of elements of some code type $A \cup \{\beta\}$ and a small collection of elements of code types
downward extending $A$.

Note that for any code of code type $D$, type indices appearing as immediate components
of the code will downward extend $D$.  Further, for any code of type $D$, a code appearing as an immediate component of the code will be of a type downward extending $D$,
unless it is the parent component of the code of type $D$, in which case $D$ must be a base type code, and the parent code in question will be of code type $D_1\cup \{\delta\}$ for
some $\delta\neq 0$ dominated by $D$.  Notice that this cannot be iterated:  there is no way for a code of code type $D$ to include a code as a component with index not properly downward extending 
$D_1$, and if $D$ is not a base type index, there is no way for the code to contain as a component any code with type not downward extending $D$.

Define $D^{\circ}$ as $D \setminus \{{\tt max}(D)\}$ for any type index $D$.   For any code, consider the operation of replacing every component type index $C$ with
$C^{\circ}$.  This will preserve well-formedness of codes $(\alpha,B,0)$ as long as the base type index $B$ has at least four elements.   This will preserve well-formedness
of $(\alpha,T,A,1)$ again as long as the base type index $A$ has at least four elements.  It will preserve well-formedness of $(T,\Sigma,A,2)$ if $A$ has at least three elements (so that any base type index downward extending it has at least four elements).  For any code of a type $D$ with index with at least three nonzero elements, uniform application of this operation gives a code.   Further, this operation sends equivalent codes to equivalent codes and inequivalent codes to inequivalent codes:  any such type $D$ is a set (i.e, there is just a set of codes of type $D$, which correlate with the equivalence classes of precodes of type $D$) if type $D^{\circ}$ is a set.

The types which remain to be considered are types $\{\alpha\}$, $\{\alpha,\beta\}$ and $\{\alpha,\beta,0\}$.   An atom of type $\{\alpha,\beta,0\}$ is determined by a code parent of some type $\{\alpha,\beta'\}$ and a small ordinal index.  Type $\{\alpha,\beta,0\}$ will thus be a set if each type $\{\alpha,\beta'\}$ is a set.  We consider the type $\{\alpha,\beta\}$,
Each element of type $\{\alpha,\beta\}$ is determined by a subcollection of a type $\{\alpha,\beta,\gamma\}$ for $\gamma<\beta$.  In each case except that of
$\gamma=0$, we can observe that type $\{\alpha,\beta,\gamma\}$ is a set iff type $\{\beta,\gamma\}$ is a set, which is true by inductive hypothesis (induction on the largest element of the type index).

We have to argue that no difficulty arises from the fact that elements of type $\{\alpha,\beta\}$ can be determined by subcollections of type $\{\alpha,\beta,0\}$.  The key fact is that the subcollections of type $\{\alpha,\beta,0\}$ are quite impoverished:  each such set has a small support made up of atoms and near-litters, and it is straightforward to see that the extension implemented (the preimage of the code under $\in^*$) will have small symmetric difference from a small or co-small union of litters.  Each such set can be supposed to have a support consisting entirely of litters and atoms (pull anomalous elements of near-litter elements out into the support themselves).  Thus each subcollection of $\{\alpha,\beta,0\}$ is determined by a small collection of either codes for elements of types $\{\alpha,\beta'\}$ (of lower rank than the code for the subcollection) or pairs of such codes and a small ordinal
(again of lower set theoretical rank).  We can consider all the types $\{\alpha,\beta'\}$ as being constructed in stages:  initially we have the subcollections of types $\{\alpha,\beta',\gamma\}$ for $\gamma \neq 0$ (these types being isomorphic to types $\{\beta,\gamma\}$ already constructed) and the seed litters as subcollections of each type $\{\alpha,\beta,0\}$ (and of course the elements of the seed litters as initial atoms).   We then go through stages indexed by small ordinals:  at each stage we can use previously constructed elements of the types $\{\alpha,\beta'\}$ as parents of new atoms in each type $\{\alpha,\beta'',0\}$, then use small collections of previously constructed elements of the types $\{\alpha,\beta'\}$
and $\{\alpha,\beta'',0\}$
to specify new subcollections of the types $\{\alpha,\beta'',0\}$, which will in their turn serve as parents of new atoms and so forth.   This process will terminate at stage $\kappa$.  Notice that all the new objects added after the initial stage are atoms and typed sets of atoms; no new subcollections of types $\{\alpha,\beta,\gamma\}$ ($\gamma \neq 0$) are added.  

Once it is verified that each code type is a set, it should be clear that identifying each atom code as its own referent and defining the referents of all other codes and precodes
as in the previous section will give an FTS in which every object is coded and every code has a referent.

To show comprehension, we need to show that every symmetric set is codable using a strong support extending any given support set.  This appears not to be hard.  Every atom is coded, trivially (with any support set containing the atom itself).    Every symmetric set has support, and in fact has strong support (this is built into our syntax).   Suppose that $S$ is a symmetric set of type $A$ elements with support $\Sigma$.  Suppose (ind hyp) that each element
of $S$ can be coded with support extending any given support set, and thus can be coded with a support extending $\Sigma$.  Choose codes for representatives of each orbit in $S$ under allowable permutations respecting $\Sigma$; each of these supports must have support component extending $\Sigma$.
Apply allowable permutations to each of these codes to convert any support elements in these codes which are neither in $\Sigma$ nor in an element of $\Sigma$ to codes of minimal set theoretical rank in their clan (while fixing $\Sigma$; this can be done with substitution extensions).  The collection of representive codes thus obtained will serve as the $T$ component
of a code for the typed set $(S,A)$.  By Lemma 2, we can restrict the support component to objects with type downward extending $A_1$.

The fact that all symmetric sets are coded ensures that the structures for the language of TSTU$_n$ extracted from our FST actually satisfy TSTU$_n$.  It is easy to show that
a subset of a type defined using a comprehension axiom of TSTU as interpreted in any of the structures for the language of TSTU$_n$ embedded in the FST  and using symmetric parameters will be symmetric, and by the results of the previous paragraph codable.

Further, it is clear that the map sending codes of type $D$ to codes of type $D^{\circ}$ preserves the truth values of all sentences in the interpretations of TSTU$_n$ 
embedded in our structure for which $n$ is at least 4.  The operation on codes thus implemented commutes with our internal representations of equality and membership.  Conversely, adding additional dominant elements to the type indices in such an interpretation will not change the theory
of the relevant types.  In general, the theory of TSTU$_n$ associated with a base type $B$ with $n \geq 4$ elements will be the same as that associated with a base type
$A \cup B$ where $A$ dominates $B$:  the theory of a model of TSTU$_n$ with type $B$ as its type 0 will be determined by $B \setminus B_n$.

\end{description}

\newpage

\section{The final move (replicating Jensen's argument for Con(NFU))}

The appropriate modification of Jensen's argument then gives the consistency of TSTU + ``there are no more atoms than sets" + Ambiguity, which entails the consistency of NF by results of Boffa and Specker.

Comprehension holds in the interpretations of TSTU because all sets provided are symmetric by construction, any set which witnesses an instance of comprehension and has symmetric parameters is symmetric, and we have just shown that all symmetric subsets of types are in fact present in the interpretations.

We have shown above that the theory of the first $n$ types of the interpretation associated with a type index $A$ depends only on the set $A \setminus A_n$ of the first
$n$ elements of $A$ (as long as $A$ has at least three nonzero elements, which is not an obstruction).   Choose a finite set $\Sigma$ of formulas of the language of TSTU.  There will be an $n$ such that all formulas in $\Sigma$ are in the language of
TSTU$_n$.  We thus determine a partition of the $n$-element subsets $A$ of $\lambda$ determined by the truth values of the sentences in $\Sigma$ in interpretations
of TSTU with index having the elements of $A$ as their smallest $n$ elements.   This partition has an infinite homogeneous set $H$ by Ramsey's theorem.   Any interpretation of TSTU based on a subset
of $H$ with at least $n+1$ elements satisfies ambiguity for $\Sigma$.   Thus the full ambiguity scheme is consistent by compactness so we obtain consistency of
TSTU + Ambiguity + ``there are no more urelements than sets" (because there are no more urelements than sets in any type with index greater than one in our interpretations, because the maps $f_B$ are internally represented, such representations being symmetric).   By Specker's results, NFU + ``there are no more urelements than sets" is consistent,
and so by Boffa's result NF is consistent.

\newpage

\section{Conclusions to be drawn about NF}

The conclusions to be drawn about NF are rather unexciting ones.

By choosing the parameter $\lambda$ to be larger (and so to have stronger partition properties) one can show the consistency of a hierarchy of extensions of NF similar to extensions of NFU known to be consistent:  one can replicate Jensen's construction of $\omega$- and $\alpha$-models of NFU to get $\omega$- and $\alpha$-models of NF  (e.g.,  see how we proved the existence of $\alpha$-models for the mildly impredicative fragment NFI of NF in \cite{tangled}).
One can show the consistency of NF + Rosser's Axiom of Counting (see \cite{rosser}), Henson's Axiom of Cantorian Sets (see \cite{henson}), or the author's axioms of Small and Large Ordinals (see \cite{mybook}, \cite{strongaxioms}, \cite{nfub}) in basically the same way as in NFU.

It seems clear that this argument, suitably refined, shows that the consistency strength of NF is exactly the minimum possible on previous information, that of
TST + Infinity, or Mac Lane set theory (Zermelo set theory with comprehension restricted to bounded formulas).
Actually showing that the consistency strength is the very lowest possible might be technically tricky, of course.  I have not been concerned to do this here.  It is clear from what is done here that NF is much weaker than ZFC.

By choosing the parameter $\kappa$ to be large enough, one can get local versions of Choice for sets as large as desired.   The minimum value $\omega_1$ for $\kappa$ already enforces Denumerable Choice (Rosser's assumption in his book) or Dependent Choices.  It is unclear whether one can get a linear order on the universe or the Prime Ideal Theorem:  that would require major changes in this construction.  But certainly the question of whether NF has interesting consequences for familiar mathematical structures such as the continuum is answered in the negative:  set $\kappa$ large enough and what our model of NF will say about such a structure will be entirely in accordance with what our original model of ZFC said.
It is worth noting that the models of NF that we obtain are not $\kappa$-complete in the sense of containing every
subset of their domains of size $\kappa$; it is well-known that a model of NF cannot contain all {\em countable\/} subsets
of its domain.  But the models of TST from which its theory is constructed will be $\kappa$-complete, so combinatorial consequences of $\kappa$-completeness will hold in the model of NF (which could further be made a $\kappa$-model by making $\lambda$ large enough).

The consistency of NF with the existence of a linear order on the universe or the Prime Ideal theorem is not established:  questions about many weak versions of Choice remain.

The question of Maurice Boffa as to whether there is an $\omega$-model of TNT (the theory of negative types, that is TST with all integers as types, proposed by Hao Wang  (\cite{tnt})) is settled:  an $\omega$-model of NF yields an $\omega$-model of TNT instantly.  This work does not answer the question, very interesting to the author, of whether there is a model of TNT in which every set is symmetric under permutations of some lower type.

The question of the possibility of cardinals of infinite Specker rank at least in TSTU  is answered  and can be answered in ZFA with the same tools with not too much additional work (the cardinalities of the types will have infinite Specker rank if the minimal index of their type is infinite), and we see that the existence of such cardinals doesn't require much consistency strength.  For those not familiar with this question, the Specker tree of a cardinal is the tree with that cardinal at the top and the children of each node (a cardinal) being its preimages under $\alpha \mapsto 2^{\alpha}$.   It is a theorem of Forster (a corollary of a well known theorem of Sierpinski) that the Specker tree of a cardinal is well-founded  (see \cite{forster}, p. 48), so has an ordinal rank, which we call the Specker rank of the cardinal.   NF + Rosser's axiom of counting proves that the Specker rank of the cardinality of the universe is infinite;  it was unknown until this point whether the existence of a cardinal of infinite Specker rank was consistent even with type theory.

This work does not answer the question as to whether NF proves the existence of infinitely many infinite cardinals (discussed in \cite{forster}, p. 52).  A model with only finitely many infinite cardinals would have to be constructed in a totally different way.

A natural general question which arises is, to what extent are {\em all\/} models of NF like the ones indirectly shown to exist here?  Do any of the features of this construction reflect facts about the universe of NF which we have not yet proved as theorems, or are there quite different models of NF as well?

\newpage

\section{References and Index}

\begin{thebibliography}{99}

\bibitem{finiteaxiomatization}  Hailperin, T.  
``A set of axioms for logic". 
Journal of Symbolic Logic 9 (1944), pp. 1-19.

\bibitem{boffaperms} Maurice Boffa, ``Entre {\em NF\/} et {\em
NFU\/},'' {\em Comptes Rendues de l'Academie des Sciences de
Paris\/}, series A, 277 (1973), pp. 821--2.

\bibitem{forster}  Forster, T.E. [1995] 
Set Theory with a Universal Set, exploring an untyped Universe 
Second edition. Oxford Logic Guides, Oxford University Press, Clarendon Press, Oxford.

\bibitem{henson}   Henson, C.W. [1973a] 
Type-raising operations in NF. 
Journal of Symbolic Logic 38 , pp. 59-68.

\bibitem{tangled}  Holmes, M.R.
``The equivalence of NF-style set theories with "tangled" type theories; the construction of omega-models of predicative NF (and more)". 
{\em Journal of Symbolic Logic\/} 60 (1995), pp. 178-189.

\bibitem{mybook}  Holmes, M. R. [1998] 
Elementary set theory with a universal set. 
volume 10 of the Cahiers du Centre de logique, Academia, Louvain-la-Neuve (Belgium), 241 pages, ISBN 2-87209-488-1. See here for an on-line errata slip. By permission of the publishers, a corrected text is published online; an official second edition will appear online eventually.

\bibitem{strongaxioms}   Holmes, M. R. [2001]
Strong Axioms of infinity in NFU.
Journal of Symbolic Logic, 66, no. 1, pp. 87-116.  \newline(``Errata in `Strong
Axioms of Infinity in NFU' ", JSL, vol. 66, no. 4 (December
2001), p. 1974, reports some errata and provides corrections).

\bibitem{zfa}  Jech, Thomas, {\em The axiom of choice\/}, North-Holland 1973, p. 46

\bibitem{nfu}  Jensen, R.B.
``On the consistency of a slight(?) modification of Quine's NF". 
{\em Synthese\/} 19 (1969), pp. 250-263.

\bibitem{nf}  Quine, W.V.,
``New Foundations for Mathematical Logic". 
{\em American Mathematical Monthly\/} 44 (1937), pp. 70-80. 

\bibitem{ramsey}  Ramsey, F.P., 1926, ``The foundations of mathematics,   {\em Proceedings of the London Mathematical Society\/}, s225 (1), 338384.

\bibitem{rosser}  Rosser, J. B. [1978] 
Logic for mathematicians, second edition. 
Chelsea Publishing.

\bibitem{scottstrick}  Scott, Dana, ``Definitions by abstraction in axiomatic set theory",  {\em Bull. Amer. Math.
Soc.}, vol. 61, p. 442, 1955.

\bibitem{nfub}  Solovay, R, ``The consistency strength of NFUB",  preprint on {\tt arXiv.org}, {\tt arXiv:math/9707207 [math.LO]}

\bibitem{notac}  Specker, E.P.
``The axiom of choice in Quine's new foundations for mathematical logic". 
{\em Proceedings of the National Academy of Sciences of the USA\/} 39 (1953), pp. 972-975.

\bibitem{ambiguity}  Specker, E.P. [1962] 
``Typical ambiguity". 
{\em Logic, methodology and philosophy of science\/}, ed. E. Nagel, Stanford University Press, pp. 116-123.

\bibitem{tnt}  Wang, H. [1952] 
Negative types.

\bibitem{wang}  Wang, Hao, {\em Logic, Computers and Sets\/}, Chelsea 1970, pp. 402-415.

\bibitem{pm}  Whitehead, A. N.,  and Russell B., {\em Principia  Mathematica, second edition\/}, 3 vols.  Cambridge University Press, 1927.

\bibitem{pair} Wiener, N., 1914, ``A simplification of the logic of relations,  {\em Proceedings of the Cambridge Philosophical Society\/}, 17: 387390.



\end{thebibliography}

\newpage

\printindex


\end{document}

