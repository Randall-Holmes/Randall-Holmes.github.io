\documentclass[12pt]{article}

\usepackage{amssymb}

\title{Implementation of Zermelo's work of 1908 in Lestrade:  Part V, working out the consequences of the main result of part IV}

\author{M. Randall Holmes}

\begin{document}

\maketitle

\section{Introduction}
 
This document was originally titled as an essay on the proposition that mathematics is what can be done in Automath (as opposed to what can be done in ZFC, for example).  Such an essay is still in in my mind, but this particular document has transformed itself into the large project of implementing Zermelo's two important set theory papers of 1908 in Lestrade, with the further purpose of exploring the actual capabilities of Zermelo's system of 1908 as a mathematical foundation, which we think are perhaps underrated.

This is a new version of this document in modules, designed to make it possible to work more efficiently without repeated execution of slow log files when they do not need to be revisited.

\section{Consequences of the result of Part IV}

\begin{verbatim}Lestrade execution:


load whatismath4

open
clearcurrent


   define Mbold:Mbold2 Misset thelawchooses


>>    Mbold: [((Misset Mbold2 thelawchooses):
>>         obj)]
>>      {move 1}



   declare A1 obj

>>    A1: obj {move 2}



   declare B1 obj

>>    B1: obj {move 2}



   declare aev that A1 E Mbold

>>    aev: that (A1 E Mbold) {move 2}



   declare bev that B1 E Mbold

>>    bev: that (B1 E Mbold) {move 2}



   define Mboldstrongtotal aev bev : Mboldstrongtotal2 \
      Misset, thelawchooses, aev bev

>>    Mboldstrongtotal: [(.A1_1:obj),(aev_1:
>>         that (.A1_1 E Mbold)),(.B1_1:obj),(bev_1:
>>         that (.B1_1 E Mbold)) => (Mboldstrongtotal2(Misset,
>>         thelawchooses,aev_1,bev_1):that ((.B1_1
>>         <<= prime2(thelaw,.A1_1)) V (.A1_1
>>         <<= .B1_1)))]
>>      {move 1}



   define Mboldtotal aev bev : Mboldtotal2 \
      Misset, thelawchooses, aev bev

>>    Mboldtotal: [(.A1_1:obj),(aev_1:that (.A1_1
>>         E Mbold)),(.B1_1:obj),(bev_1:that (.B1_1
>>         E Mbold)) => (Mboldtotal2(Misset,thelawchooses,
>>         aev_1,bev_1):that ((.B1_1 <<= .A1_1)
>>         V (.A1_1 <<= .B1_1)))]
>>      {move 1}



   define Mboldtheta: Mboldtheta2 Misset \
      thelawchooses

>>    Mboldtheta: [((Misset Mboldtheta2 thelawchooses):
>>         that thetachain1(M,thelaw,(Misset Mbold2
>>         thelawchooses)))]
>>      {move 1}



   declare P obj

>>    P: obj {move 2}



   define prime P: prime2 thelaw, P

>>    prime: [(P_1:obj) => (prime2(thelaw,P_1):
>>         obj)]
>>      {move 1}



   declare Pev that P <<= M

>>    Pev: that (P <<= M) {move 2}



   declare x2 obj

>>    x2: obj {move 2}



   declare Pev2 that Exists[x2=>x2 E P] \
      



>>    Pev2: that Exists([(x2_1:obj) => ((x2_1
>>         E P):prop)])
>>      {move 2}



   declare x obj

>>    x: obj {move 2}



   open

      declare x1 obj

>>       x1: obj {move 3}



      define Pset: Set Mbold [x1 => P <<= \
            x1] \
         



>>       Pset: [((Mbold Set [(x1_1:obj) => ((P
>>               <<= x1_1):prop)])
>>            :obj)]
>>         {move 2}



      define P0 : Intersection(Pset,M)

>>       P0: [((Pset Intersection M):obj)]
>>         {move 2}



      goal that P0 E Mbold

>>       Goal: that (P0 E Mbold)

      define line1: Ui M,Ui Pset,(Simp2 Simp2 \
         Simp2 Mboldtheta)

>>       line1: [((M Ui (Pset Ui Simp2(Simp2(Simp2(Mboldtheta))))):
>>            that (((Pset <<= (Misset Mbold2
>>            thelawchooses)) & (M E Pset)) ->
>>            ((Pset Intersection M) E (Misset
>>            Mbold2 thelawchooses))))]
>>         {move 2}



      define line2: Fixform(Pset <<= Mbold, \
         Sepsub2(Separation3 Refleq Mbold,Refleq \
         Pset))

>>       line2: [(((Pset <<= Mbold) Fixform
>>            (Separation3(Refleq(Mbold)) Sepsub2
>>            Refleq(Pset))):that (Pset <<= Mbold))]
>>         {move 2}



      define line3: Fixform(M E Pset,Iff2(Conj \
         Simp1 Mboldtheta Pev,Ui M,Separation4 \
         Refleq Pset))

>>       line3: [(((M E Pset) Fixform ((Simp1(Mboldtheta)
>>            Conj Pev) Iff2 (M Ui Separation4(Refleq(Pset))))):
>>            that (M E Pset))]
>>         {move 2}



      define line4: Fixform(P0 E Mbold,Mp \
         (Conj line2 line3, line1))

>>       line4: [(((P0 E Mbold) Fixform ((line2
>>            Conj line3) Mp line1)):that (P0
>>            E Mbold))]
>>         {move 2}



      define p0: thelaw P0

>>       p0: [(thelaw(P0):obj)]
>>         {move 2}



      goal that p0 E P

>>       Goal: that (p0 E P)

      open

         declare z obj

>>          z: obj {move 4}



         declare zev that z E P

>>          zev: that (z E P) {move 4}



         goal that z E P0

>>          Goal: that (z E P0)

         define line6 z: Ui z,Separation4 \
            Refleq P0

>>          line6: [(z_1:obj) => ((z_1 Ui Separation4(Refleq(P0))):
>>               that ((z_1 E (M Set [(x_8:obj)
>>                  => (Forall([(B_9:obj) => (((B_9
>>                     E Pset) -> (x_8 E B_9)):
>>                     prop)])
>>                  :prop)]))
>>               == ((z_1 E M) & Forall([(B_10:
>>                  obj) => (((B_10 E Pset) ->
>>                  (z_1 E B_10)):prop)]))
>>               ))]
>>            {move 3}



         define line7 zev: Mpsubs zev Pev


>>          line7: [(.z_1:obj),(zev_1:that (.z_1
>>               E P)) => ((zev_1 Mpsubs Pev):
>>               that (.z_1 E M))]
>>            {move 3}



         open

            declare B obj

>>             B: obj {move 5}



            open

               declare Bev that B E Pset


>>                Bev: that (B E Pset) {move
>>                  6}



               goal that z E B

>>                Goal: that (z E B)

               define line8 Bev: Mpsubs (zev, \
                  Simp2(Iff1(Bev,Ui B,Separation4 \
                  Refleq Pset)))

>>                line8: [(Bev_1:that (B E Pset))
>>                     => ((zev Mpsubs Simp2((Bev_1
>>                     Iff1 (B Ui Separation4(Refleq(Pset)))))):
>>                     that (z E B))]
>>                  {move 5}



               close

            define line9 B: Ded line8

>>             line9: [(B_1:obj) => (Ded([(Bev_2:
>>                     that (B_1 E Pset)) => ((zev
>>                     Mpsubs Simp2((Bev_2 Iff1
>>                     (B_1 Ui Separation4(Refleq(Pset)))))):
>>                     that (z E B_1))])
>>                  :that ((B_1 E Pset) -> (z
>>                  E B_1)))]
>>               {move 4}



            close

         define line10 zev: Ug line9

>>          line10: [(.z_1:obj),(zev_1:that
>>               (.z_1 E P)) => (Ug([(B_3:obj)
>>                  => (Ded([(Bev_4:that (B_3
>>                     E Pset)) => ((zev_1 Mpsubs
>>                     Simp2((Bev_4 Iff1 (B_3
>>                     Ui Separation4(Refleq(Pset)))))):
>>                     that (.z_1 E B_3))])
>>                  :that ((B_3 E Pset) -> (.z_1
>>                  E B_3)))])
>>               :that Forall([(B_8:obj) => (((B_8
>>                  E Pset) -> (.z_1 E B_8)):prop)]))
>>               ]
>>            {move 3}



         define line11 zev: Fixform(z E P0, \
            Iff2(Conj line7 zev line10 zev, \
            line6 z))

>>          line11: [(.z_1:obj),(zev_1:that
>>               (.z_1 E P)) => (((.z_1 E P0)
>>               Fixform ((line7(zev_1) Conj line10(zev_1))
>>               Iff2 line6(.z_1))):that (.z_1
>>               E P0))]
>>            {move 3}



         declare zev2 that z E P

>>          zev2: that (z E P) {move 4}



         define linea11 z: Ded [zev2 => line11 \
               zev2] \
            



>>          linea11: [(z_1:obj) => (Ded([(zev2_2:
>>                  that (z_1 E P)) => (line11(zev2_2):
>>                  that (z_1 E P0))])
>>               :that ((z_1 E P) -> (z_1 E P0)))]
>>            {move 3}



         declare w obj

>>          w: obj {move 4}



         define line12 zev: Fixform(Exists[w \
               => w E P0] \
            , Ei1 z line11 zev)

>>          line12: [(.z_1:obj),(zev_1:that
>>               (.z_1 E P)) => ((Exists([(w_2:
>>                  obj) => ((w_2 E P0):prop)])
>>               Fixform (.z_1 Ei1 line11(zev_1))):
>>               that Exists([(w_4:obj) => ((w_4
>>                  E P0):prop)]))
>>               ]
>>            {move 3}



         close

      define line13: Eg Pev2 line12

>>       line13: [((Pev2 Eg [(.z_3:obj),(zev_3:
>>               that (.z_3 E P)) => ((Exists([(w_4:
>>                  obj) => ((w_4 E P0):prop)])
>>               Fixform (.z_3 Ei1 ((.z_3 E P0)
>>               Fixform (((zev_3 Mpsubs Pev)
>>               Conj Ug([(B_9:obj) => (Ded([(Bev_10:
>>                     that (B_9 E Pset)) => ((zev_3
>>                     Mpsubs Simp2((Bev_10 Iff1
>>                     (B_9 Ui Separation4(Refleq(Pset)))))):
>>                     that (.z_3 E B_9))])
>>                  :that ((B_9 E Pset) -> (.z_3
>>                  E B_9)))]))
>>               Iff2 (.z_3 Ui Separation4(Refleq(P0))))))):
>>               that Exists([(w_2:obj) => ((w_2
>>                  E P0):prop)]))
>>               ])
>>            :that Exists([(w_22:obj) => ((w_22
>>               E P0):prop)]))
>>            ]
>>         {move 2}



      define linea13: Fixform(P<<= P0,Conj(Ug \
         linea11,Conj(Simp1 Simp2 Pev,Separation3 \
         Refleq P0)))

>>       linea13: [(((P <<= P0) Fixform (Ug([(z_2:
>>               obj) => (Ded([(zev2_3:that (z_2
>>                  E P)) => (((z_2 E P0) Fixform
>>                  (((zev2_3 Mpsubs Pev) Conj
>>                  Ug([(B_7:obj) => (Ded([(Bev_8:
>>                        that (B_7 E Pset)) =>
>>                        ((zev2_3 Mpsubs Simp2((Bev_8
>>                        Iff1 (B_7 Ui Separation4(Refleq(Pset)))))):
>>                        that (z_2 E B_7))])
>>                     :that ((B_7 E Pset) ->
>>                     (z_2 E B_7)))]))
>>                  Iff2 (z_2 Ui Separation4(Refleq(P0))))):
>>                  that (z_2 E P0))])
>>               :that ((z_2 E P) -> (z_2 E P0)))])
>>            Conj (Simp1(Simp2(Pev)) Conj Separation3(Refleq(P0))))):
>>            that (P <<= P0))]
>>         {move 2}



      define line14: Fixform(p0 E P0,thelawchooses(Sepsub2 \
         Misset Refleq P0,line13))

>>       line14: [(((p0 E P0) Fixform ((Misset
>>            Sepsub2 Refleq(P0)) thelawchooses
>>            line13)):that (p0 E P0))]
>>         {move 2}



      open

         declare absurdhyp that ~(p0 E P)


>>          absurdhyp: that ~((p0 E P)) {move
>>            4}



         open

            declare Q obj

>>             Q: obj {move 5}



            open

               declare Qev that Q E P

>>                Qev: that (Q E P) {move 6}



               define line15 Qev: line11 \
                  Qev

>>                line15: [(Qev_1:that (Q E
>>                     P)) => (line11(Qev_1):that
>>                     (Q E P0))]
>>                  {move 5}



               open

                  declare eqtest that Q E \
                     Usc p0

>>                   eqtest: that (Q E Usc(p0))
>>                     {move 7}



                  define line16 eqtest:Inusc1 \
                     eqtest

>>                   line16: [(eqtest_1:that
>>                        (Q E Usc(p0))) => (Inusc1(eqtest_1):
>>                        that (Q = p0))]
>>                     {move 6}



                  define line17 eqtest: Mp(Qev, \
                     Subs1(Eqsymm line16 eqtest, \
                     absurdhyp))

>>                   line17: [(eqtest_1:that
>>                        (Q E Usc(p0))) => ((Qev
>>                        Mp (Eqsymm(line16(eqtest_1))
>>                        Subs1 absurdhyp)):that
>>                        ??)]
>>                     {move 6}



                  close

               define line18 Qev : Negintro \
                  line17

>>                line18: [(Qev_1:that (Q E
>>                     P)) => (Negintro([(eqtest_2:
>>                        that (Q E Usc(p0)))
>>                        => ((Qev_1 Mp (Eqsymm(Inusc1(eqtest_2))
>>                        Subs1 absurdhyp)):that
>>                        ??)])
>>                     :that ~((Q E Usc(p0))))]
>>                  {move 5}



               define line19 Qev: Fixform(Q \
                  E prime P0,Iff2(Conj(line15 \
                  Qev,line18 Qev),Ui Q,Separation4 \
                  Refleq (prime P0)))

>>                line19: [(Qev_1:that (Q E
>>                     P)) => (((Q E prime(P0))
>>                     Fixform ((line15(Qev_1)
>>                     Conj line18(Qev_1)) Iff2
>>                     (Q Ui Separation4(Refleq(prime(P0)))))):
>>                     that (Q E prime(P0)))]
>>                  {move 5}



               close

            define line20 Q: Ded line19

>>             line20: [(Q_1:obj) => (Ded([(Qev_2:
>>                     that (Q_1 E P)) => (((Q_1
>>                     E prime(P0)) Fixform ((line11(Qev_2)
>>                     Conj Negintro([(eqtest_3:
>>                        that (Q_1 E Usc(p0)))
>>                        => ((Qev_2 Mp (Eqsymm(Inusc1(eqtest_3))
>>                        Subs1 absurdhyp)):that
>>                        ??)]))
>>                     Iff2 (Q_1 Ui Separation4(Refleq(prime(P0)))))):
>>                     that (Q_1 E prime(P0)))])
>>                  :that ((Q_1 E P) -> (Q_1 E
>>                  prime(P0))))]
>>               {move 4}



            save

            close

         define line21 absurdhyp: Fixform(P \
            <<= prime P0,Conj(Ug line20,Conj(Add2(P=0, \
            Pev2),Separation3 Refleq prime \
            P0)))

>>          line21: [(absurdhyp_1:that ~((p0
>>               E P))) => (((P <<= prime(P0))
>>               Fixform (Ug([(Q_4:obj) => (Ded([(Qev_5:
>>                     that (Q_4 E P)) => (((Q_4
>>                     E prime(P0)) Fixform ((line11(Qev_5)
>>                     Conj Negintro([(eqtest_6:
>>                        that (Q_4 E Usc(p0)))
>>                        => ((Qev_5 Mp (Eqsymm(Inusc1(eqtest_6))
>>                        Subs1 absurdhyp_1)):
>>                        that ??)]))
>>                     Iff2 (Q_4 Ui Separation4(Refleq(prime(P0)))))):
>>                     that (Q_4 E prime(P0)))])
>>                  :that ((Q_4 E P) -> (Q_4 E
>>                  prime(P0))))])
>>               Conj (((P = 0) Add2 Pev2) Conj
>>               Separation3(Refleq(prime(P0)))))):
>>               that (P <<= prime(P0)))]
>>            {move 3}



         define line22 absurdhyp: Ui prime \
            P0, Simp2 Iff1(line14,Ui p0,Separation4 \
            Refleq P0)

>>          line22: [(absurdhyp_1:that ~((p0
>>               E P))) => ((prime(P0) Ui Simp2((line14
>>               Iff1 (p0 Ui Separation4(Refleq(P0)))))):
>>               that ((prime(P0) E Pset) -> (p0
>>               E prime(P0))))]
>>            {move 3}



         define linea23 absurdhyp: Mp(line4, \
            Ui P0,Simp1 Simp2 Simp2 Mboldtheta)


>>          linea23: [(absurdhyp_1:that ~((p0
>>               E P))) => ((line4 Mp (P0 Ui Simp1(Simp2(Simp2(Mboldtheta))))):
>>               that (prime2(thelaw,P0) E (Misset
>>               Mbold2 thelawchooses)))]
>>            {move 3}



         define line23 absurdhyp: Fixform((prime \
            P0) E Pset,Iff2(Conj(linea23 absurdhyp, \
            line21 absurdhyp),Ui prime P0, \
            Separation4 Refleq Pset))

>>          line23: [(absurdhyp_1:that ~((p0
>>               E P))) => (((prime(P0) E Pset)
>>               Fixform ((linea23(absurdhyp_1)
>>               Conj line21(absurdhyp_1)) Iff2
>>               (prime(P0) Ui Separation4(Refleq(Pset))))):
>>               that (prime(P0) E Pset))]
>>            {move 3}



         define line24 absurdhyp: Mp line23 \
            absurdhyp line22 absurdhyp

>>          line24: [(absurdhyp_1:that ~((p0
>>               E P))) => ((line23(absurdhyp_1)
>>               Mp line22(absurdhyp_1)):that
>>               (p0 E prime(P0)))]
>>            {move 3}



         define line25 absurdhyp: Simp2(Iff1(line24 \
            absurdhyp,Ui p0,Separation4 Refleq \
            prime P0))

>>          line25: [(absurdhyp_1:that ~((p0
>>               E P))) => (Simp2((line24(absurdhyp_1)
>>               Iff1 (p0 Ui Separation4(Refleq(prime(P0)))))):
>>               that ~((p0 E Usc(thelaw(P0)))))]
>>            {move 3}



         define line26 absurdhyp: Mp (Inusc2 \
            p0,line25 absurdhyp)

>>          line26: [(absurdhyp_1:that ~((p0
>>               E P))) => ((Inusc2(p0) Mp line25(absurdhyp_1)):
>>               that ??)]
>>            {move 3}



         save

         close

      define line27 : Dneg Negintro line26


>>       line27: [(Dneg(Negintro([(absurdhyp_1:
>>               that ~((p0 E P))) => ((Inusc2(p0)
>>               Mp Simp2(((((prime(P0) E Pset)
>>               Fixform (((line4 Mp (P0 Ui Simp1(Simp2(Simp2(Mboldtheta)))))
>>               Conj ((P <<= prime(P0)) Fixform
>>               (Ug([(Q_14:obj) => (Ded([(Qev_15:
>>                     that (Q_14 E P)) => (((Q_14
>>                     E prime(P0)) Fixform ((((Q_14
>>                     E P0) Fixform (((Qev_15
>>                     Mpsubs Pev) Conj Ug([(B_19:
>>                        obj) => (Ded([(Bev_20:
>>                           that (B_19 E Pset))
>>                           => ((Qev_15 Mpsubs
>>                           Simp2((Bev_20 Iff1
>>                           (B_19 Ui Separation4(Refleq(Pset)))))):
>>                           that (Q_14 E B_19))])
>>                        :that ((B_19 E Pset)
>>                        -> (Q_14 E B_19)))]))
>>                     Iff2 (Q_14 Ui Separation4(Refleq(P0)))))
>>                     Conj Negintro([(eqtest_32:
>>                        that (Q_14 E Usc(p0)))
>>                        => ((Qev_15 Mp (Eqsymm(Inusc1(eqtest_32))
>>                        Subs1 absurdhyp_1)):
>>                        that ??)]))
>>                     Iff2 (Q_14 Ui Separation4(Refleq(prime(P0)))))):
>>                     that (Q_14 E prime(P0)))])
>>                  :that ((Q_14 E P) -> (Q_14
>>                  E prime(P0))))])
>>               Conj (((P = 0) Add2 Pev2) Conj
>>               Separation3(Refleq(prime(P0)))))))
>>               Iff2 (prime(P0) Ui Separation4(Refleq(Pset)))))
>>               Mp (prime(P0) Ui Simp2((line14
>>               Iff1 (p0 Ui Separation4(Refleq(P0)))))))
>>               Iff1 (p0 Ui Separation4(Refleq(prime(P0))))))):
>>               that ??)]))
>>            :that (p0 E P))]
>>         {move 2}



      declare P1 obj

>>       P1: obj {move 3}



      goal that ~(thelaw P1) E prime P1

>>       Goal: that (~(thelaw(P1)) E prime(P1))


      open

         declare neghyp that (thelaw P1) \
            E prime P1

>>          neghyp: that (thelaw(P1) E prime(P1))
>>            {move 4}



         define line28 neghyp: Simp2(Separation5 \
            neghyp)

>>          line28: [(neghyp_1:that (thelaw(P1)
>>               E prime(P1))) => (Simp2(Separation5(neghyp_1)):
>>               that ~((thelaw(P1) E Usc(thelaw(P1)))))]
>>            {move 3}



         define line29 neghyp: Mp(Inusc2 \
            thelaw P1,line28 neghyp)

>>          line29: [(neghyp_1:that (thelaw(P1)
>>               E prime(P1))) => ((Inusc2(thelaw(P1))
>>               Mp line28(neghyp_1)):that ??)]
>>            {move 3}



         close

      define primefact1 P1: Negintro line29


>>       primefact1: [(P1_1:obj) => (Negintro([(neghyp_2:
>>               that (thelaw(P1_1) E prime(P1_1)))
>>               => ((Inusc2(thelaw(P1_1)) Mp
>>               Simp2(Separation5(neghyp_2))):
>>               that ??)])
>>            :that ~((thelaw(P1_1) E prime(P1_1))))]
>>         {move 2}



      save

      close

   declare P2 obj

>>    P2: obj {move 2}



   define primefact2 P2:primefact1 P2

>>    primefact2: [(P2_1:obj) => (Negintro([(neghyp_2:
>>            that (thelaw(P2_1) E prime(P2_1)))
>>            => ((Inusc2(thelaw(P2_1)) Mp Simp2(Separation5(neghyp_2))):
>>            that ??)])
>>         :that ~((thelaw(P2_1) E prime(P2_1))))]
>>      {move 1}



   save

   close

declare P3 obj

>> P3: obj {move 1}



define primefact3 Misset, thelawchooses, \
   P3:primefact2 P3

>> primefact3: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))]),
>>      (P3_1:obj) => (Negintro([(neghyp_5:that
>>         (.thelaw_1(P3_1) E prime2(.thelaw_1,
>>         P3_1))) => ((Inusc2(.thelaw_1(P3_1))
>>         Mp Simp2(Separation5(neghyp_5))):that
>>         ??)])
>>      :that ~((.thelaw_1(P3_1) E prime2(.thelaw_1,
>>      P3_1))))]
>>   {move 0}



open

   define primefact4 P2: primefact3 Misset, \
      thelawchooses, P2

>>    primefact4: [(P2_1:obj) => (primefact3(Misset,
>>         thelawchooses,P2_1):that ~((thelaw(P2_1)
>>         E prime2(thelaw,P2_1))))]
>>      {move 1}



   open

      define primefact P1:primefact4 P1

>>       primefact: [(P1_1:obj) => (primefact4(P1_1):
>>            that ~((thelaw(P1_1) E prime2(thelaw,
>>            P1_1))))]
>>         {move 2}



      open

         declare phyp0 that P1 E Mbold

>>          phyp0: that (P1 E Mbold) {move 4}



         declare phyp1 that P <<= P1

>>          phyp1: that (P <<= P1) {move 4}



         declare phyp2 that ~(P1 = P0)

>>          phyp2: that ~((P1 = P0)) {move 4}



         goal that P0 <<= P1

>>          Goal: that (P0 <<= P1)

         open

            declare z obj

>>             z: obj {move 5}



            open

               declare zev that z E P0

>>                zev: that (z E P0) {move 6}



               goal that z E P1

>>                Goal: that (z E P1)

               define line30 zev: Ui P1 Simp2 \
                  Separation5 zev

>>                line30: [(zev_1:that (z E
>>                     P0)) => ((P1 Ui Simp2(Separation5(zev_1))):
>>                     that ((P1 E Pset) -> (z
>>                     E P1)))]
>>                  {move 5}



               define line31 zev: Fixform(P1 \
                  E Pset,Iff2(Conj phyp0 phyp1, \
                  Ui P1 Separation4 Refleq \
                  Pset))

>>                line31: [(zev_1:that (z E
>>                     P0)) => (((P1 E Pset) Fixform
>>                     ((phyp0 Conj phyp1) Iff2
>>                     (P1 Ui Separation4(Refleq(Pset))))):
>>                     that (P1 E Pset))]
>>                  {move 5}



               define line32 zev : Mp line31 \
                  zev, line30 zev

>>                line32: [(zev_1:that (z E
>>                     P0)) => ((line31(zev_1)
>>                     Mp line30(zev_1)):that
>>                     (z E P1))]
>>                  {move 5}



               close

            define line33 z: Ded line32

>>             line33: [(z_1:obj) => (Ded([(zev_2:
>>                     that (z_1 E P0)) => ((((P1
>>                     E Pset) Fixform ((phyp0
>>                     Conj phyp1) Iff2 (P1 Ui
>>                     Separation4(Refleq(Pset)))))
>>                     Mp (P1 Ui Simp2(Separation5(zev_2)))):
>>                     that (z_1 E P1))])
>>                  :that ((z_1 E P0) -> (z_1
>>                  E P1)))]
>>               {move 4}



            define line34: Fixform(P0 <<= \
               P1,Conj(Ug line33, Conj(Separation3 \
               Refleq P0,Simp2 Simp2 phyp1)))


>>             line34: [(((P0 <<= P1) Fixform
>>                  (Ug(line33) Conj (Separation3(Refleq(P0))
>>                  Conj Simp2(Simp2(phyp1))))):
>>                  that (P0 <<= P1))]
>>               {move 4}



            goal that P0 <<= prime P1

>>             Goal: that (P0 <<= prime(P1))


            goal that ~(P1 <<= P0)

>>             Goal: that ~((P1 <<= P0))

            open

               declare sillyhyp that P1 <<= \
                  P0

>>                sillyhyp: that (P1 <<= P0)
>>                  {move 6}



               define line35 sillyhyp: Mp \
                  Antisymsub sillyhyp line34 \
                  phyp2

>>                line35: [(sillyhyp_1:that
>>                     (P1 <<= P0)) => (((sillyhyp_1
>>                     Antisymsub line34) Mp phyp2):
>>                     that ??)]
>>                  {move 5}



               close

            define line36: Negintro line35


>>             line36: [(Negintro([(sillyhyp_1:
>>                     that (P1 <<= P0)) => (((sillyhyp_1
>>                     Antisymsub line34) Mp phyp2):
>>                     that ??)])
>>                  :that ~((P1 <<= P0)))]
>>               {move 4}



            define line37: Fixform(P0 <<= \
               prime P1,Ds1 Mboldstrongtotal \
               phyp0 line4 line36)

>>             line37: [(((P0 <<= prime(P1))
>>                  Fixform ((phyp0 Mboldstrongtotal
>>                  line4) Ds1 line36)):that (P0
>>                  <<= prime(P1)))]
>>               {move 4}



            goal that ~(thelaw P1 E P)

>>             Goal: that ~((thelaw(P1) E P))


            open

               declare sillyhyp that thelaw \
                  P1 E P

>>                sillyhyp: that (thelaw(P1)
>>                  E P) {move 6}



               define line38 sillyhyp: Mp \
                  Mpsubs Mpsubs sillyhyp linea13 \
                  line37 primefact P1

>>                line38: [(sillyhyp_1:that
>>                     (thelaw(P1) E P)) => ((((sillyhyp_1
>>                     Mpsubs linea13) Mpsubs
>>                     line37) Mp primefact(P1)):
>>                     that ??)]
>>                  {move 5}



               close

            define line39 : Negintro line38


>>             line39: [(Negintro([(sillyhyp_1:
>>                     that (thelaw(P1) E P))
>>                     => ((((sillyhyp_1 Mpsubs
>>                     linea13) Mpsubs line37)
>>                     Mp primefact(P1)):that
>>                     ??)])
>>                  :that ~((thelaw(P1) E P)))]
>>               {move 4}



            close

         define Line34 phyp0 phyp1 phyp2 \
            : line34

>>          Line34: [(phyp0_1:that (P1 E Mbold)),
>>               (phyp1_1:that (P <<= P1)),(phyp2_1:
>>               that ~((P1 = P0))) => (((P0 <<=
>>               P1) Fixform (Ug([(z_4:obj) =>
>>                  (Ded([(zev_5:that (z_4 E P0))
>>                     => ((((P1 E Pset) Fixform
>>                     ((phyp0_1 Conj phyp1_1)
>>                     Iff2 (P1 Ui Separation4(Refleq(Pset)))))
>>                     Mp (P1 Ui Simp2(Separation5(zev_5)))):
>>                     that (z_4 E P1))])
>>                  :that ((z_4 E P0) -> (z_4
>>                  E P1)))])
>>               Conj (Separation3(Refleq(P0))
>>               Conj Simp2(Simp2(phyp1_1))))):
>>               that (P0 <<= P1))]
>>            {move 3}



         define Line37 phyp0 phyp1 phyp2: \
            line37

>>          Line37: [(phyp0_1:that (P1 E Mbold)),
>>               (phyp1_1:that (P <<= P1)),(phyp2_1:
>>               that ~((P1 = P0))) => (((P0 <<=
>>               prime(P1)) Fixform ((phyp0_1
>>               Mboldstrongtotal line4) Ds1 Negintro([(sillyhyp_2:
>>                  that (P1 <<= P0)) => (((sillyhyp_2
>>                  Antisymsub ((P0 <<= P1) Fixform
>>                  (Ug([(z_5:obj) => (Ded([(zev_6:
>>                        that (z_5 E P0)) =>
>>                        ((((P1 E Pset) Fixform
>>                        ((phyp0_1 Conj phyp1_1)
>>                        Iff2 (P1 Ui Separation4(Refleq(Pset)))))
>>                        Mp (P1 Ui Simp2(Separation5(zev_6)))):
>>                        that (z_5 E P1))])
>>                     :that ((z_5 E P0) -> (z_5
>>                     E P1)))])
>>                  Conj (Separation3(Refleq(P0))
>>                  Conj Simp2(Simp2(phyp1_1))))))
>>                  Mp phyp2_1):that ??)]))
>>               ):that (P0 <<= prime(P1)))]
>>            {move 3}



         define Line39 phyp0 phyp1 phyp2: \
            line39

>>          Line39: [(phyp0_1:that (P1 E Mbold)),
>>               (phyp1_1:that (P <<= P1)),(phyp2_1:
>>               that ~((P1 = P0))) => (Negintro([(sillyhyp_2:
>>                  that (thelaw(P1) E P)) =>
>>                  ((((sillyhyp_2 Mpsubs linea13)
>>                  Mpsubs ((P0 <<= prime(P1))
>>                  Fixform ((phyp0_1 Mboldstrongtotal
>>                  line4) Ds1 Negintro([(sillyhyp_3:
>>                     that (P1 <<= P0)) => (((sillyhyp_3
>>                     Antisymsub ((P0 <<= P1)
>>                     Fixform (Ug([(z_6:obj)
>>                        => (Ded([(zev_7:that
>>                           (z_6 E P0)) => ((((P1
>>                           E Pset) Fixform ((phyp0_1
>>                           Conj phyp1_1) Iff2
>>                           (P1 Ui Separation4(Refleq(Pset)))))
>>                           Mp (P1 Ui Simp2(Separation5(zev_7)))):
>>                           that (z_6 E P1))])
>>                        :that ((z_6 E P0) ->
>>                        (z_6 E P1)))])
>>                     Conj (Separation3(Refleq(P0))
>>                     Conj Simp2(Simp2(phyp1_1))))))
>>                     Mp phyp2_1):that ??)]))
>>                  )) Mp primefact(P1)):that
>>                  ??)])
>>               :that ~((thelaw(P1) E P)))]
>>            {move 3}



         close

      declare phyps that (P1 E Mbold) & (P \
         <<= P1) & ~(P1=P0)

>>       phyps: that ((P1 E Mbold) & ((P <<=
>>         P1) & ~((P1 = P0)))) {move 3}



      define Lemma34 phyps: Line34 Simp1 \
         phyps Simp1 Simp2 phyps Simp2 Simp2 \
         phyps

>>       Lemma34: [(.P1_1:obj),(phyps_1:that
>>            ((.P1_1 E Mbold) & ((P <<= .P1_1)
>>            & ~((.P1_1 = P0))))) => (((P0 <<=
>>            .P1_1) Fixform (Ug([(z_4:obj) =>
>>               (Ded([(zev_5:that (z_4 E P0))
>>                  => ((((.P1_1 E Pset) Fixform
>>                  ((Simp1(phyps_1) Conj Simp1(Simp2(phyps_1)))
>>                  Iff2 (.P1_1 Ui Separation4(Refleq(Pset)))))
>>                  Mp (.P1_1 Ui Simp2(Separation5(zev_5)))):
>>                  that (z_4 E .P1_1))])
>>               :that ((z_4 E P0) -> (z_4 E .P1_1)))])
>>            Conj (Separation3(Refleq(P0)) Conj
>>            Simp2(Simp2(Simp1(Simp2(phyps_1))))))):
>>            that (P0 <<= .P1_1))]
>>         {move 2}



      define Lemma37 phyps: Line37 Simp1 \
         phyps Simp1 Simp2 phyps Simp2 Simp2 \
         phyps

>>       Lemma37: [(.P1_1:obj),(phyps_1:that
>>            ((.P1_1 E Mbold) & ((P <<= .P1_1)
>>            & ~((.P1_1 = P0))))) => (((P0 <<=
>>            prime(.P1_1)) Fixform ((Simp1(phyps_1)
>>            Mboldstrongtotal line4) Ds1 Negintro([(sillyhyp_2:
>>               that (.P1_1 <<= P0)) => (((sillyhyp_2
>>               Antisymsub ((P0 <<= .P1_1) Fixform
>>               (Ug([(z_5:obj) => (Ded([(zev_6:
>>                     that (z_5 E P0)) => ((((.P1_1
>>                     E Pset) Fixform ((Simp1(phyps_1)
>>                     Conj Simp1(Simp2(phyps_1)))
>>                     Iff2 (.P1_1 Ui Separation4(Refleq(Pset)))))
>>                     Mp (.P1_1 Ui Simp2(Separation5(zev_6)))):
>>                     that (z_5 E .P1_1))])
>>                  :that ((z_5 E P0) -> (z_5
>>                  E .P1_1)))])
>>               Conj (Separation3(Refleq(P0))
>>               Conj Simp2(Simp2(Simp1(Simp2(phyps_1))))))))
>>               Mp Simp2(Simp2(phyps_1))):that
>>               ??)]))
>>            ):that (P0 <<= prime(.P1_1)))]
>>         {move 2}



      define Lemma39 phyps: Line39 Simp1 \
         phyps Simp1 Simp2 phyps Simp2 Simp2 \
         phyps

>>       Lemma39: [(.P1_1:obj),(phyps_1:that
>>            ((.P1_1 E Mbold) & ((P <<= .P1_1)
>>            & ~((.P1_1 = P0))))) => (Negintro([(sillyhyp_2:
>>               that (thelaw(.P1_1) E P)) =>
>>               ((((sillyhyp_2 Mpsubs linea13)
>>               Mpsubs ((P0 <<= prime(.P1_1))
>>               Fixform ((Simp1(phyps_1) Mboldstrongtotal
>>               line4) Ds1 Negintro([(sillyhyp_3:
>>                  that (.P1_1 <<= P0)) => (((sillyhyp_3
>>                  Antisymsub ((P0 <<= .P1_1)
>>                  Fixform (Ug([(z_6:obj) =>
>>                     (Ded([(zev_7:that (z_6
>>                        E P0)) => ((((.P1_1
>>                        E Pset) Fixform ((Simp1(phyps_1)
>>                        Conj Simp1(Simp2(phyps_1)))
>>                        Iff2 (.P1_1 Ui Separation4(Refleq(Pset)))))
>>                        Mp (.P1_1 Ui Simp2(Separation5(zev_7)))):
>>                        that (z_6 E .P1_1))])
>>                     :that ((z_6 E P0) -> (z_6
>>                     E .P1_1)))])
>>                  Conj (Separation3(Refleq(P0))
>>                  Conj Simp2(Simp2(Simp1(Simp2(phyps_1))))))))
>>                  Mp Simp2(Simp2(phyps_1))):
>>                  that ??)]))
>>               )) Mp primefact(.P1_1)):that
>>               ??)])
>>            :that ~((thelaw(.P1_1) E P)))]
>>         {move 2}



      declare phyps2 that (P1 E Mbold) & \
         (P <<= P1) & thelaw P1 E P

>>       phyps2: that ((P1 E Mbold) & ((P <<=
>>         P1) & (thelaw(P1) E P))) {move 3}



      goal that P1 = P0

>>       Goal: that (P1 = P0)

      open

         declare sillyhyp that ~(P1 = P0)


>>          sillyhyp: that ~((P1 = P0)) {move
>>            4}



         define line40 sillyhyp:Mp(Simp2 \
            Simp2 phyps2, Lemma39 (Conj(Simp1 \
            phyps2,Conj(Simp1 Simp2 phyps2, \
            sillyhyp))))

>>          line40: [(sillyhyp_1:that ~((P1
>>               = P0))) => ((Simp2(Simp2(phyps2))
>>               Mp Lemma39((Simp1(phyps2) Conj
>>               (Simp1(Simp2(phyps2)) Conj sillyhyp_1)))):
>>               that ??)]
>>            {move 3}



         close

      define line41 phyps2: Dneg(Negintro \
         line40)

>>       line41: [(.P1_1:obj),(phyps2_1:that
>>            ((.P1_1 E Mbold) & ((P <<= .P1_1)
>>            & (thelaw(.P1_1) E P)))) => (Dneg(Negintro([(sillyhyp_2:
>>               that ~((.P1_1 = P0))) => ((Simp2(Simp2(phyps2_1))
>>               Mp Lemma39((Simp1(phyps2_1) Conj
>>               (Simp1(Simp2(phyps2_1)) Conj
>>               sillyhyp_2)))):that ??)]))
>>            :that (.P1_1 = P0))]
>>         {move 2}



      close

   define Rcal1 P: P0

>>    Rcal1: [(P_1:obj) => (((Mbold Set [(x1_2:
>>            obj) => ((P_1 <<= x1_2):prop)])
>>         Intersection M):obj)]
>>      {move 1}



   define Rcal x: Rcal1 Usc x

>>    Rcal: [(x_1:obj) => (Rcal1(Usc(x_1)):obj)]
>>      {move 1}



   goal that (thelaw Rcal x) = x

>>    Goal: that (thelaw(Rcal(x)) = x)

   define Linea27 Pev Pev2 : Fixform((thelaw(Rcal1 \
      P))E P,line27)

>>    Linea27: [(.P_1:obj),(Pev_1:that (.P_1
>>         <<= M)),(Pev2_1:that Exists([(x2_2:
>>            obj) => ((x2_2 E .P_1):prop)]))
>>         => (((thelaw(Rcal1(.P_1)) E .P_1) Fixform
>>         Dneg(Negintro([(absurdhyp_5:that ~((thelaw(((Mbold
>>            Set [(x1_6:obj) => ((.P_1 <<= x1_6):
>>               prop)])
>>            Intersection M)) E .P_1))) => ((Inusc2(thelaw(((Mbold
>>            Set [(x1_10:obj) => ((.P_1 <<= x1_10):
>>               prop)])
>>            Intersection M))) Mp Simp2(((((prime(((Mbold
>>            Set [(x1_19:obj) => ((.P_1 <<= x1_19):
>>               prop)])
>>            Intersection M)) E (Mbold Set [(x1_20:
>>               obj) => ((.P_1 <<= x1_20):prop)]))
>>            Fixform (((((((Mbold Set [(x1_25:
>>               obj) => ((.P_1 <<= x1_25):prop)])
>>            Intersection M) E Mbold) Fixform
>>            (((((Mbold Set [(x1_29:obj) => ((.P_1
>>               <<= x1_29):prop)])
>>            <<= Mbold) Fixform (Separation3(Refleq(Mbold))
>>            Sepsub2 Refleq((Mbold Set [(x1_37:
>>               obj) => ((.P_1 <<= x1_37):prop)]))
>>            )) Conj ((M E (Mbold Set [(x1_39:
>>               obj) => ((.P_1 <<= x1_39):prop)]))
>>            Fixform ((Simp1(Mboldtheta) Conj
>>            Pev_1) Iff2 (M Ui Separation4(Refleq((Mbold
>>            Set [(x1_48:obj) => ((.P_1 <<= x1_48):
>>               prop)]))
>>            ))))) Mp (M Ui ((Mbold Set [(x1_54:
>>               obj) => ((.P_1 <<= x1_54):prop)])
>>            Ui Simp2(Simp2(Simp2(Mboldtheta)))))))
>>            Mp (((Mbold Set [(x1_67:obj) =>
>>               ((.P_1 <<= x1_67):prop)])
>>            Intersection M) Ui Simp1(Simp2(Simp2(Mboldtheta)))))
>>            Conj ((.P_1 <<= prime(((Mbold Set
>>            [(x1_79:obj) => ((.P_1 <<= x1_79):
>>               prop)])
>>            Intersection M))) Fixform (Ug([(Q_84:
>>               obj) => (Ded([(Qev_86:that (Q_84
>>                  E .P_1)) => (((Q_84 E prime(((Mbold
>>                  Set [(x1_87:obj) => ((.P_1
>>                     <<= x1_87):prop)])
>>                  Intersection M))) Fixform
>>                  ((((Q_84 E ((Mbold Set [(x1_91:
>>                     obj) => ((.P_1 <<= x1_91):
>>                     prop)])
>>                  Intersection M)) Fixform (((Qev_86
>>                  Mpsubs Pev_1) Conj Ug([(B_98:
>>                     obj) => (Ded([(Bev_100:
>>                        that (B_98 E (Mbold
>>                        Set [(x1_101:obj) =>
>>                           ((.P_1 <<= x1_101):
>>                           prop)]))
>>                        ) => ((Qev_86 Mpsubs
>>                        Simp2((Bev_100 Iff1
>>                        (B_98 Ui Separation4(Refleq((Mbold
>>                        Set [(x1_107:obj) =>
>>                           ((.P_1 <<= x1_107):
>>                           prop)]))
>>                        ))))):that (Q_84 E B_98))])
>>                     :that ((B_98 E (Mbold Set
>>                     [(x1_108:obj) => ((.P_1
>>                        <<= x1_108):prop)]))
>>                     -> (Q_84 E B_98)))]))
>>                  Iff2 (Q_84 Ui Separation4(Refleq(((Mbold
>>                  Set [(x1_122:obj) => ((.P_1
>>                     <<= x1_122):prop)])
>>                  Intersection M)))))) Conj
>>                  Negintro([(eqtest_125:that
>>                     (Q_84 E Usc(thelaw(((Mbold
>>                     Set [(x1_126:obj) => ((.P_1
>>                        <<= x1_126):prop)])
>>                     Intersection M))))) =>
>>                     ((Qev_86 Mp (Eqsymm(Inusc1(eqtest_125))
>>                     Subs1 absurdhyp_5)):that
>>                     ??)]))
>>                  Iff2 (Q_84 Ui Separation4(Refleq(prime(((Mbold
>>                  Set [(x1_144:obj) => ((.P_1
>>                     <<= x1_144):prop)])
>>                  Intersection M))))))):that
>>                  (Q_84 E prime(((Mbold Set
>>                  [(x1_145:obj) => ((.P_1 <<=
>>                     x1_145):prop)])
>>                  Intersection M))))])
>>               :that ((Q_84 E .P_1) -> (Q_84
>>               E prime(((Mbold Set [(x1_146:
>>                  obj) => ((.P_1 <<= x1_146):
>>                  prop)])
>>               Intersection M)))))])
>>            Conj (((.P_1 = 0) Add2 Pev2_1) Conj
>>            Separation3(Refleq(prime(((Mbold
>>            Set [(x1_160:obj) => ((.P_1 <<=
>>               x1_160):prop)])
>>            Intersection M)))))))) Iff2 (prime(((Mbold
>>            Set [(x1_163:obj) => ((.P_1 <<=
>>               x1_163):prop)])
>>            Intersection M)) Ui Separation4(Refleq((Mbold
>>            Set [(x1_168:obj) => ((.P_1 <<=
>>               x1_168):prop)]))
>>            )))) Mp (prime(((Mbold Set [(x1_171:
>>               obj) => ((.P_1 <<= x1_171):prop)])
>>            Intersection M)) Ui Simp2((((thelaw(((Mbold
>>            Set [(x1_181:obj) => ((.P_1 <<=
>>               x1_181):prop)])
>>            Intersection M)) E ((Mbold Set [(x1_182:
>>               obj) => ((.P_1 <<= x1_182):prop)])
>>            Intersection M)) Fixform ((Misset
>>            Sepsub2 Refleq(((Mbold Set [(x1_189:
>>               obj) => ((.P_1 <<= x1_189):prop)])
>>            Intersection M))) thelawchooses
>>            (Pev2_1 Eg [(.z_193:obj),(zev_193:
>>               that (.z_193 E .P_1)) => ((Exists([(w_194:
>>                  obj) => ((w_194 E ((Mbold
>>                  Set [(x1_195:obj) => ((.P_1
>>                     <<= x1_195):prop)])
>>                  Intersection M)):prop)])
>>               Fixform (.z_193 Ei1 ((.z_193
>>               E ((Mbold Set [(x1_198:obj) =>
>>                  ((.P_1 <<= x1_198):prop)])
>>               Intersection M)) Fixform (((zev_193
>>               Mpsubs Pev_1) Conj Ug([(B_205:
>>                  obj) => (Ded([(Bev_207:that
>>                     (B_205 E (Mbold Set [(x1_208:
>>                        obj) => ((.P_1 <<= x1_208):
>>                        prop)]))
>>                     ) => ((zev_193 Mpsubs Simp2((Bev_207
>>                     Iff1 (B_205 Ui Separation4(Refleq((Mbold
>>                     Set [(x1_214:obj) => ((.P_1
>>                        <<= x1_214):prop)]))
>>                     ))))):that (.z_193 E B_205))])
>>                  :that ((B_205 E (Mbold Set
>>                  [(x1_215:obj) => ((.P_1 <<=
>>                     x1_215):prop)]))
>>                  -> (.z_193 E B_205)))]))
>>               Iff2 (.z_193 Ui Separation4(Refleq(((Mbold
>>               Set [(x1_229:obj) => ((.P_1 <<=
>>                  x1_229):prop)])
>>               Intersection M)))))))):that Exists([(w_230:
>>                  obj) => ((w_230 E ((Mbold
>>                  Set [(x1_231:obj) => ((.P_1
>>                     <<= x1_231):prop)])
>>                  Intersection M)):prop)]))
>>               ]))
>>            ) Iff1 (thelaw(((Mbold Set [(x1_236:
>>               obj) => ((.P_1 <<= x1_236):prop)])
>>            Intersection M)) Ui Separation4(Refleq(((Mbold
>>            Set [(x1_247:obj) => ((.P_1 <<=
>>               x1_247):prop)])
>>            Intersection M)))))))) Iff1 (thelaw(((Mbold
>>            Set [(x1_252:obj) => ((.P_1 <<=
>>               x1_252):prop)])
>>            Intersection M)) Ui Separation4(Refleq(prime(((Mbold
>>            Set [(x1_263:obj) => ((.P_1 <<=
>>               x1_263):prop)])
>>            Intersection M)))))))):that ??)]))
>>         ):that (thelaw(Rcal1(.P_1)) E .P_1))]
>>      {move 1}



   save

   close

declare P77 obj

>> P77: obj {move 1}



declare Pev77 that P77 <<= M

>> Pev77: that (P77 <<= M) {move 1}



declare x77 obj

>> x77: obj {move 1}



declare Pev277 that Exists[x77 => x77 EP77] \
   



>> Pev277: that Exists([(x77_1:obj) => ((x77_1
>>      E P77):prop)])
>>   {move 1}



define Lineb27 Misset, thelawchooses, Pev77, \
   Pev277: Linea27 Pev77 Pev277

>> Lineb27: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))]),
>>      (.P77_1:obj),(Pev77_1:that (.P77_1 <<=
>>      .M_1)),(Pev277_1:that Exists([(x77_5:obj)
>>         => ((x77_5 E .P77_1):prop)]))
>>      => (((.thelaw_1((((Misset_1 Mbold2 thelawchooses_1)
>>      Set [(x1_6:obj) => ((.P77_1 <<= x1_6):
>>         prop)])
>>      Intersection .M_1)) E .P77_1) Fixform
>>      Dneg(Negintro([(absurdhyp_9:that ~((.thelaw_1((((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_10:
>>            obj) => ((.P77_1 <<= x1_10):prop)])
>>         Intersection .M_1)) E .P77_1))) =>
>>         ((Inusc2(.thelaw_1((((Misset_1 Mbold2
>>         thelawchooses_1) Set [(x1_14:obj) =>
>>            ((.P77_1 <<= x1_14):prop)])
>>         Intersection .M_1))) Mp Simp2(((((prime2(.thelaw_1,
>>         (((Misset_1 Mbold2 thelawchooses_1)
>>         Set [(x1_23:obj) => ((.P77_1 <<= x1_23):
>>            prop)])
>>         Intersection .M_1)) E ((Misset_1 Mbold2
>>         thelawchooses_1) Set [(x1_24:obj) =>
>>            ((.P77_1 <<= x1_24):prop)]))
>>         Fixform ((((((((Misset_1 Mbold2 thelawchooses_1)
>>         Set [(x1_29:obj) => ((.P77_1 <<= x1_29):
>>            prop)])
>>         Intersection .M_1) E (Misset_1 Mbold2
>>         thelawchooses_1)) Fixform ((((((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_33:
>>            obj) => ((.P77_1 <<= x1_33):prop)])
>>         <<= (Misset_1 Mbold2 thelawchooses_1))
>>         Fixform (Separation3(Refleq((Misset_1
>>         Mbold2 thelawchooses_1))) Sepsub2 Refleq(((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_41:
>>            obj) => ((.P77_1 <<= x1_41):prop)]))
>>         )) Conj ((.M_1 E ((Misset_1 Mbold2
>>         thelawchooses_1) Set [(x1_43:obj) =>
>>            ((.P77_1 <<= x1_43):prop)]))
>>         Fixform ((Simp1((Misset_1 Mboldtheta2
>>         thelawchooses_1)) Conj Pev77_1) Iff2
>>         (.M_1 Ui Separation4(Refleq(((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_52:
>>            obj) => ((.P77_1 <<= x1_52):prop)]))
>>         ))))) Mp (.M_1 Ui (((Misset_1 Mbold2
>>         thelawchooses_1) Set [(x1_58:obj) =>
>>            ((.P77_1 <<= x1_58):prop)])
>>         Ui Simp2(Simp2(Simp2((Misset_1 Mboldtheta2
>>         thelawchooses_1)))))))) Mp ((((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_71:
>>            obj) => ((.P77_1 <<= x1_71):prop)])
>>         Intersection .M_1) Ui Simp1(Simp2(Simp2((Misset_1
>>         Mboldtheta2 thelawchooses_1)))))) Conj
>>         ((.P77_1 <<= prime2(.thelaw_1,(((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_83:
>>            obj) => ((.P77_1 <<= x1_83):prop)])
>>         Intersection .M_1))) Fixform (Ug([(Q_88:
>>            obj) => (Ded([(Qev_90:that (Q_88
>>               E .P77_1)) => (((Q_88 E prime2(.thelaw_1,
>>               (((Misset_1 Mbold2 thelawchooses_1)
>>               Set [(x1_91:obj) => ((.P77_1
>>                  <<= x1_91):prop)])
>>               Intersection .M_1))) Fixform
>>               ((((Q_88 E (((Misset_1 Mbold2
>>               thelawchooses_1) Set [(x1_95:
>>                  obj) => ((.P77_1 <<= x1_95):
>>                  prop)])
>>               Intersection .M_1)) Fixform (((Qev_90
>>               Mpsubs Pev77_1) Conj Ug([(B_102:
>>                  obj) => (Ded([(Bev_104:that
>>                     (B_102 E ((Misset_1 Mbold2
>>                     thelawchooses_1) Set [(x1_105:
>>                        obj) => ((.P77_1 <<=
>>                        x1_105):prop)]))
>>                     ) => ((Qev_90 Mpsubs Simp2((Bev_104
>>                     Iff1 (B_102 Ui Separation4(Refleq(((Misset_1
>>                     Mbold2 thelawchooses_1)
>>                     Set [(x1_111:obj) => ((.P77_1
>>                        <<= x1_111):prop)]))
>>                     ))))):that (Q_88 E B_102))])
>>                  :that ((B_102 E ((Misset_1
>>                  Mbold2 thelawchooses_1) Set
>>                  [(x1_112:obj) => ((.P77_1
>>                     <<= x1_112):prop)]))
>>                  -> (Q_88 E B_102)))]))
>>               Iff2 (Q_88 Ui Separation4(Refleq((((Misset_1
>>               Mbold2 thelawchooses_1) Set [(x1_126:
>>                  obj) => ((.P77_1 <<= x1_126):
>>                  prop)])
>>               Intersection .M_1)))))) Conj
>>               Negintro([(eqtest_129:that (Q_88
>>                  E Usc(.thelaw_1((((Misset_1
>>                  Mbold2 thelawchooses_1) Set
>>                  [(x1_130:obj) => ((.P77_1
>>                     <<= x1_130):prop)])
>>                  Intersection .M_1))))) =>
>>                  ((Qev_90 Mp (Eqsymm(Inusc1(eqtest_129))
>>                  Subs1 absurdhyp_9)):that ??)]))
>>               Iff2 (Q_88 Ui Separation4(Refleq(prime2(.thelaw_1,
>>               (((Misset_1 Mbold2 thelawchooses_1)
>>               Set [(x1_148:obj) => ((.P77_1
>>                  <<= x1_148):prop)])
>>               Intersection .M_1))))))):that
>>               (Q_88 E prime2(.thelaw_1,(((Misset_1
>>               Mbold2 thelawchooses_1) Set [(x1_149:
>>                  obj) => ((.P77_1 <<= x1_149):
>>                  prop)])
>>               Intersection .M_1))))])
>>            :that ((Q_88 E .P77_1) -> (Q_88
>>            E prime2(.thelaw_1,(((Misset_1 Mbold2
>>            thelawchooses_1) Set [(x1_150:obj)
>>               => ((.P77_1 <<= x1_150):prop)])
>>            Intersection .M_1)))))])
>>         Conj (((.P77_1 = 0) Add2 Pev277_1)
>>         Conj Separation3(Refleq(prime2(.thelaw_1,
>>         (((Misset_1 Mbold2 thelawchooses_1)
>>         Set [(x1_164:obj) => ((.P77_1 <<= x1_164):
>>            prop)])
>>         Intersection .M_1)))))))) Iff2 (prime2(.thelaw_1,
>>         (((Misset_1 Mbold2 thelawchooses_1)
>>         Set [(x1_167:obj) => ((.P77_1 <<= x1_167):
>>            prop)])
>>         Intersection .M_1)) Ui Separation4(Refleq(((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_172:
>>            obj) => ((.P77_1 <<= x1_172):prop)]))
>>         )))) Mp (prime2(.thelaw_1,(((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_175:
>>            obj) => ((.P77_1 <<= x1_175):prop)])
>>         Intersection .M_1)) Ui Simp2((((.thelaw_1((((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_185:
>>            obj) => ((.P77_1 <<= x1_185):prop)])
>>         Intersection .M_1)) E (((Misset_1 Mbold2
>>         thelawchooses_1) Set [(x1_186:obj)
>>            => ((.P77_1 <<= x1_186):prop)])
>>         Intersection .M_1)) Fixform thelawchooses_1((.M_1
>>         Set [(x_187:obj) => (Forall([(B_188:
>>               obj) => (((B_188 E ((Misset_1
>>               Mbold2 thelawchooses_1) Set [(x1_189:
>>                  obj) => ((.P77_1 <<= x1_189):
>>                  prop)]))
>>               -> (x_187 E B_188)):prop)])
>>            :prop)]),
>>         (Misset_1 Sepsub2 Refleq((((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_193:
>>            obj) => ((.P77_1 <<= x1_193):prop)])
>>         Intersection .M_1))),(Pev277_1 Eg [(.z_197:
>>            obj),(zev_197:that (.z_197 E .P77_1))
>>            => ((Exists([(w_198:obj) => ((w_198
>>               E (((Misset_1 Mbold2 thelawchooses_1)
>>               Set [(x1_199:obj) => ((.P77_1
>>                  <<= x1_199):prop)])
>>               Intersection .M_1)):prop)])
>>            Fixform (.z_197 Ei1 ((.z_197 E (((Misset_1
>>            Mbold2 thelawchooses_1) Set [(x1_202:
>>               obj) => ((.P77_1 <<= x1_202):
>>               prop)])
>>            Intersection .M_1)) Fixform (((zev_197
>>            Mpsubs Pev77_1) Conj Ug([(B_209:
>>               obj) => (Ded([(Bev_211:that (B_209
>>                  E ((Misset_1 Mbold2 thelawchooses_1)
>>                  Set [(x1_212:obj) => ((.P77_1
>>                     <<= x1_212):prop)]))
>>                  ) => ((zev_197 Mpsubs Simp2((Bev_211
>>                  Iff1 (B_209 Ui Separation4(Refleq(((Misset_1
>>                  Mbold2 thelawchooses_1) Set
>>                  [(x1_218:obj) => ((.P77_1
>>                     <<= x1_218):prop)]))
>>                  ))))):that (.z_197 E B_209))])
>>               :that ((B_209 E ((Misset_1 Mbold2
>>               thelawchooses_1) Set [(x1_219:
>>                  obj) => ((.P77_1 <<= x1_219):
>>                  prop)]))
>>               -> (.z_197 E B_209)))]))
>>            Iff2 (.z_197 Ui Separation4(Refleq((((Misset_1
>>            Mbold2 thelawchooses_1) Set [(x1_233:
>>               obj) => ((.P77_1 <<= x1_233):
>>               prop)])
>>            Intersection .M_1)))))))):that Exists([(w_234:
>>               obj) => ((w_234 E (((Misset_1
>>               Mbold2 thelawchooses_1) Set [(x1_235:
>>                  obj) => ((.P77_1 <<= x1_235):
>>                  prop)])
>>               Intersection .M_1)):prop)]))
>>            ]))
>>         ) Iff1 (.thelaw_1((((Misset_1 Mbold2
>>         thelawchooses_1) Set [(x1_240:obj)
>>            => ((.P77_1 <<= x1_240):prop)])
>>         Intersection .M_1)) Ui Separation4(Refleq((((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_251:
>>            obj) => ((.P77_1 <<= x1_251):prop)])
>>         Intersection .M_1)))))))) Iff1 (.thelaw_1((((Misset_1
>>         Mbold2 thelawchooses_1) Set [(x1_256:
>>            obj) => ((.P77_1 <<= x1_256):prop)])
>>         Intersection .M_1)) Ui Separation4(Refleq(prime2(.thelaw_1,
>>         (((Misset_1 Mbold2 thelawchooses_1)
>>         Set [(x1_267:obj) => ((.P77_1 <<= x1_267):
>>            prop)])
>>         Intersection .M_1)))))))):that ??)]))
>>      ):that (.thelaw_1((((Misset_1 Mbold2 thelawchooses_1)
>>      Set [(x1_268:obj) => ((.P77_1 <<= x1_268):
>>         prop)])
>>      Intersection .M_1)) E .P77_1))]
>>   {move 0}



open

   define Line27 Pev Pev2: Lineb27 Misset, \
      thelawchooses, Pev, Pev2

>>    Line27: [(.P_1:obj),(Pev_1:that (.P_1
>>         <<= M)),(Pev2_1:that Exists([(x2_2:
>>            obj) => ((x2_2 E .P_1):prop)]))
>>         => (Lineb27(Misset,thelawchooses,Pev_1,
>>         Pev2_1):that (thelaw((((Misset Mbold2
>>         thelawchooses) Set [(x1_3:obj) => ((.P_1
>>            <<= x1_3):prop)])
>>         Intersection M)) E .P_1))]
>>      {move 1}



   declare xinm that x E M

>>    xinm: that (x E M) {move 2}



   open

      define line42: Iff2 xinm, Uscsubs x \
         M

>>       line42: [((xinm Iff2 (x Uscsubs M)):
>>            that (Usc(x) <<= M))]
>>         {move 2}



      define line43: Pairinhabited x x

>>       line43: [((x Pairinhabited x):that
>>            Exists([(u_1:obj) => ((u_1 E (x
>>               ; x)):prop)]))
>>            ]
>>         {move 2}



      define line44: Fixform((thelaw(Rcal \
         x)= x),Inusc1 Line27 line42 line43)


>>       line44: [(((thelaw(Rcal(x)) = x) Fixform
>>            Inusc1((line42 Line27 line43))):
>>            that (thelaw(Rcal(x)) = x))]
>>         {move 2}



      close

   define line45 xinm: line44

>>    line45: [(.x_1:obj),(xinm_1:that (.x_1
>>         E M)) => (((thelaw(Rcal(.x_1)) = .x_1)
>>         Fixform Inusc1(((xinm_1 Iff2 (.x_1
>>         Uscsubs M)) Line27 (.x_1 Pairinhabited
>>         .x_1)))):that (thelaw(Rcal(.x_1)) =
>>         .x_1))]
>>      {move 1}



   declare Q obj

>>    Q: obj {move 2}



   declare phypsq that (Q E Mbold) & (P <<= \
      Q) & thelaw Q E P

>>    phypsq: that ((Q E Mbold) & ((P <<= Q)
>>      & (thelaw(Q) E P))) {move 2}



   define Line41 Pev Pev2 phypsq: line41 \
      phypsq

>>    Line41: [(.P_1:obj),(Pev_1:that (.P_1
>>         <<= M)),(Pev2_1:that Exists([(x2_2:
>>            obj) => ((x2_2 E .P_1):prop)]))
>>         ,(.Q_1:obj),(phypsq_1:that ((.Q_1 E
>>         Mbold) & ((.P_1 <<= .Q_1) & (thelaw(.Q_1)
>>         E .P_1)))) => (Dneg(Negintro([(sillyhyp_5:
>>            that ~((.Q_1 = ((Mbold Set [(x1_6:
>>               obj) => ((.P_1 <<= x1_6):prop)])
>>            Intersection M)))) => ((Simp2(Simp2(phypsq_1))
>>            Mp Negintro([(sillyhyp_7:that (thelaw(.Q_1)
>>               E .P_1)) => ((((sillyhyp_7 Mpsubs
>>               ((.P_1 <<= ((Mbold Set [(x1_10:
>>                  obj) => ((.P_1 <<= x1_10):
>>                  prop)])
>>               Intersection M)) Fixform (Ug([(z_15:
>>                  obj) => (Ded([(zev2_17:that
>>                     (z_15 E .P_1)) => (((z_15
>>                     E ((Mbold Set [(x1_18:obj)
>>                        => ((.P_1 <<= x1_18):
>>                        prop)])
>>                     Intersection M)) Fixform
>>                     (((zev2_17 Mpsubs Pev_1)
>>                     Conj Ug([(B_25:obj) =>
>>                        (Ded([(Bev_27:that (B_25
>>                           E (Mbold Set [(x1_28:
>>                              obj) => ((.P_1
>>                              <<= x1_28):prop)]))
>>                           ) => ((zev2_17 Mpsubs
>>                           Simp2((Bev_27 Iff1
>>                           (B_25 Ui Separation4(Refleq((Mbold
>>                           Set [(x1_34:obj)
>>                              => ((.P_1 <<=
>>                              x1_34):prop)]))
>>                           ))))):that (z_15
>>                           E B_25))])
>>                        :that ((B_25 E (Mbold
>>                        Set [(x1_35:obj) =>
>>                           ((.P_1 <<= x1_35):
>>                           prop)]))
>>                        -> (z_15 E B_25)))]))
>>                     Iff2 (z_15 Ui Separation4(Refleq(((Mbold
>>                     Set [(x1_49:obj) => ((.P_1
>>                        <<= x1_49):prop)])
>>                     Intersection M)))))):that
>>                     (z_15 E ((Mbold Set [(x1_50:
>>                        obj) => ((.P_1 <<= x1_50):
>>                        prop)])
>>                     Intersection M)))])
>>                  :that ((z_15 E .P_1) -> (z_15
>>                  E ((Mbold Set [(x1_51:obj)
>>                     => ((.P_1 <<= x1_51):prop)])
>>                  Intersection M))))])
>>               Conj (Simp1(Simp2(Pev_1)) Conj
>>               Separation3(Refleq(((Mbold Set
>>               [(x1_63:obj) => ((.P_1 <<= x1_63):
>>                  prop)])
>>               Intersection M))))))) Mpsubs
>>               ((((Mbold Set [(x1_64:obj) =>
>>                  ((.P_1 <<= x1_64):prop)])
>>               Intersection M) <<= prime(.Q_1))
>>               Fixform ((Simp1((Simp1(phypsq_1)
>>               Conj (Simp1(Simp2(phypsq_1))
>>               Conj sillyhyp_5))) Mboldstrongtotal
>>               ((((Mbold Set [(x1_71:obj) =>
>>                  ((.P_1 <<= x1_71):prop)])
>>               Intersection M) E Mbold) Fixform
>>               (((((Mbold Set [(x1_75:obj) =>
>>                  ((.P_1 <<= x1_75):prop)])
>>               <<= Mbold) Fixform (Separation3(Refleq(Mbold))
>>               Sepsub2 Refleq((Mbold Set [(x1_83:
>>                  obj) => ((.P_1 <<= x1_83):
>>                  prop)]))
>>               )) Conj ((M E (Mbold Set [(x1_85:
>>                  obj) => ((.P_1 <<= x1_85):
>>                  prop)]))
>>               Fixform ((Simp1(Mboldtheta) Conj
>>               Pev_1) Iff2 (M Ui Separation4(Refleq((Mbold
>>               Set [(x1_94:obj) => ((.P_1 <<=
>>                  x1_94):prop)]))
>>               ))))) Mp (M Ui ((Mbold Set [(x1_100:
>>                  obj) => ((.P_1 <<= x1_100):
>>                  prop)])
>>               Ui Simp2(Simp2(Simp2(Mboldtheta))))))))
>>               Ds1 Negintro([(sillyhyp_113:that
>>                  (.Q_1 <<= ((Mbold Set [(x1_114:
>>                     obj) => ((.P_1 <<= x1_114):
>>                     prop)])
>>                  Intersection M))) => (((sillyhyp_113
>>                  Antisymsub ((((Mbold Set [(x1_117:
>>                     obj) => ((.P_1 <<= x1_117):
>>                     prop)])
>>                  Intersection M) <<= .Q_1)
>>                  Fixform (Ug([(z_122:obj) =>
>>                     (Ded([(zev_124:that (z_122
>>                        E ((Mbold Set [(x1_125:
>>                           obj) => ((.P_1 <<=
>>                           x1_125):prop)])
>>                        Intersection M))) =>
>>                        ((((.Q_1 E (Mbold Set
>>                        [(x1_127:obj) => ((.P_1
>>                           <<= x1_127):prop)]))
>>                        Fixform ((Simp1((Simp1(phypsq_1)
>>                        Conj (Simp1(Simp2(phypsq_1))
>>                        Conj sillyhyp_5))) Conj
>>                        Simp1(Simp2((Simp1(phypsq_1)
>>                        Conj (Simp1(Simp2(phypsq_1))
>>                        Conj sillyhyp_5)))))
>>                        Iff2 (.Q_1 Ui Separation4(Refleq((Mbold
>>                        Set [(x1_140:obj) =>
>>                           ((.P_1 <<= x1_140):
>>                           prop)]))
>>                        )))) Mp (.Q_1 Ui Simp2(Separation5(zev_124)))):
>>                        that (z_122 E .Q_1))])
>>                     :that ((z_122 E ((Mbold
>>                     Set [(x1_148:obj) => ((.P_1
>>                        <<= x1_148):prop)])
>>                     Intersection M)) -> (z_122
>>                     E .Q_1)))])
>>                  Conj (Separation3(Refleq(((Mbold
>>                  Set [(x1_159:obj) => ((.P_1
>>                     <<= x1_159):prop)])
>>                  Intersection M))) Conj Simp2(Simp2(Simp1(Simp2((Simp1(phypsq_1)
>>                  Conj (Simp1(Simp2(phypsq_1))
>>                  Conj sillyhyp_5))))))))))
>>                  Mp Simp2(Simp2((Simp1(phypsq_1)
>>                  Conj (Simp1(Simp2(phypsq_1))
>>                  Conj sillyhyp_5))))):that
>>                  ??)]))
>>               )) Mp primefact4(.Q_1)):that
>>               ??)]))
>>            :that ??)]))
>>         :that (.Q_1 = ((Mbold Set [(x1_169:
>>            obj) => ((.P_1 <<= x1_169):prop)])
>>         Intersection M)))]
>>      {move 1}



   declare Qinmbold that Q E Mbold

>>    Qinmbold: that (Q E Mbold) {move 2}



   declare y obj

>>    y: obj {move 2}



   declare Qev that y E Q

>>    Qev: that (y E Q) {move 2}



   goal that (thelaw Q = x) -> Q = Rcal x


>>    Goal: that ((thelaw(Q) = x) -> (Q = Rcal(x)))


   open

      declare thehyp that thelaw Q = x

>>       thehyp: that (thelaw(Q) = x) {move
>>         3}



      define line46: Iff1(Simp1 Separation5 \
         Qinmbold,Ui Q,Scthm M)

>>       line46: [((Simp1(Separation5(Qinmbold))
>>            Iff1 (Q Ui Scthm(M))):that (Q <<=
>>            M))]
>>         {move 2}



      define line47 thehyp:Iff2(Subs1 thehyp, \
         thelawchooses line46, Ei1 y Qev,Uscsubs \
         x Q)

>>       line47: [(thehyp_1:that (thelaw(Q)
>>            = x)) => (((thehyp_1 Subs1 (line46
>>            thelawchooses (y Ei1 Qev))) Iff2
>>            (x Uscsubs Q)):that (Usc(x) <<=
>>            Q))]
>>         {move 2}



      declare y1 obj

>>       y1: obj {move 3}



      define line48 thehyp: Subs Eqsymm thehyp \
         [y1 => y1 E Usc x] \
         Inusc2 x

>>       line48: [(thehyp_1:that (thelaw(Q)
>>            = x)) => (Subs(Eqsymm(thehyp_1),
>>            [(y1_2:obj) => ((y1_2 E Usc(x)):
>>               prop)]
>>            ,Inusc2(x)):that (thelaw(Q) E Usc(x)))]
>>         {move 2}



      define line49 thehyp: Fixform(Q = Rcal \
         x,Line41 line42 line43 (Qinmbold Conj \
         line47 thehyp Conj line48 thehyp))


>>       line49: [(thehyp_1:that (thelaw(Q)
>>            = x)) => (((Q = Rcal(x)) Fixform
>>            Line41(line42,line43,(Qinmbold Conj
>>            (line47(thehyp_1) Conj line48(thehyp_1))))):
>>            that (Q = Rcal(x)))]
>>         {move 2}



      close

   declare thehyp2 that thelaw Q = x

>>    thehyp2: that (thelaw(Q) = x) {move 2}



   define Line49 xinm Qinmbold Qev thehyp2: \
      line49 thehyp2

>>    Line49: [(.x_1:obj),(xinm_1:that (.x_1
>>         E M)),(.Q_1:obj),(Qinmbold_1:that (.Q_1
>>         E Mbold)),(.y_1:obj),(Qev_1:that (.y_1
>>         E .Q_1)),(thehyp2_1:that (thelaw(.Q_1)
>>         = .x_1)) => (((.Q_1 = Rcal(.x_1)) Fixform
>>         Line41((xinm_1 Iff2 (.x_1 Uscsubs M)),
>>         (.x_1 Pairinhabited .x_1),(Qinmbold_1
>>         Conj (((thehyp2_1 Subs1 ((Simp1(Separation5(Qinmbold_1))
>>         Iff1 (.Q_1 Ui Scthm(M))) thelawchooses
>>         (.y_1 Ei1 Qev_1))) Iff2 (.x_1 Uscsubs
>>         .Q_1)) Conj Subs(Eqsymm(thehyp2_1),
>>         [(y1_10:obj) => ((y1_10 E Usc(.x_1)):
>>            prop)]
>>         ,Inusc2(.x_1)))))):that (.Q_1 = Rcal(.x_1)))]
>>      {move 1}



   declare a obj

>>    a: obj {move 2}



   declare b obj

>>    b: obj {move 2}



   declare ainm that a E M

>>    ainm: that (a E M) {move 2}



   declare binm that b E M

>>    binm: that (b E M) {move 2}



   define <~ a b: (a E M) & (b E M) & ~(a=b) \
      & b E Rcal a

>>    <~: [(a_1:obj),(b_1:obj) => (((a_1 E M)
>>         & ((b_1 E M) & (~((a_1 = b_1)) & (b_1
>>         E Rcal(a_1))))):prop)]
>>      {move 1}


% I am going to argue for the same result in this paragraph in a simpler (I hope) way.


   goal that (b E Rcal a) == (Rcal b) <<= \
      Rcal a

>>    Goal: that ((b E Rcal(a)) == (Rcal(b)
>>      <<= Rcal(a)))

   define Line4 Pev Pev2: Fixform(P0 E Mbold, \
      line4)

>>    Line4: [(.P_1:obj),(Pev_1:that (.P_1 <<=
>>         M)),(Pev2_1:that Exists([(x2_2:obj)
>>            => ((x2_2 E .P_1):prop)]))
>>         => (((((Mbold Set [(x1_3:obj) => ((.P_1
>>            <<= x1_3):prop)])
>>         Intersection M) E Mbold) Fixform ((((Mbold
>>         Set [(x1_4:obj) => ((.P_1 <<= x1_4):
>>            prop)])
>>         Intersection M) E Mbold) Fixform (((((Mbold
>>         Set [(x1_8:obj) => ((.P_1 <<= x1_8):
>>            prop)])
>>         <<= Mbold) Fixform (Separation3(Refleq(Mbold))
>>         Sepsub2 Refleq((Mbold Set [(x1_16:obj)
>>            => ((.P_1 <<= x1_16):prop)]))
>>         )) Conj ((M E (Mbold Set [(x1_18:obj)
>>            => ((.P_1 <<= x1_18):prop)]))
>>         Fixform ((Simp1(Mboldtheta) Conj Pev_1)
>>         Iff2 (M Ui Separation4(Refleq((Mbold
>>         Set [(x1_27:obj) => ((.P_1 <<= x1_27):
>>            prop)]))
>>         ))))) Mp (M Ui ((Mbold Set [(x1_33:
>>            obj) => ((.P_1 <<= x1_33):prop)])
>>         Ui Simp2(Simp2(Simp2(Mboldtheta)))))))):
>>         that (((Mbold Set [(x1_45:obj) => ((.P_1
>>            <<= x1_45):prop)])
>>         Intersection M) E Mbold))]
>>      {move 1}



   define Rcalinmbold xinm: Fixform(Rcal \
      x E Mbold,Line4 line42 line43)

>>    Rcalinmbold: [(.x_1:obj),(xinm_1:that
>>         (.x_1 E M)) => (((Rcal(.x_1) E Mbold)
>>         Fixform ((xinm_1 Iff2 (.x_1 Uscsubs
>>         M)) Line4 (.x_1 Pairinhabited .x_1))):
>>         that (Rcal(.x_1) E Mbold))]
>>      {move 1}



   define Line44 xinm: line44

>>    Line44: [(.x_1:obj),(xinm_1:that (.x_1
>>         E M)) => (((thelaw(Rcal(.x_1)) = .x_1)
>>         Fixform Inusc1(((xinm_1 Iff2 (.x_1
>>         Uscsubs M)) Line27 (.x_1 Pairinhabited
>>         .x_1)))):that (thelaw(Rcal(.x_1)) =
>>         .x_1))]
>>      {move 1}



   define Linea13 Pev Pev2: Fixform(P <<= \
      Rcal1 P,linea13)

>>    Linea13: [(.P_1:obj),(Pev_1:that (.P_1
>>         <<= M)),(Pev2_1:that Exists([(x2_2:
>>            obj) => ((x2_2 E .P_1):prop)]))
>>         => (((.P_1 <<= Rcal1(.P_1)) Fixform
>>         ((.P_1 <<= ((Mbold Set [(x1_3:obj)
>>            => ((.P_1 <<= x1_3):prop)])
>>         Intersection M)) Fixform (Ug([(z_8:
>>            obj) => (Ded([(zev2_10:that (z_8
>>               E .P_1)) => (((z_8 E ((Mbold
>>               Set [(x1_11:obj) => ((.P_1 <<=
>>                  x1_11):prop)])
>>               Intersection M)) Fixform (((zev2_10
>>               Mpsubs Pev_1) Conj Ug([(B_18:
>>                  obj) => (Ded([(Bev_20:that
>>                     (B_18 E (Mbold Set [(x1_21:
>>                        obj) => ((.P_1 <<= x1_21):
>>                        prop)]))
>>                     ) => ((zev2_10 Mpsubs Simp2((Bev_20
>>                     Iff1 (B_18 Ui Separation4(Refleq((Mbold
>>                     Set [(x1_27:obj) => ((.P_1
>>                        <<= x1_27):prop)]))
>>                     ))))):that (z_8 E B_18))])
>>                  :that ((B_18 E (Mbold Set
>>                  [(x1_28:obj) => ((.P_1 <<=
>>                     x1_28):prop)]))
>>                  -> (z_8 E B_18)))]))
>>               Iff2 (z_8 Ui Separation4(Refleq(((Mbold
>>               Set [(x1_42:obj) => ((.P_1 <<=
>>                  x1_42):prop)])
>>               Intersection M)))))):that (z_8
>>               E ((Mbold Set [(x1_43:obj) =>
>>                  ((.P_1 <<= x1_43):prop)])
>>               Intersection M)))])
>>            :that ((z_8 E .P_1) -> (z_8 E ((Mbold
>>            Set [(x1_44:obj) => ((.P_1 <<= x1_44):
>>               prop)])
>>            Intersection M))))])
>>         Conj (Simp1(Simp2(Pev_1)) Conj Separation3(Refleq(((Mbold
>>         Set [(x1_56:obj) => ((.P_1 <<= x1_56):
>>            prop)])
>>         Intersection M))))))):that (.P_1 <<=
>>         Rcal1(.P_1)))]
>>      {move 1}



   define Lineb13 xinm: Iff1(Linea13 line42 \
      line43,Uscsubs x Rcal x)

>>    Lineb13: [(.x_1:obj),(xinm_1:that (.x_1
>>         E M)) => ((((xinm_1 Iff2 (.x_1 Uscsubs
>>         M)) Linea13 (.x_1 Pairinhabited .x_1))
>>         Iff1 (.x_1 Uscsubs Rcal(.x_1))):that
>>         (.x_1 E Rcal(.x_1)))]
>>      {move 1}



   open

      declare dir1 that b E Rcal a

>>       dir1: that (b E Rcal(a)) {move 3}



      declare dir2 that (Rcal b) <<= Rcal \
         a

>>       dir2: that (Rcal(b) <<= Rcal(a)) {move
>>         3}



      define line50: Mboldstrongtotal Rcalinmbold \
         binm Rcalinmbold ainm

>>       line50: [((Rcalinmbold(binm) Mboldstrongtotal
>>            Rcalinmbold(ainm)):that ((Rcal(a)
>>            <<= prime2(thelaw,Rcal(b))) V (Rcal(b)
>>            <<= Rcal(a))))]
>>         {move 2}



      open

         declare case1 that Rcal b <<= Rcal \
            a

>>          case1: that (Rcal(b) <<= Rcal(a))
>>            {move 4}



         define line51 case1: case1

>>          line51: [(case1_1:that (Rcal(b)
>>               <<= Rcal(a))) => (case1_1:that
>>               (Rcal(b) <<= Rcal(a)))]
>>            {move 3}



         declare case2 that Rcal a <<= prime \
            Rcal b

>>          case2: that (Rcal(a) <<= prime(Rcal(b)))
>>            {move 4}



         define line52 case2: Mpsubs dir1 \
            case2

>>          line52: [(case2_1:that (Rcal(a)
>>               <<= prime(Rcal(b)))) => ((dir1
>>               Mpsubs case2_1):that (b E prime(Rcal(b))))]
>>            {move 3}



         declare z1 obj

>>          z1: obj {move 4}



         define line53 case2: Subs(Eqsymm \
            Line44 binm,[z1=>z1 E prime(Rcal \
               b)] \
            ,line52 case2)

>>          line53: [(case2_1:that (Rcal(a)
>>               <<= prime(Rcal(b)))) => (Subs(Eqsymm(Line44(binm)),
>>               [(z1_2:obj) => ((z1_2 E prime(Rcal(b))):
>>                  prop)]
>>               ,line52(case2_1)):that (thelaw(Rcal(b))
>>               E prime(Rcal(b))))]
>>            {move 3}



         define line54 case2: Mp line53 case2, \
            primefact Rcal b

>>          line54: [(case2_1:that (Rcal(a)
>>               <<= prime(Rcal(b)))) => ((line53(case2_1)
>>               Mp primefact(Rcal(b))):that ??)]
>>            {move 3}



         declare testobj obj

>>          testobj: obj {move 4}



         define line55 case2: Giveup(Rcal \
            b <<= Rcal a,line54 case2)

>>          line55: [(case2_1:that (Rcal(a)
>>               <<= prime(Rcal(b)))) => (((Rcal(b)
>>               <<= Rcal(a)) Giveup line54(case2_1)):
>>               that (Rcal(b) <<= Rcal(a)))]
>>            {move 3}



         close

      define line56 dir1: Cases line50, line55, \
         line51

>>       line56: [(dir1_1:that (b E Rcal(a)))
>>            => (Cases(line50,[(case2_2:that
>>               (Rcal(a) <<= prime(Rcal(b))))
>>               => (((Rcal(b) <<= Rcal(a)) Giveup
>>               (Subs(Eqsymm(Line44(binm)),[(z1_3:
>>                  obj) => ((z1_3 E prime(Rcal(b))):
>>                  prop)]
>>               ,(dir1_1 Mpsubs case2_2)) Mp
>>               primefact(Rcal(b)))):that (Rcal(b)
>>               <<= Rcal(a)))]
>>            ,[(case1_4:that (Rcal(b) <<= Rcal(a)))
>>               => (case1_4:that (Rcal(b) <<=
>>               Rcal(a)))])
>>            :that (Rcal(b) <<= Rcal(a)))]
>>         {move 2}



      define line57 dir2: Mpsubs(Lineb13 \
         binm,dir2)

>>       line57: [(dir2_1:that (Rcal(b) <<=
>>            Rcal(a))) => ((Lineb13(binm) Mpsubs
>>            dir2_1):that (b E Rcal(a)))]
>>         {move 2}



      close

   define line58 ainm binm: Dediff line56, \
      line57

>>    line58: [(.a_1:obj),(ainm_1:that (.a_1
>>         E M)),(.b_1:obj),(binm_1:that (.b_1
>>         E M)) => (Dediff([(dir1_2:that (.b_1
>>            E Rcal(.a_1))) => (Cases((Rcalinmbold(binm_1)
>>            Mboldstrongtotal Rcalinmbold(ainm_1)),
>>            [(case2_3:that (Rcal(.a_1) <<= prime(Rcal(.b_1))))
>>               => (((Rcal(.b_1) <<= Rcal(.a_1))
>>               Giveup (Subs(Eqsymm(Line44(binm_1)),
>>               [(z1_4:obj) => ((z1_4 E prime(Rcal(.b_1))):
>>                  prop)]
>>               ,(dir1_2 Mpsubs case2_3)) Mp
>>               primefact4(Rcal(.b_1)))):that
>>               (Rcal(.b_1) <<= Rcal(.a_1)))]
>>            ,[(case1_5:that (Rcal(.b_1) <<=
>>               Rcal(.a_1))) => (case1_5:that
>>               (Rcal(.b_1) <<= Rcal(.a_1)))])
>>            :that (Rcal(.b_1) <<= Rcal(.a_1)))]
>>         ,[(dir2_6:that (Rcal(.b_1) <<= Rcal(.a_1)))
>>            => ((Lineb13(binm_1) Mpsubs dir2_6):
>>            that (.b_1 E Rcal(.a_1)))])
>>         :that ((.b_1 E Rcal(.a_1)) == (Rcal(.b_1)
>>         <<= Rcal(.a_1))))]
>>      {move 1}



   goal that (a = b) V (a <~ b) V (b <~ a)


>>    Goal: that ((a = b) V ((a <~ b) V (b <~
>>      a)))

   define line59 a b: Excmid (a=b)

>>    line59: [(a_1:obj),(b_1:obj) => (Excmid((a_1
>>         = b_1)):that ((a_1 = b_1) V ~((a_1
>>         = b_1))))]
>>      {move 1}



   open

      declare case1 that a=b

>>       case1: that (a = b) {move 3}



      define line60 case1: Add1((a<~b) V \
         b <~ a,case1)

>>       line60: [(case1_1:that (a = b)) =>
>>            ((((a <~ b) V (b <~ a)) Add1 case1_1):
>>            that ((a = b) V ((a <~ b) V (b <~
>>            a))))]
>>         {move 2}



      declare case2 that ~(a=b)

>>       case2: that ~((a = b)) {move 3}



      define line61: Mboldtotal Rcalinmbold \
         ainm Rcalinmbold binm

>>       line61: [((Rcalinmbold(ainm) Mboldtotal
>>            Rcalinmbold(binm)):that ((Rcal(b)
>>            <<= Rcal(a)) V (Rcal(a) <<= Rcal(b))))]
>>         {move 2}



      open

         declare casea1 that Rcal b <<= Rcal \
            a

>>          casea1: that (Rcal(b) <<= Rcal(a))
>>            {move 4}



         define line62 casea1: Iff2(casea1, \
            line58 ainm binm)

>>          line62: [(casea1_1:that (Rcal(b)
>>               <<= Rcal(a))) => ((casea1_1 Iff2
>>               (ainm line58 binm)):that (b E
>>               Rcal(a)))]
>>            {move 3}



         define line63 casea1: Fixform(a \
            <~ b,ainm Conj binm Conj case2 \
            Conj line62 casea1)

>>          line63: [(casea1_1:that (Rcal(b)
>>               <<= Rcal(a))) => (((a <~ b) Fixform
>>               (ainm Conj (binm Conj (case2
>>               Conj line62(casea1_1))))):that
>>               (a <~ b))]
>>            {move 3}



         define linea63 casea1: Add2(a=b, \
            Add1(b<~ a,line63 casea1))

>>          linea63: [(casea1_1:that (Rcal(b)
>>               <<= Rcal(a))) => (((a = b) Add2
>>               ((b <~ a) Add1 line63(casea1_1))):
>>               that ((a = b) V ((a <~ b) V (b
>>               <~ a))))]
>>            {move 3}



         declare casea2 that Rcal a <<= Rcal \
            b

>>          casea2: that (Rcal(a) <<= Rcal(b))
>>            {move 4}



         define line64 casea2: Iff2(casea2, \
            line58 binm ainm)

>>          line64: [(casea2_1:that (Rcal(a)
>>               <<= Rcal(b))) => ((casea2_1 Iff2
>>               (binm line58 ainm)):that (a E
>>               Rcal(b)))]
>>            {move 3}



         define line65 casea2:Fixform(b <~a, \
            binm Conj ainm Conj Negeqsymm case2 \
            Conj line64 casea2)

>>          line65: [(casea2_1:that (Rcal(a)
>>               <<= Rcal(b))) => (((b <~ a) Fixform
>>               (binm Conj (ainm Conj (Negeqsymm(case2)
>>               Conj line64(casea2_1))))):that
>>               (b <~ a))]
>>            {move 3}



         define linea65 casea2: Add2 a=b, \
            Add2 a <~ b,line65 casea2

>>          linea65: [(casea2_1:that (Rcal(a)
>>               <<= Rcal(b))) => (((a = b) Add2
>>               ((a <~ b) Add2 line65(casea2_1))):
>>               that ((a = b) V ((a <~ b) V (b
>>               <~ a))))]
>>            {move 3}



         close

      define line66 case2: Cases line61 linea63, \
         linea65

>>       line66: [(case2_1:that ~((a = b)))
>>            => (Cases(line61,[(casea1_2:that
>>               (Rcal(b) <<= Rcal(a))) => (((a
>>               = b) Add2 ((b <~ a) Add1 ((a
>>               <~ b) Fixform (ainm Conj (binm
>>               Conj (case2_1 Conj (casea1_2
>>               Iff2 (ainm line58 binm)))))))):
>>               that ((a = b) V ((a <~ b) V (b
>>               <~ a))))]
>>            ,[(casea2_3:that (Rcal(a) <<= Rcal(b)))
>>               => (((a = b) Add2 ((a <~ b) Add2
>>               ((b <~ a) Fixform (binm Conj
>>               (ainm Conj (Negeqsymm(case2_1)
>>               Conj (casea2_3 Iff2 (binm line58
>>               ainm)))))))):that ((a = b) V
>>               ((a <~ b) V (b <~ a))))])
>>            :that ((a = b) V ((a <~ b) V (b
>>            <~ a))))]
>>         {move 2}



      close

   define line67 ainm binm: Cases line59 \
      a b line60, line66

>>    line67: [(.a_1:obj),(ainm_1:that (.a_1
>>         E M)),(.b_1:obj),(binm_1:that (.b_1
>>         E M)) => (Cases((.a_1 line59 .b_1),
>>         [(case1_2:that (.a_1 = .b_1)) => ((((.a_1
>>            <~ .b_1) V (.b_1 <~ .a_1)) Add1
>>            case1_2):that ((.a_1 = .b_1) V ((.a_1
>>            <~ .b_1) V (.b_1 <~ .a_1))))]
>>         ,[(case2_3:that ~((.a_1 = .b_1))) =>
>>            (Cases((Rcalinmbold(ainm_1) Mboldtotal
>>            Rcalinmbold(binm_1)),[(casea1_4:
>>               that (Rcal(.b_1) <<= Rcal(.a_1)))
>>               => (((.a_1 = .b_1) Add2 ((.b_1
>>               <~ .a_1) Add1 ((.a_1 <~ .b_1)
>>               Fixform (ainm_1 Conj (binm_1
>>               Conj (case2_3 Conj (casea1_4
>>               Iff2 (ainm_1 line58 binm_1)))))))):
>>               that ((.a_1 = .b_1) V ((.a_1
>>               <~ .b_1) V (.b_1 <~ .a_1))))]
>>            ,[(casea2_5:that (Rcal(.a_1) <<=
>>               Rcal(.b_1))) => (((.a_1 = .b_1)
>>               Add2 ((.a_1 <~ .b_1) Add2 ((.b_1
>>               <~ .a_1) Fixform (binm_1 Conj
>>               (ainm_1 Conj (Negeqsymm(case2_3)
>>               Conj (casea2_5 Iff2 (binm_1 line58
>>               ainm_1)))))))):that ((.a_1 =
>>               .b_1) V ((.a_1 <~ .b_1) V (.b_1
>>               <~ .a_1))))])
>>            :that ((.a_1 = .b_1) V ((.a_1 <~
>>            .b_1) V (.b_1 <~ .a_1))))])
>>         :that ((.a_1 = .b_1) V ((.a_1 <~ .b_1)
>>         V (.b_1 <~ .a_1))))]
>>      {move 1}



   goal that ~(a <~ a)

>>    Goal: that ~((a <~ a))

   open

      declare sillyhyp that a <~ a

>>       sillyhyp: that (a <~ a) {move 3}



      define line68 sillyhyp: Mp Refleq a, \
         Simp1 Simp2 Simp2 sillyhyp

>>       line68: [(sillyhyp_1:that (a <~ a))
>>            => ((Refleq(a) Mp Simp1(Simp2(Simp2(sillyhyp_1)))):
>>            that ??)]
>>         {move 2}



      close

   define line69 ainm: Negintro line68

>>    line69: [(.a_1:obj),(ainm_1:that (.a_1
>>         E M)) => (Negintro([(sillyhyp_2:that
>>            (.a_1 <~ .a_1)) => ((Refleq(.a_1)
>>            Mp Simp1(Simp2(Simp2(sillyhyp_2)))):
>>            that ??)])
>>         :that ~((.a_1 <~ .a_1)))]
>>      {move 1}



   goal that (a <~ b) -> ~(b <~ a)

>>    Goal: that ((a <~ b) -> ~((b <~ a)))

   open

      declare thehyp that a <~ b

>>       thehyp: that (a <~ b) {move 3}



      define line70 thehyp: Iff1 Simp2 Simp2 \
         Simp2 thehyp, line58 ainm binm

>>       line70: [(thehyp_1:that (a <~ b)) =>
>>            ((Simp2(Simp2(Simp2(thehyp_1)))
>>            Iff1 (ainm line58 binm)):that (Rcal(b)
>>            <<= Rcal(a)))]
>>         {move 2}



      open

         declare sillyhyp that b <~ a

>>          sillyhyp: that (b <~ a) {move 4}



         define line71 sillyhyp: Iff1 Simp2 \
            Simp2 Simp2 sillyhyp, line58 binm \
            ainm

>>          line71: [(sillyhyp_1:that (b <~
>>               a)) => ((Simp2(Simp2(Simp2(sillyhyp_1)))
>>               Iff1 (binm line58 ainm)):that
>>               (Rcal(a) <<= Rcal(b)))]
>>            {move 3}



         define line72 sillyhyp: Antisymsub \
            line70 thehyp, line71 sillyhyp


>>          line72: [(sillyhyp_1:that (b <~
>>               a)) => ((line70(thehyp) Antisymsub
>>               line71(sillyhyp_1)):that (Rcal(b)
>>               = Rcal(a)))]
>>            {move 3}



         define line73 sillyhyp: Subs1 Line44 \
            ainm, Subs1 Line44 binm,bothsides \
            thelaw, line72 sillyhyp

>>          line73: [(sillyhyp_1:that (b <~
>>               a)) => ((Line44(ainm) Subs1 (Line44(binm)
>>               Subs1 bothsides(thelaw,line72(sillyhyp_1)))):
>>               that (b = a))]
>>            {move 3}



         define line74 sillyhyp: Mp line73 \
            sillyhyp, Simp1 Simp2 Simp2 sillyhyp


>>          line74: [(sillyhyp_1:that (b <~
>>               a)) => ((line73(sillyhyp_1) Mp
>>               Simp1(Simp2(Simp2(sillyhyp_1)))):
>>               that ??)]
>>            {move 3}



         close

      define line75 thehyp: Negintro line74


>>       line75: [(thehyp_1:that (a <~ b)) =>
>>            (Negintro([(sillyhyp_2:that (b <~
>>               a)) => (((Line44(ainm) Subs1
>>               (Line44(binm) Subs1 bothsides(thelaw,
>>               (line70(thehyp_1) Antisymsub
>>               (Simp2(Simp2(Simp2(sillyhyp_2)))
>>               Iff1 (binm line58 ainm))))))
>>               Mp Simp1(Simp2(Simp2(sillyhyp_2)))):
>>               that ??)])
>>            :that ~((b <~ a)))]
>>         {move 2}



      close

   define line76 ainm binm: Ded line75

>>    line76: [(.a_1:obj),(ainm_1:that (.a_1
>>         E M)),(.b_1:obj),(binm_1:that (.b_1
>>         E M)) => (Ded([(thehyp_2:that (.a_1
>>            <~ .b_1)) => (Negintro([(sillyhyp_3:
>>               that (.b_1 <~ .a_1)) => (((Line44(ainm_1)
>>               Subs1 (Line44(binm_1) Subs1 bothsides(thelaw,
>>               ((Simp2(Simp2(Simp2(thehyp_2)))
>>               Iff1 (ainm_1 line58 binm_1))
>>               Antisymsub (Simp2(Simp2(Simp2(sillyhyp_3)))
>>               Iff1 (binm_1 line58 ainm_1))))))
>>               Mp Simp1(Simp2(Simp2(sillyhyp_3)))):
>>               that ??)])
>>            :that ~((.b_1 <~ .a_1)))])
>>         :that ((.a_1 <~ .b_1) -> ~((.b_1 <~
>>         .a_1))))]
>>      {move 1}



   declare c obj

>>    c: obj {move 2}



   declare cinm that c E M

>>    cinm: that (c E M) {move 2}



   goal that ((a <~b) & (b <~ c))-> \
      a <~ c

>>    Goal: that (((a <~ b) & (b <~ c)) -> (a
>>      <~ c))

   open

      declare thehyp that (a <~ b) & b <~ \
         c

>>       thehyp: that ((a <~ b) & (b <~ c))
>>         {move 3}



      define line77 thehyp: Iff1(Simp2 Simp2 \
         Simp2 Simp1 thehyp, line58 \
         ainm binm)

>>       line77: [(thehyp_1:that ((a <~ b) &
>>            (b <~ c))) => ((Simp2(Simp2(Simp2(Simp1(thehyp_1))))
>>            Iff1 (ainm line58 binm)):that (Rcal(b)
>>            <<= Rcal(a)))]
>>         {move 2}



      define line78 thehyp: Iff1 (Simp2 Simp2 \
         Simp2 Simp2 thehyp,line58 binm cinm)


>>       line78: [(thehyp_1:that ((a <~ b) &
>>            (b <~ c))) => ((Simp2(Simp2(Simp2(Simp2(thehyp_1))))
>>            Iff1 (binm line58 cinm)):that (Rcal(c)
>>            <<= Rcal(b)))]
>>         {move 2}



      define line79 thehyp: Iff2(Transsub \
         line78 thehyp, line77 thehyp, line58 \
         ainm cinm)

>>       line79: [(thehyp_1:that ((a <~ b) &
>>            (b <~ c))) => (((line78(thehyp_1)
>>            Transsub line77(thehyp_1)) Iff2
>>            (ainm line58 cinm)):that (c E Rcal(a)))]
>>         {move 2}



      open

         declare sillyhyp that a=c

>>          sillyhyp: that (a = c) {move 4}



         define line80 sillyhyp: Subs1 Eqsymm \
            sillyhyp Simp2 thehyp

>>          line80: [(sillyhyp_1:that (a = c))
>>               => ((Eqsymm(sillyhyp_1) Subs1
>>               Simp2(thehyp)):that (b <~ a))]
>>            {move 3}



         define line81 sillyhyp: Mp line80 \
            sillyhyp, Mp Simp1 thehyp, line76 \
            ainm binm

>>          line81: [(sillyhyp_1:that (a = c))
>>               => ((line80(sillyhyp_1) Mp (Simp1(thehyp)
>>               Mp (ainm line76 binm))):that
>>               ??)]
>>            {move 3}



         close

      define line82 thehyp: Negintro line81


>>       line82: [(thehyp_1:that ((a <~ b) &
>>            (b <~ c))) => (Negintro([(sillyhyp_2:
>>               that (a = c)) => (((Eqsymm(sillyhyp_2)
>>               Subs1 Simp2(thehyp_1)) Mp (Simp1(thehyp_1)
>>               Mp (ainm line76 binm))):that
>>               ??)])
>>            :that ~((a = c)))]
>>         {move 2}



      define line83 thehyp: Fixform(a <~ \
         c,ainm Conj cinm Conj line82 thehyp \
         Conj line79 thehyp)

>>       line83: [(thehyp_1:that ((a <~ b) &
>>            (b <~ c))) => (((a <~ c) Fixform
>>            (ainm Conj (cinm Conj (line82(thehyp_1)
>>            Conj line79(thehyp_1))))):that (a
>>            <~ c))]
>>         {move 2}



      close

   define line84 ainm binm cinm: Ded line83


>>    line84: [(.a_1:obj),(ainm_1:that (.a_1
>>         E M)),(.b_1:obj),(binm_1:that (.b_1
>>         E M)),(.c_1:obj),(cinm_1:that (.c_1
>>         E M)) => (Ded([(thehyp_2:that ((.a_1
>>            <~ .b_1) & (.b_1 <~ .c_1))) => (((.a_1
>>            <~ .c_1) Fixform (ainm_1 Conj (cinm_1
>>            Conj (Negintro([(sillyhyp_3:that
>>               (.a_1 = .c_1)) => (((Eqsymm(sillyhyp_3)
>>               Subs1 Simp2(thehyp_2)) Mp (Simp1(thehyp_2)
>>               Mp (ainm_1 line76 binm_1))):that
>>               ??)])
>>            Conj (((Simp2(Simp2(Simp2(Simp2(thehyp_2))))
>>            Iff1 (binm_1 line58 cinm_1)) Transsub
>>            (Simp2(Simp2(Simp2(Simp1(thehyp_2))))
>>            Iff1 (ainm_1 line58 binm_1))) Iff2
>>            (ainm_1 line58 cinm_1)))))):that
>>            (.a_1 <~ .c_1))])
>>         :that (((.a_1 <~ .b_1) & (.b_1 <~ .c_1))
>>         -> (.a_1 <~ .c_1)))]
>>      {move 1}


%%  we have shown that <~ is a linear order. 
% line67 = trichotomy, line69 irreflexive, line76 asymmetric, line84 = transitive

% it remains to show that it is well-founded.


   open

      declare S obj

>>       S: obj {move 3}



      declare Ssubm that S <<= M

>>       Ssubm: that (S <<= M) {move 3}



      declare z obj

>>       z: obj {move 3}



      declare zins that z E S

>>       zins: that (z E S) {move 3}



      define chosenof S: thelaw(Rcal1 S)


>>       chosenof: [(S_1:obj) => (thelaw(Rcal1(S_1)):
>>            obj)]
>>         {move 2}



      goal that chosenof S E S

>>       Goal: that (chosenof(S) E S)

      define line85 Ssubm zins: Fixform(chosenof \
         S E S,Line27 Ssubm, Ei1 z zins)

>>       line85: [(.S_1:obj),(Ssubm_1:that (.S_1
>>            <<= M)),(.z_1:obj),(zins_1:that
>>            (.z_1 E .S_1)) => (((chosenof(.S_1)
>>            E .S_1) Fixform (Ssubm_1 Line27
>>            (.z_1 Ei1 zins_1))):that (chosenof(.S_1)
>>            E .S_1))]
>>         {move 2}



      open

         declare xx obj

>>          xx: obj {move 4}



         goal that Forall[xx => (xx E S) \
               -> (xx = chosenof S) V (chosenof \
               S <~ xx)] \
            



>>          Goal: that Forall([(xx_277:obj)
>>               => (((xx_277 E S) -> ((xx_277
>>               = chosenof(S)) V (chosenof(S)
>>               <~ xx_277))):prop)])
>>            

         open

            declare thehyp that xx E S

>>             thehyp: that (xx E S) {move 5}



            define line86 thehyp: Excmid(xx \
               = chosenof S)

>>             line86: [(thehyp_1:that (xx E
>>                  S)) => (Excmid((xx = chosenof(S))):
>>                  that ((xx = chosenof(S)) V
>>                  ~((xx = chosenof(S)))))]
>>               {move 4}



            open

               declare case1 that xx = chosenof \
                  S

>>                case1: that (xx = chosenof(S))
>>                  {move 6}



               declare case2 that ~(xx = \
                  chosenof S)

>>                case2: that ~((xx = chosenof(S)))
>>                  {move 6}



               define line87 case1: Add1(chosenof \
                  S <~ xx,case1)

>>                line87: [(case1_1:that (xx
>>                     = chosenof(S))) => (((chosenof(S)
>>                     <~ xx) Add1 case1_1):that
>>                     ((xx = chosenof(S)) V (chosenof(S)
>>                     <~ xx)))]
>>                  {move 5}



               goal that Rcal1 S = Rcal chosenof \
                  S

>>                Goal: that (Rcal1(S) = Rcal(chosenof(S)))


               define line88: Fixform(Rcal1 \
                  S E Mbold,Line4 Ssubm, Ei1 \
                  z zins)

>>                line88: [(((Rcal1(S) E Mbold)
>>                     Fixform (Ssubm Line4 (z
>>                     Ei1 zins))):that (Rcal1(S)
>>                     E Mbold))]
>>                  {move 5}


% will be using Line41 to show Rcal1 S = Rcal(chosenof S)


               define line89: Iff2(Mpsubs \
                  line85 Ssubm zins, Linea13 \
                  Ssubm , Ei1 z zins,Uscsubs \
                  chosenof S Rcal1 S)

>>                line89: [((((Ssubm line85
>>                     zins) Mpsubs (Ssubm Linea13
>>                     (z Ei1 zins))) Iff2 (chosenof(S)
>>                     Uscsubs Rcal1(S))):that
>>                     (Usc(chosenof(S)) <<= Rcal1(S)))]
>>                  {move 5}



               define linea90: (Line4 Ssubm, \
                  Ei1 z zins) Conj line89 Conj \
                  (Inusc2 chosenof S)

>>                linea90: [(((Ssubm Line4 (z
>>                     Ei1 zins)) Conj (line89
>>                     Conj Inusc2(chosenof(S)))):
>>                     that ((((Mbold Set [(x1_3:
>>                        obj) => ((S <<= x1_3):
>>                        prop)])
>>                     Intersection M) E Mbold)
>>                     & ((Usc(chosenof(S)) <<=
>>                     Rcal1(S)) & (chosenof(S)
>>                     E (chosenof(S) ; chosenof(S))))))]
>>                  {move 5}



               define line90: Fixform(Rcal1 \
                  S = Rcal chosenof S,Line41 \
                  (Iff2 Mpsubs line85 Ssubm \
                  zins Ssubm,Uscsubs chosenof \
                  S M,Pairinhabited chosenof \
                  S chosenof S,linea90))

>>                line90: [(((Rcal1(S) = Rcal(chosenof(S)))
>>                     Fixform Line41((((Ssubm
>>                     line85 zins) Mpsubs Ssubm)
>>                     Iff2 (chosenof(S) Uscsubs
>>                     M)),(chosenof(S) Pairinhabited
>>                     chosenof(S)),linea90)):
>>                     that (Rcal1(S) = Rcal(chosenof(S))))]
>>                  {move 5}



               define line91: Subs1 line90, \
                  Mpsubs thehyp, Linea13 Ssubm \
                  , Ei1 z zins

>>                line91: [((line90 Subs1 (thehyp
>>                     Mpsubs (Ssubm Linea13 (z
>>                     Ei1 zins)))):that (xx E
>>                     Rcal(chosenof(S))))]
>>                  {move 5}



               define line92 case2: Fixform(chosenof \
                  S <~ xx,(Mpsubs line85 Ssubm \
                  zins Ssubm) Conj (Mpsubs \
                  thehyp Ssubm) Conj (Negeqsymm \
                  case2) Conj line91)

>>                line92: [(case2_1:that ~((xx
>>                     = chosenof(S)))) => (((chosenof(S)
>>                     <~ xx) Fixform (((Ssubm
>>                     line85 zins) Mpsubs Ssubm)
>>                     Conj ((thehyp Mpsubs Ssubm)
>>                     Conj (Negeqsymm(case2_1)
>>                     Conj line91)))):that (chosenof(S)
>>                     <~ xx))]
>>                  {move 5}



               define line93 case2: Add2(xx=chosenof \
                  S,line92 case2)

>>                line93: [(case2_1:that ~((xx
>>                     = chosenof(S)))) => (((xx
>>                     = chosenof(S)) Add2 line92(case2_1)):
>>                     that ((xx = chosenof(S))
>>                     V (chosenof(S) <~ xx)))]
>>                  {move 5}



               close

            define line94 thehyp: Cases line86 \
               thehyp, line87, line93

>>             line94: [(thehyp_1:that (xx E
>>                  S)) => (Cases(line86(thehyp_1),
>>                  [(case1_2:that (xx = chosenof(S)))
>>                     => (((chosenof(S) <~ xx)
>>                     Add1 case1_2):that ((xx
>>                     = chosenof(S)) V (chosenof(S)
>>                     <~ xx)))]
>>                  ,[(case2_3:that ~((xx = chosenof(S))))
>>                     => (((xx = chosenof(S))
>>                     Add2 ((chosenof(S) <~ xx)
>>                     Fixform (((Ssubm line85
>>                     zins) Mpsubs Ssubm) Conj
>>                     ((thehyp_1 Mpsubs Ssubm)
>>                     Conj (Negeqsymm(case2_3)
>>                     Conj (((Rcal1(S) = Rcal(chosenof(S)))
>>                     Fixform Line41((((Ssubm
>>                     line85 zins) Mpsubs Ssubm)
>>                     Iff2 (chosenof(S) Uscsubs
>>                     M)),(chosenof(S) Pairinhabited
>>                     chosenof(S)),((Ssubm Line4
>>                     (z Ei1 zins)) Conj ((((Ssubm
>>                     line85 zins) Mpsubs (Ssubm
>>                     Linea13 (z Ei1 zins)))
>>                     Iff2 (chosenof(S) Uscsubs
>>                     Rcal1(S))) Conj Inusc2(chosenof(S))))))
>>                     Subs1 (thehyp_1 Mpsubs
>>                     (Ssubm Linea13 (z Ei1 zins))))))))):
>>                     that ((xx = chosenof(S))
>>                     V (chosenof(S) <~ xx)))])
>>                  :that ((xx = chosenof(S))
>>                  V (chosenof(S) <~ xx)))]
>>               {move 4}



            close

         define line95 xx: Ded line94

>>          line95: [(xx_1:obj) => (Ded([(thehyp_2:
>>                  that (xx_1 E S)) => (Cases(Excmid((xx_1
>>                  = chosenof(S))),[(case1_3:
>>                     that (xx_1 = chosenof(S)))
>>                     => (((chosenof(S) <~ xx_1)
>>                     Add1 case1_3):that ((xx_1
>>                     = chosenof(S)) V (chosenof(S)
>>                     <~ xx_1)))]
>>                  ,[(case2_4:that ~((xx_1 =
>>                     chosenof(S)))) => (((xx_1
>>                     = chosenof(S)) Add2 ((chosenof(S)
>>                     <~ xx_1) Fixform (((Ssubm
>>                     line85 zins) Mpsubs Ssubm)
>>                     Conj ((thehyp_2 Mpsubs
>>                     Ssubm) Conj (Negeqsymm(case2_4)
>>                     Conj (((Rcal1(S) = Rcal(chosenof(S)))
>>                     Fixform Line41((((Ssubm
>>                     line85 zins) Mpsubs Ssubm)
>>                     Iff2 (chosenof(S) Uscsubs
>>                     M)),(chosenof(S) Pairinhabited
>>                     chosenof(S)),((Ssubm Line4
>>                     (z Ei1 zins)) Conj ((((Ssubm
>>                     line85 zins) Mpsubs (Ssubm
>>                     Linea13 (z Ei1 zins)))
>>                     Iff2 (chosenof(S) Uscsubs
>>                     Rcal1(S))) Conj Inusc2(chosenof(S))))))
>>                     Subs1 (thehyp_2 Mpsubs
>>                     (Ssubm Linea13 (z Ei1 zins))))))))):
>>                     that ((xx_1 = chosenof(S))
>>                     V (chosenof(S) <~ xx_1)))])
>>                  :that ((xx_1 = chosenof(S))
>>                  V (chosenof(S) <~ xx_1)))])
>>               :that ((xx_1 E S) -> ((xx_1 =
>>               chosenof(S)) V (chosenof(S) <~
>>               xx_1))))]
>>            {move 3}



         close

      define line96 Ssubm zins: Ug line95


>>       line96: [(.S_1:obj),(Ssubm_1:that (.S_1
>>            <<= M)),(.z_1:obj),(zins_1:that
>>            (.z_1 E .S_1)) => (Ug([(xx_3:obj)
>>               => (Ded([(thehyp_4:that (xx_3
>>                  E .S_1)) => (Cases(Excmid((xx_3
>>                  = chosenof(.S_1))),[(case1_5:
>>                     that (xx_3 = chosenof(.S_1)))
>>                     => (((chosenof(.S_1) <~
>>                     xx_3) Add1 case1_5):that
>>                     ((xx_3 = chosenof(.S_1))
>>                     V (chosenof(.S_1) <~ xx_3)))]
>>                  ,[(case2_6:that ~((xx_3 =
>>                     chosenof(.S_1)))) => (((xx_3
>>                     = chosenof(.S_1)) Add2
>>                     ((chosenof(.S_1) <~ xx_3)
>>                     Fixform (((Ssubm_1 line85
>>                     zins_1) Mpsubs Ssubm_1)
>>                     Conj ((thehyp_4 Mpsubs
>>                     Ssubm_1) Conj (Negeqsymm(case2_6)
>>                     Conj (((Rcal1(.S_1) = Rcal(chosenof(.S_1)))
>>                     Fixform Line41((((Ssubm_1
>>                     line85 zins_1) Mpsubs Ssubm_1)
>>                     Iff2 (chosenof(.S_1) Uscsubs
>>                     M)),(chosenof(.S_1) Pairinhabited
>>                     chosenof(.S_1)),((Ssubm_1
>>                     Line4 (.z_1 Ei1 zins_1))
>>                     Conj ((((Ssubm_1 line85
>>                     zins_1) Mpsubs (Ssubm_1
>>                     Linea13 (.z_1 Ei1 zins_1)))
>>                     Iff2 (chosenof(.S_1) Uscsubs
>>                     Rcal1(.S_1))) Conj Inusc2(chosenof(.S_1))))))
>>                     Subs1 (thehyp_4 Mpsubs
>>                     (Ssubm_1 Linea13 (.z_1
>>                     Ei1 zins_1))))))))):that
>>                     ((xx_3 = chosenof(.S_1))
>>                     V (chosenof(.S_1) <~ xx_3)))])
>>                  :that ((xx_3 = chosenof(.S_1))
>>                  V (chosenof(.S_1) <~ xx_3)))])
>>               :that ((xx_3 E .S_1) -> ((xx_3
>>               = chosenof(.S_1)) V (chosenof(.S_1)
>>               <~ xx_3))))])
>>            :that Forall([(xx_13:obj) => (((xx_13
>>               E .S_1) -> ((xx_13 = chosenof(.S_1))
>>               V (chosenof(.S_1) <~ xx_13))):
>>               prop)]))
>>            ]
>>         {move 2}



      define line97 Ssubm zins: Ei1 chosenof \
         S,Conj (line85 Ssubm zins,line96 Ssubm \
         zins)

>>       line97: [(.S_1:obj),(Ssubm_1:that (.S_1
>>            <<= M)),(.z_1:obj),(zins_1:that
>>            (.z_1 E .S_1)) => ((chosenof(.S_1)
>>            Ei1 ((Ssubm_1 line85 zins_1) Conj
>>            (Ssubm_1 line96 zins_1))):that Exists([(x_5:
>>               obj) => (((x_5 E .S_1) & Forall([(xx_6:
>>                  obj) => (((xx_6 E .S_1) ->
>>                  ((xx_6 = x_5) V (x_5 <~ xx_6))):
>>                  prop)]))
>>               :prop)]))
>>            ]
>>         {move 2}



      open

         declare x66 obj

>>          x66: obj {move 4}



         declare thehyp that (S <<= M ) & \
            Exists[x66 => x66 E S] \
            



>>          thehyp: that ((S <<= M) & Exists([(x66_1:
>>               obj) => ((x66_1 E S):prop)]))
>>            {move 4}



         open

            declare y66 obj

>>             y66: obj {move 5}



            declare yins66 that y66 E S

>>             yins66: that (y66 E S) {move
>>               5}



            define line98 yins66 : line97 \
               Simp1 thehyp yins66

>>             line98: [(.y66_1:obj),(yins66_1:
>>                  that (.y66_1 E S)) => ((Simp1(thehyp)
>>                  line97 yins66_1):that Exists([(x_3:
>>                     obj) => (((x_3 E S) & Forall([(xx_4:
>>                        obj) => (((xx_4 E S)
>>                        -> ((xx_4 = x_3) V (x_3
>>                        <~ xx_4))):prop)]))
>>                     :prop)]))
>>                  ]
>>               {move 4}



            close

         define line99 thehyp: Eg Simp2 thehyp \
            line98

>>          line99: [(thehyp_1:that ((S <<=
>>               M) & Exists([(x66_2:obj) => ((x66_2
>>                  E S):prop)]))
>>               ) => ((Simp2(thehyp_1) Eg [(.y66_7:
>>                  obj),(yins66_7:that (.y66_7
>>                  E S)) => ((Simp1(thehyp_1)
>>                  line97 yins66_7):that Exists([(x_9:
>>                     obj) => (((x_9 E S) & Forall([(xx_10:
>>                        obj) => (((xx_10 E S)
>>                        -> ((xx_10 = x_9) V
>>                        (x_9 <~ xx_10))):prop)]))
>>                     :prop)]))
>>                  ])
>>               :that Exists([(x_11:obj) => (((x_11
>>                  E S) & Forall([(xx_12:obj)
>>                     => (((xx_12 E S) -> ((xx_12
>>                     = x_11) V (x_11 <~ xx_12))):
>>                     prop)]))
>>                  :prop)]))
>>               ]
>>            {move 3}



         close

      define line100 S: Ded line99

>>       line100: [(S_1:obj) => (Ded([(thehyp_5:
>>               that ((S_1 <<= M) & Exists([(x66_6:
>>                  obj) => ((x66_6 E S_1):prop)]))
>>               ) => ((Simp2(thehyp_5) Eg [(.y66_11:
>>                  obj),(yins66_11:that (.y66_11
>>                  E S_1)) => ((Simp1(thehyp_5)
>>                  line97 yins66_11):that Exists([(x_13:
>>                     obj) => (((x_13 E S_1)
>>                     & Forall([(xx_14:obj) =>
>>                        (((xx_14 E S_1) -> ((xx_14
>>                        = x_13) V (x_13 <~ xx_14))):
>>                        prop)]))
>>                     :prop)]))
>>                  ])
>>               :that Exists([(x_15:obj) => (((x_15
>>                  E S_1) & Forall([(xx_16:obj)
>>                     => (((xx_16 E S_1) -> ((xx_16
>>                     = x_15) V (x_15 <~ xx_16))):
>>                     prop)]))
>>                  :prop)]))
>>               ])
>>            :that (((S_1 <<= M) & Exists([(x66_17:
>>               obj) => ((x66_17 E S_1):prop)]))
>>            -> Exists([(x_18:obj) => (((x_18
>>               E S_1) & Forall([(xx_19:obj)
>>                  => (((xx_19 E S_1) -> ((xx_19
>>                  = x_18) V (x_18 <~ xx_19))):
>>                  prop)]))
>>               :prop)]))
>>            )]
>>         {move 2}



      close

   define line101: Ug line100

>>    line101: [(Ug([(S_1:obj) => (Ded([(thehyp_8:
>>               that ((S_1 <<= M) & Exists([(x66_9:
>>                  obj) => ((x66_9 E S_1):prop)]))
>>               ) => ((Simp2(thehyp_8) Eg [(.y66_14:
>>                  obj),(yins66_14:that (.y66_14
>>                  E S_1)) => ((thelaw(Rcal1(S_1))
>>                  Ei1 (((thelaw(Rcal1(S_1))
>>                  E S_1) Fixform (Simp1(thehyp_8)
>>                  Line27 (.y66_14 Ei1 yins66_14)))
>>                  Conj Ug([(xx_21:obj) => (Ded([(thehyp_22:
>>                        that (xx_21 E S_1))
>>                        => (Cases(Excmid((xx_21
>>                        = thelaw(Rcal1(S_1)))),
>>                        [(case1_23:that (xx_21
>>                           = thelaw(Rcal1(S_1))))
>>                           => (((thelaw(Rcal1(S_1))
>>                           <~ xx_21) Add1 case1_23):
>>                           that ((xx_21 = thelaw(Rcal1(S_1)))
>>                           V (thelaw(Rcal1(S_1))
>>                           <~ xx_21)))]
>>                        ,[(case2_24:that ~((xx_21
>>                           = thelaw(Rcal1(S_1)))))
>>                           => (((xx_21 = thelaw(Rcal1(S_1)))
>>                           Add2 ((thelaw(Rcal1(S_1))
>>                           <~ xx_21) Fixform
>>                           ((((thelaw(Rcal1(S_1))
>>                           E S_1) Fixform (Simp1(thehyp_8)
>>                           Line27 (.y66_14 Ei1
>>                           yins66_14))) Mpsubs
>>                           Simp1(thehyp_8))
>>                           Conj ((thehyp_22
>>                           Mpsubs Simp1(thehyp_8))
>>                           Conj (Negeqsymm(case2_24)
>>                           Conj (((Rcal1(S_1)
>>                           = Rcal(thelaw(Rcal1(S_1))))
>>                           Fixform Line41(((((thelaw(Rcal1(S_1))
>>                           E S_1) Fixform (Simp1(thehyp_8)
>>                           Line27 (.y66_14 Ei1
>>                           yins66_14))) Mpsubs
>>                           Simp1(thehyp_8))
>>                           Iff2 (thelaw(Rcal1(S_1))
>>                           Uscsubs M)),(thelaw(Rcal1(S_1))
>>                           Pairinhabited thelaw(Rcal1(S_1))),
>>                           ((Simp1(thehyp_8)
>>                           Line4 (.y66_14 Ei1
>>                           yins66_14)) Conj
>>                           (((((thelaw(Rcal1(S_1))
>>                           E S_1) Fixform (Simp1(thehyp_8)
>>                           Line27 (.y66_14 Ei1
>>                           yins66_14))) Mpsubs
>>                           (Simp1(thehyp_8)
>>                           Linea13 (.y66_14
>>                           Ei1 yins66_14)))
>>                           Iff2 (thelaw(Rcal1(S_1))
>>                           Uscsubs Rcal1(S_1)))
>>                           Conj Inusc2(thelaw(Rcal1(S_1)))))))
>>                           Subs1 (thehyp_22
>>                           Mpsubs (Simp1(thehyp_8)
>>                           Linea13 (.y66_14
>>                           Ei1 yins66_14))))))))):
>>                           that ((xx_21 = thelaw(Rcal1(S_1)))
>>                           V (thelaw(Rcal1(S_1))
>>                           <~ xx_21)))])
>>                        :that ((xx_21 = thelaw(Rcal1(S_1)))
>>                        V (thelaw(Rcal1(S_1))
>>                        <~ xx_21)))])
>>                     :that ((xx_21 E S_1) ->
>>                     ((xx_21 = thelaw(Rcal1(S_1)))
>>                     V (thelaw(Rcal1(S_1)) <~
>>                     xx_21))))]))
>>                  ):that Exists([(x_43:obj)
>>                     => (((x_43 E S_1) & Forall([(xx_44:
>>                        obj) => (((xx_44 E S_1)
>>                        -> ((xx_44 = x_43) V
>>                        (x_43 <~ xx_44))):prop)]))
>>                     :prop)]))
>>                  ])
>>               :that Exists([(x_45:obj) => (((x_45
>>                  E S_1) & Forall([(xx_46:obj)
>>                     => (((xx_46 E S_1) -> ((xx_46
>>                     = x_45) V (x_45 <~ xx_46))):
>>                     prop)]))
>>                  :prop)]))
>>               ])
>>            :that (((S_1 <<= M) & Exists([(x66_2:
>>               obj) => ((x66_2 E S_1):prop)]))
>>            -> Exists([(x_3:obj) => (((x_3 E
>>               S_1) & Forall([(xx_4:obj) =>
>>                  (((xx_4 E S_1) -> ((xx_4 =
>>                  x_3) V (x_3 <~ xx_4))):prop)]))
>>               :prop)]))
>>            )])
>>         :that Forall([(S_47:obj) => ((((S_47
>>            <<= M) & Exists([(x66_48:obj) =>
>>               ((x66_48 E S_47):prop)]))
>>            -> Exists([(x_49:obj) => (((x_49
>>               E S_47) & Forall([(xx_50:obj)
>>                  => (((xx_50 E S_47) -> ((xx_50
>>                  = x_49) V (x_49 <~ xx_50))):
>>                  prop)]))
>>               :prop)]))
>>            :prop)]))
>>         ]
>>      {move 1}



   close
comment the following line will not run until we work on definition expansion control in the text above

comment define line102 Misset thelawchooses: line101

\end{verbatim}

\end{document}

quit
