\documentclass[12pt]{article}

\usepackage{amssymb}

\title{Implementation of Zermelo's work of 1908 in Lestrade}

\author{M. Randall Holmes}

\begin{document}

\maketitle

\section{Introduction}
 
This document was originally titled as an essay on the proposition that mathematics is what can be done in Automath (as opposed to what can be done in ZFC, for example).  Such an essay is still in in my mind, but this particular document has transformed itself into the large project of implementing Zermelo's two important set theory papers of 1908 in Lestrade, with the further purpose of exploring the actual capabilities of Zermelo's system of 1908 as a mathematical foundation, which we think are perhaps underrated.

\section{Introducing Lestrade}

Text in Lestrade is a series of declarations and definitions of entities of various sorts, which fall into two large categories, {\em objects\/} and {\tt constructions\/}.

There are five kinds of sorts of object:  there is a sort {\tt prop} of propositions, there is a sort {\tt type} of type labels and there is a sort {\tt obj} of ``untyped mathematical objects" (which we will use as the sort of the sets in our implementation of Zermelo set theory and ZFC).  Then there are two systems of parameterized sorts which can be expanded as the Lestrade text develops:  for each proposition $p$ there is a sort {\tt that} $p$, inhabited by evidence for $p$ (a proof of $p$ is evidence, but we prefer the less definite term for the sort);  for each type label $\tau$ there is a sort {\tt in} $\tau$ (which we may call the type $\tau$).  The types are intended to be inhabited by typed  mathematical objects.

Constructions are ``functions" in the most general sense.  A construction sort is of the form $[x_1:\tau_1,x_2:\tau_2,\ldots,x_n:\tau_n \Rightarrow \tau]$, where the $\tau_i$ of each input parameter $x_i$  is an object or construction sort, $\tau$ is an object sort, and the output sort $\tau$ may depend on the values of any or all of the $x_i$'s, while each $\tau_j$ may depend on any or all $x_i$'s for $i<j$.  In other words, constructions are dependently typed.  We will see this at work in examples.

We have just described basically the entire framework.  All further concepts are introduced by specific declarations and definitions in the Lestrade environment.

This is less powerful than Automath, it should be observed.  No construction produces a construction as output (though a construction can take a construction as input and produce an object as output and this feature can be used to encapsulate constructions in actual objects of appropriate types, which we would be more likely to call ``functions".  In Automath, functions are first class objects and function types are first class types, and we will see that this gives Automath strength which would make it difficult to replicate our implementation of (first-order) Zermelo set theory in Automath.

Nonetheless, philosophically it {\em is\/} Automath:  it is a system of dependent type theory intended to implement mathematical objects and proofs about mathematical objects in parallel ways, the parallelism mediated by the Curry-Howard isomorphism.   It might be characterized as more cautious Automath.



\section{Developing logic}

We will develop classical logic, but in a way which can readily be cut down to constructive logic.

\begin{verbatim}Lestrade execution:


declare p prop

>> p: prop {move 1}



declare q prop

>> q: prop {move 1}



postulate & p q prop

>> &: [(p_1:prop),(q_1:prop) => (---:prop)]
>>   {move 0}



postulate -> p q prop

>> ->: [(p_1:prop),(q_1:prop) => (---:prop)]
>>   {move 0}



postulate V p q prop

>> V: [(p_1:prop),(q_1:prop) => (---:prop)]
>>   {move 0}



postulate ?? prop

>> ??: prop {move 0}


\end{verbatim}

Above are the declarations for basic operations of propositional logic.  We introduce propositional variables usable as parameters in our declarations using the {\tt declare\/} command, then
introduce primitives of conjunction, implicatation, disjunction, and the False using the {\tt postulate\/} command.  That {\bf ??} is a constant rather than a variable parameter
can be seen in its designation at {\tt move 0\/} rather than {\tt move 1\/}, the designation attached to the parameters {\tt p} and {\tt q\/}.

\begin{verbatim}Lestrade execution:


declare pp that p

>> pp: that p {move 1}



declare qq that q

>> qq: that q {move 1}



declare rr that p & q

>> rr: that (p & q) {move 1}



postulate Conj pp qq that p & q

>> Conj: [(.p_1:prop),(pp_1:that .p_1),(.q_1:
>>      prop),(qq_1:that .q_1) => (---:that (.p_1
>>      & .q_1))]
>>   {move 0}



postulate Simp1 rr that p

>> Simp1: [(.p_1:prop),(.q_1:prop),(rr_1:that
>>      (.p_1 & .q_1)) => (---:that .p_1)]
>>   {move 0}



postulate Simp2 rr that q

>> Simp2: [(.p_1:prop),(.q_1:prop),(rr_1:that
>>      (.p_1 & .q_1)) => (---:that .q_1)]
>>   {move 0}


\end{verbatim}

Above we declare the rules of deduction for conjunction as constructions.   Parameters {\tt pp}, {\tt qq}, and {\tt rr} representing evidence for $p$, $q$, and $p \wedge q$ respectively, are introduced.  We then declare primitive functions which take proofs of $p$ and $q$ to a proof of $p \wedge q$, and which extract proofs of $p$ and $q$ from a proof of $p \wedge q$.

Notice that the dependently typed constructions {\tt Conj}, {\tt Simp1}, and {\tt Simp2} also have $p$ and $q$ as implicit arguments (the values of the implicit arguments can be deduced from the types of the explicit arguments;  this feature took work to install!)

\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare q prop

>> q: prop {move 1}



declare rr that p & q

>> rr: that (p & q) {move 1}



define Conjsymm rr : Conj(Simp2 rr,Simp1 \
   rr)

>> Conjsymm: [(.p_1:prop),(.q_1:prop),(rr_1:
>>      that (.p_1 & .q_1)) => ((Simp2(rr_1) Conj
>>      Simp1(rr_1)):that (.q_1 & .p_1))]
>>   {move 0}



open

   declare r prop

>>    r: prop {move 2}



   declare s prop

>>    s: prop {move 2}



   declare t prop

>>    t: prop {move 2}



   declare ss that r & s & t

>>    ss: that (r & (s & t)) {move 2}



   define conjtest ss : Conjsymm ss

>>    conjtest: [(.r_1:prop),(.s_1:prop),(.t_1:
>>         prop),(ss_1:that (.r_1 & (.s_1 & .t_1)))
>>         => (---:that ((.s_1 & .t_1) & .r_1))]
>>      {move 1}



   close
\end{verbatim}

In this block of text we verify a rule of inference (from $p \wedge q$, infer $q \wedge p$) and present an example of its use.

The {\tt clearcurrent} command clears all the variables currently declared, so $p$, $q$ and {\tt rr} have to be declared again.

The proof of the rule of inference is simply presented as a calculation:  we will see examples below where proof development looks more the way we expect a proof to look.

The example is encapsulated in a local environment (indicated by the {\tt open} and {\tt close} commands).  Notice that the parameters introduced locally to that environment
are labelld {\tt move 2}, and the proof {\tt conjtest} constructed in the local environment is labelled {\tt move 1}:  it will be cleared at the next execution of the {\tt clearcurrent}
command, while {\tt Conjsymm}, developed at move 0, is a permanently recorded theorem.

\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare q prop

>> q: prop {move 1}



declare pp that p

>> pp: that p {move 1}



declare rr that p -> q

>> rr: that (p -> q) {move 1}



postulate Mp pp rr that q

>> Mp: [(.p_1:prop),(pp_1:that .p_1),(.q_1:prop),
>>      (rr_1:that (.p_1 -> .q_1)) => (---:that
>>      .q_1)]
>>   {move 0}



open

   declare pp1 that p

>>    pp1: that p {move 2}



   postulate ded pp1 that q

>>    ded: [(pp1_1:that p) => (---:that q)]
>>      {move 1}



   close

postulate Ded ded that p -> q

>> Ded: [(.p_1:prop),(.q_1:prop),(ded_1:[(pp1_2:
>>         that .p_1) => (---:that .q_1)])
>>      => (---:that (.p_1 -> .q_1))]
>>   {move 0}


\end{verbatim}

In this block we present the primitive rules for implication.  The rule of modus ponens requires no special comment:  it is developed in much the same way as
the rules for conjunction above.

The rule {\tt Ded} which implements the deduction theorem is a more subtle object, and the way it is developed involves subtle use of the Lestrade environment system.

What {\tt Ded} does is readily described:  it takes implicit arguments $p$ and $q$ (deducible from the type of the explicit argument) and a construction of evidence for $q$ from evidence for $p$, and returns a proof of $p \rightarrow q$.

It makes an important point about the difference between Lestrade and Automath (and other Automath relatives) that a construction of type \newline $[p:{\tt prop} \Rightarrow {\tt that} \,q]$ is not itself a proof of (or even evidence for) $p \rightarrow q$:  such a construction is actually in itself a rule of inference rather than an implication.  That we can infer $q$ from $p$ (a rule of inference, and a construction) is cast to a proof of $p\rightarrow q$ (an entity) by the constructor {\tt Ded}.

To explain how it is done, we need to outline the story of Lestrade environments.  At any given point, we are committed to objects in a move $i$ (and all moves $j$ for $j<i$) and may declare variable parameters in
move $i+1$.  The system variable $i$ is usually 0:  the {\tt open} command has the effect of creating a new empty move $i+2$ and then incrementing $i$;  the {\tt close} command has
the effect of erasing all declarations and definitions in move $i+1$ and decrementing $i$.  $i$ cannot be decremented below 0.  The {\tt clearcurrent} command has the effect
of clearing move $i+1$ without decrementing $i$:  this can be used to clear move 1, which would otherwise get cluttered.  Anything declared in move 0 is permanent.

The {\tt declare} command is used to introduce new objects in move $i+1$, which serve as parameters in declarations and definitions.

The {\tt postulate} command, the mechanism for introduction of primitive notions and axioms,  declares an identifier as a constant in move $i$ of a given type, either an object if it is presented with no arguments, or a construction if it is presented
with a list of arguments from move $i+1$ appearing in the order in which they are declared (the order condition is  a cheap way to ensure that type dependencies are coherent).  As we have seen above, some arguments may be left implicit, if they can be deduced from the types of the explicitly given arguments.

The {\tt define} command defines an identifier as equivalent to an object term in move $i$ (if it has no arguments) or as a construction in move $i$ if it is presented with
move $i+1$ arguments in the correct order.   Of course this only works if the term types correctly.  This command is the vehicle for introduction of defined notions and theorems.

Declaration information recorded in type $i$ will expand any definitions in type $i+1$ on which the declaration or definition depended, because such information may disappear
when move $i+1$ is cleared.

Notice that constructions are declared in prefix form, but once declared can be used in infix form.  Lestrade treats most arity 2 operators as infix in output.

This is only a brief account, enough to support the origin story of {\tt Ded}.  We execute {\tt open}, so we are in move 1 instead of move 0.  We introduce a move 2
parameter {\tt pp1} representing evidence for $p$.  We declare a construction {\tt ded} which takes {\tt pp1} as input and outputs evidence for $q$:  this is a move 1 object.
We then execute {\tt close}, so that {\tt ded} appears at move 1 while we are in move 0.  Since {\tt ded} is not a defined object, it is viewed as a variable parameter of the appropriate type,
which allows us to use the {\tt postulate} command to declare {\tt Ded} with the expected behavior.  It is a subtle point that primitive notions and axioms declared in move $i+1$ using
{\tt postulate} become variable parameters when we transition to move $i$.

\begin{verbatim}Lestrade execution:


open

   declare pp2 that p

>>    pp2: that p {move 2}



   declare ded2 [pp2 => that q] \
      



>>    ded2: [(pp2_1:that p) => (---:that q)]
>>      {move 2}



   postulate Ded2 ded2 that p-> q

>>    Ded2: [(ded2_1:[(pp2_2:that p) => (---:
>>            that q)])
>>         => (---:that (p -> q))]
>>      {move 1}



   close
\end{verbatim}

Here we illustrate how the deduction theorem construction could be declared without a local environment (though we package the whole experiment in a local environment so that the redundant  construction we declare can be discarded).  The key move here is that {\tt ded2} is declared directly with a construction type.   Notice that {\tt Ded2} has the same dependent type as {\tt Ded}.  If the {\tt open} and {\tt close} were removed, this block would declare the deduction theorem as a primitive construction in move 0, functionally equivalent to {\tt Ded} already declared above.

\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare q prop

>> q: prop {move 1}



open

   declare rr that p & q

>>    rr: that (p & q) {move 2}



   define line1 rr: Conjsymm rr

>>    line1: [(rr_1:that (p & q)) => (---:that
>>         (q & p))]
>>      {move 1}



   close

define Consymmimp p q: Ded line1

>> Consymmimp: [(p_1:prop),(q_1:prop) => (Ded([(rr_2:
>>         that (p_1 & q_1)) => (Conjsymm(rr_2):
>>         that (q_1 & p_1))])
>>      :that ((p_1 & q_1) -> (q_1 & p_1)))]
>>   {move 0}


\end{verbatim}

Here is an example of use of {\tt Ded}.  Do notice that {\tt line1} and {\tt Conjsymm} have different types:  the implicit type mechanism obscures the true type of {\tt Conjsymm}, which is not suitable for use as an input to {\tt Ded}.


\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



define ~ p : p -> ??

>> ~: [(p_1:prop) => ((p_1 -> ??):prop)]
>>   {move 0}



declare absurd that ??

>> absurd: that ?? {move 1}



postulate Giveup p absurd that p

>> Giveup: [(p_1:prop),(absurd_1:that ??) =>
>>      (---:that p_1)]
>>   {move 0}



declare maybe that ~ ~ p

>> maybe: that ~(~(p)) {move 1}



postulate Dneg maybe that p

>> Dneg: [(.p_1:prop),(maybe_1:that ~(~(.p_1)))
>>      => (---:that .p_1)]
>>   {move 0}



declare q prop

>> q: prop {move 1}



define == p q : (p -> q) & q -> p

>> ==: [(p_1:prop),(q_1:prop) => (((p_1 -> q_1)
>>      & (q_1 -> p_1)):prop)]
>>   {move 0}


\end{verbatim}

Here we define negation $\neg p$ as $p \rightarrow \, \perp$ ($\perp$ being the absurd), introduce the rule that anything follows from the absurd, and introduce the primitive rule of  double negation which makes the logic classical.
All of our other primitive constructions of logic are constructive.

We incidentally define the biconditional.


\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare q prop

>> q: prop {move 1}



declare r prop

>> r: prop {move 1}



declare pp that p

>> pp: that p {move 1}



declare qq that q

>> qq: that q {move 1}



declare rr that p V q

>> rr: that (p V q) {move 1}



postulate Add1 q pp that p V q

>> Add1: [(q_1:prop),(.p_1:prop),(pp_1:that
>>      .p_1) => (---:that (.p_1 V q_1))]
>>   {move 0}



postulate Add2 p qq that p V q

>> Add2: [(p_1:prop),(.q_1:prop),(qq_1:that
>>      .q_1) => (---:that (p_1 V .q_1))]
>>   {move 0}



declare case1 [pp => that r] \
   



>> case1: [(pp_1:that p) => (---:that r)]
>>   {move 1}



declare case2 [qq => that r] \
   



>> case2: [(qq_1:that q) => (---:that r)]
>>   {move 1}



postulate Cases rr case1, case2 that r

>> Cases: [(.p_1:prop),(.q_1:prop),(rr_1:that
>>      (.p_1 V .q_1)),(.r_1:prop),(case1_1:[(pp_2:
>>         that .p_1) => (---:that .r_1)]),
>>      (case2_1:[(qq_3:that .q_1) => (---:that
>>         .r_1)])
>>      => (---:that .r_1)]
>>   {move 0}


\end{verbatim}

Here we develop the primitive rules of disjunction, the two rules of addition and the rule of proof by cases.

Here we use the approach of declaring the two constructions which implement the cases directly as construction variables, rather than the indirect though philosophically interesting approach using local environments exhibited in the development of the deduction theorem.

\section{Propositional logic lemmas}

This space is reserved for proofs of lemmas in propositional logic as we require them for proofs below.

\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare pp that p

>> pp: that p {move 1}



define Fixform p pp : pp

>> Fixform: [(p_1:prop),(pp_1:that p_1) => (pp_1:
>>      that p_1)]
>>   {move 0}


\end{verbatim}

{\tt Fixform} is a device for controlling the way that Lestrade expresses defined concepts in reported type information.


\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare q prop

>> q: prop {move 1}



declare pp that p

>> pp: that p {move 1}



declare qq that q

>> qq: that q {move 1}



declare iffev that p==q

>> iffev: that (p == q) {move 1}



define Iff1 pp iffev : Mp pp Simp1 iffev


>> Iff1: [(.p_1:prop),(pp_1:that .p_1),(.q_1:
>>      prop),(iffev_1:that (.p_1 == .q_1)) =>
>>      ((pp_1 Mp Simp1(iffev_1)):that .q_1)]
>>   {move 0}



define Iff2 qq iffev : Mp qq Simp2 iffev


>> Iff2: [(.q_1:prop),(qq_1:that .q_1),(.p_1:
>>      prop),(iffev_1:that (.p_1 == .q_1)) =>
>>      ((qq_1 Mp Simp2(iffev_1)):that .p_1)]
>>   {move 0}


\end{verbatim}

Rules of modus ponens for the biconditional

\begin{verbatim}Lestrade execution:


declare dir1 [pp => that q] \
   



>> dir1: [(pp_1:that p) => (---:that q)]
>>   {move 1}



declare dir2 [qq => that p] \
   



>> dir2: [(qq_1:that q) => (---:that p)]
>>   {move 1}



define Dediff dir1, dir2 : Fixform(p==q,Conj \
   (Ded dir1,Ded dir2))

>> Dediff: [(.p_1:prop),(.q_1:prop),(dir1_1:
>>      [(pp_2:that .p_1) => (---:that .q_1)]),
>>      (dir2_1:[(qq_3:that .q_1) => (---:that
>>         .p_1)])
>>      => (((.p_1 == .q_1) Fixform (Ded(dir1_1)
>>      Conj Ded(dir2_1))):that (.p_1 == .q_1))]
>>   {move 0}


\end{verbatim}

The deduction theorem for biconditionals

\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare pp that p

>> pp: that p {move 1}



declare porpev that p V p

>> porpev: that (p V p) {move 1}


\end{verbatim}

The idempotent property of disjunction.  This (below) demonstrates that from $p \vee p$ we can deduce $p$.

\begin{verbatim}Lestrade execution:


define Oridem porpev : Cases porpev [pp => \
      pp] \
   , [pp=> pp] \
   



>> Oridem: [(.p_1:prop),(porpev_1:that (.p_1
>>      V .p_1)) => (Cases(porpev_1,[(pp_2:that
>>         .p_1) => (pp_2:that .p_1)]
>>      ,[(pp_3:that .p_1) => (pp_3:that .p_1)])
>>      :that .p_1)]
>>   {move 0}


clearcurrent


declare p prop

>> p: prop {move 1}



declare pp that p

>> pp: that p {move 1}



declare adabsurdum [pp => that ??] \
   



>> adabsurdum: [(pp_1:that p) => (---:that ??)]
>>   {move 1}



define Negintro adabsurdum : Fixform (~ p, \
   Ded adabsurdum)

>> Negintro: [(.p_1:prop),(adabsurdum_1:[(pp_2:
>>         that .p_1) => (---:that ??)])
>>      => ((~(.p_1) Fixform Ded(adabsurdum_1)):
>>      that ~(.p_1))]
>>   {move 0}


\end{verbatim}


Here is an example of using {\tt Fixform}:  {\tt Negintro} is actually a special case of the deduction theorem;  what {\tt Fixform} does is force the surface expression of the implication
$p \rightarrow \, \perp$ proved to $\neg p$.

We give the classical rules of inference from the negation of an implication.

\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare q prop

>> q: prop {move 1}



declare notimp that ~(p -> q)

>> notimp: that ~((p -> q)) {move 1}



open

   declare qev that q

>>    qev: that q {move 2}



   open

      declare pev that p

>>       pev: that p {move 3}



      define idqev pev: qev

>>       idqev: [(pev_1:that p) => (---:that
>>            q)]
>>         {move 2}



      close

   define line1 qev : Mp( Ded idqev,notimp)


>>    line1: [(qev_1:that q) => (---:that ??)]
>>      {move 1}



   close

define Notimp1 notimp: Negintro line1

>> Notimp1: [(.p_1:prop),(.q_1:prop),(notimp_1:
>>      that ~((.p_1 -> .q_1))) => (Negintro([(qev_2:
>>         that .q_1) => ((Ded([(pev_3:that .p_1)
>>            => (qev_2:that .q_1)])
>>         Mp notimp_1):that ??)])
>>      :that ~(.q_1))]
>>   {move 0}



open

   declare negpev that ~p

>>    negpev: that ~(p) {move 2}



   open

      declare pev that p

>>       pev: that p {move 3}



      define line2 pev: Giveup q, Mp pev \
         negpev

>>       line2: [(pev_1:that p) => (---:that
>>            q)]
>>         {move 2}



      close

   define line3 negpev: Mp (Ded line2,notimp)


>>    line3: [(negpev_1:that ~(p)) => (---:that
>>         ??)]
>>      {move 1}



   close

define Notimp2 notimp: Dneg(Negintro line3)


>> Notimp2: [(.p_1:prop),(.q_1:prop),(notimp_1:
>>      that ~((.p_1 -> .q_1))) => (Dneg(Negintro([(negpev_2:
>>         that ~(.p_1)) => ((Ded([(pev_3:that
>>            .p_1) => ((.q_1 Giveup (pev_3 Mp
>>            negpev_2)):that .q_1)])
>>         Mp notimp_1):that ??)]))
>>      :that .p_1)]
>>   {move 0}



declare notconjev that ~(p & q)

>> notconjev: that ~((p & q)) {move 1}



declare qev that q

>> qev: that q {move 1}



open

   declare pev that p

>>    pev: that p {move 2}



   define line4 pev: Mp(Conj pev qev,notconjev)


>>    line4: [(pev_1:that p) => (---:that ??)]
>>      {move 1}



   close

define Notconj notconjev qev : Negintro line4


>> Notconj: [(.p_1:prop),(.q_1:prop),(notconjev_1:
>>      that ~((.p_1 & .q_1))),(qev_1:that .q_1)
>>      => (Negintro([(pev_2:that .p_1) => (((pev_2
>>         Conj qev_1) Mp notconjev_1):that ??)])
>>      :that ~(.p_1))]
>>   {move 0}


\end{verbatim}

Above we present the rule of inference which gives us $\neg p$ if we have $\neg(p \wedge q)$ and $q$.

Now we develop the law of excluded middle.

\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



open

   declare nona that ~(p V ~p)

>>    nona: that ~((p V ~(p))) {move 2}



   open

      declare thatp that p

>>       thatp: that p {move 3}



      define line1 thatp: Add1(~p,thatp)


>>       line1: [(thatp_1:that p) => (---:that
>>            (p V ~(p)))]
>>         {move 2}



      define line2 thatp: Mp (line1 thatp, \
         nona)

>>       line2: [(thatp_1:that p) => (---:that
>>            ??)]
>>         {move 2}



      close

   define line3 nona: Negintro line2

>>    line3: [(nona_1:that ~((p V ~(p)))) =>
>>         (---:that ~(p))]
>>      {move 1}



   define line4 nona: Add2(p,line3 nona)


>>    line4: [(nona_1:that ~((p V ~(p)))) =>
>>         (---:that (p V ~(p)))]
>>      {move 1}



   define line5 nona: Mp(line4 nona,nona)


>>    line5: [(nona_1:that ~((p V ~(p)))) =>
>>         (---:that ??)]
>>      {move 1}



   close

define Excmid p : Dneg(Negintro line5)

>> Excmid: [(p_1:prop) => (Dneg(Negintro([(nona_2:
>>         that ~((p_1 V ~(p_1)))) => (((p_1 Add2
>>         Negintro([(thatp_3:that p_1) => (((~(p_1)
>>            Add1 thatp_3) Mp nona_2):that ??)]))
>>         Mp nona_2):that ??)]))
>>      :that (p_1 V ~(p_1)))]
>>   {move 0}


\end{verbatim}

We prove the rules of disjunctive syllogism.

\begin{verbatim}Lestrade execution:

clearcurrent


declare p prop

>> p: prop {move 1}



declare q prop

>> q: prop {move 1}



declare orev that p V q

>> orev: that (p V q) {move 1}



declare negpev that ~p

>> negpev: that ~(p) {move 1}



declare negqev that ~q

>> negqev: that ~(q) {move 1}



open

   declare negpev2 that ~p

>>    negpev2: that ~(p) {move 2}



   declare negqev2 that ~q

>>    negqev2: that ~(q) {move 2}



   open

      declare thatp that p

>>       thatp: that p {move 3}



      declare thatq that q

>>       thatq: that q {move 3}



      define line1 thatp: Mp thatp negpev2


>>       line1: [(thatp_1:that p) => (---:that
>>            ??)]
>>         {move 2}



      define line2 thatp: Mp thatp negpev


>>       line2: [(thatp_1:that p) => (---:that
>>            ??)]
>>         {move 2}



      define line3 thatq: Mp thatq negqev2


>>       line3: [(thatq_1:that q) => (---:that
>>            ??)]
>>         {move 2}



      define line4 thatq: Mp thatq negqev


>>       line4: [(thatq_1:that q) => (---:that
>>            ??)]
>>         {move 2}



      close

   define line5 negpev2: Cases orev, line1, \
      line4

>>    line5: [(negpev2_1:that ~(p)) => (---:
>>         that ??)]
>>      {move 1}



   define line6 negqev2:Cases orev,line2, \
      line3

>>    line6: [(negqev2_1:that ~(q)) => (---:
>>         that ??)]
>>      {move 1}



   close

define Ds1 orev negqev: Dneg (Negintro line5)


>> Ds1: [(.p_1:prop),(.q_1:prop),(orev_1:that
>>      (.p_1 V .q_1)),(negqev_1:that ~(.q_1))
>>      => (Dneg(Negintro([(negpev2_2:that ~(.p_1))
>>         => (Cases(orev_1,[(thatp_3:that .p_1)
>>            => ((thatp_3 Mp negpev2_2):that
>>            ??)]
>>         ,[(thatq_4:that .q_1) => ((thatq_4
>>            Mp negqev_1):that ??)])
>>         :that ??)]))
>>      :that .p_1)]
>>   {move 0}



define Ds2 orev negpev: Dneg(Negintro line6)


>> Ds2: [(.p_1:prop),(.q_1:prop),(orev_1:that
>>      (.p_1 V .q_1)),(negpev_1:that ~(.p_1))
>>      => (Dneg(Negintro([(negqev2_2:that ~(.q_1))
>>         => (Cases(orev_1,[(thatp_3:that .p_1)
>>            => ((thatp_3 Mp negpev_1):that ??)]
>>         ,[(thatq_4:that .q_1) => ((thatq_4
>>            Mp negqev2_2):that ??)])
>>         :that ??)]))
>>      :that .q_1)]
>>   {move 0}


\end{verbatim}

We enjoyed the sharing of environments in this proof.


\section{Quantification}

In this section, we introduce the universal and existential quantifiers over untyped objects (sort {\tt obj}) which will be the sets and atoms of our theory.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare pred [x => prop] \
   



>> pred: [(x_1:obj) => (---:prop)]
>>   {move 1}



postulate Forall pred prop

>> Forall: [(pred_1:[(x_2:obj) => (---:prop)])
>>      => (---:prop)]
>>   {move 0}



postulate Exists pred prop

>> Exists: [(pred_1:[(x_2:obj) => (---:prop)])
>>      => (---:prop)]
>>   {move 0}


\end{verbatim}

Here are the basic declarations for the universal and existential quantifiers (which are treated as separate primitives because they are separate
primitives in constructive logic).  

\begin{verbatim}Lestrade execution:


declare univev that Forall pred

>> univev: that Forall(pred) {move 1}



postulate Ui x univev that pred x

>> Ui: [(x_1:obj),(.pred_1:[(x_2:obj) => (---:
>>         prop)]),
>>      (univev_1:that Forall(.pred_1)) => (---:
>>      that .pred_1(x_1))]
>>   {move 0}



declare univev2 [x => that pred x] \
   



>> univev2: [(x_1:obj) => (---:that pred(x_1))]
>>   {move 1}



postulate Ug univev2 that Forall pred

>> Ug: [(.pred_1:[(x_2:obj) => (---:prop)]),
>>      (univev2_1:[(x_3:obj) => (---:that .pred_1(x_3))])
>>      => (---:that Forall(.pred_1))]
>>   {move 0}



declare y obj

>> y: obj {move 1}



postulate = x y prop

>> =: [(x_1:obj),(y_1:obj) => (---:prop)]
>>   {move 0}



postulate Refleq x that x=x

>> Refleq: [(x_1:obj) => (---:that (x_1 = x_1))]
>>   {move 0}



define Ugtest : Ug Refleq

>> Ugtest: [(Ug(Refleq):that Forall([(x_2:obj)
>>         => ((x_2 = x_2):prop)]))
>>      ]
>>   {move 0}


\end{verbatim}

Here are initial declarations for equality and an example of universal generalization.  The equality relation is declared, the rule of reflexivity presented, 
and the theorem $(\forall x:x=x)$ proved.

\begin{verbatim}Lestrade execution:


declare existsev that pred x

>> existsev: that pred(x) {move 1}



postulate Ei x pred, existsev that Exists \
   pred

>> Ei: [(x_1:obj),(pred_1:[(x_2:obj) => (---:
>>         prop)]),
>>      (existsev_1:that pred_1(x_1)) => (---:
>>      that Exists(pred_1))]
>>   {move 0}



define Ei1 x existsev : Ei x pred, existsev


>> Ei1: [(x_1:obj),(.pred_1:[(x_2:obj) => (---:
>>         prop)]),
>>      (existsev_1:that .pred_1(x_1)) => (Ei(x_1,
>>      .pred_1,existsev_1):that Exists(.pred_1))]
>>   {move 0}



define Ei2 pred, existsev : Ei x pred, existsev


>> Ei2: [(pred_1:[(x_2:obj) => (---:prop)]),
>>      (.x_1:obj),(existsev_1:that pred_1(.x_1))
>>      => (Ei(.x_1,pred_1,existsev_1):that Exists(pred_1))]
>>   {move 0}



declare existsev2 that Exists pred

>> existsev2: that Exists(pred) {move 1}



declare r prop

>> r: prop {move 1}



declare witnessev [x,existsev => that r] \
   



>> witnessev: [(x_1:obj),(existsev_1:that pred(x_1))
>>      => (---:that r)]
>>   {move 1}



postulate Eg existsev2 witnessev that r

>> Eg: [(.pred_1:[(x_2:obj) => (---:prop)]),
>>      (existsev2_1:that Exists(.pred_1)),(.r_1:
>>      prop),(witnessev_1:[(x_3:obj),(existsev_3:
>>         that .pred_1(x_3)) => (---:that .r_1)])
>>      => (---:that .r_1)]
>>   {move 0}



declare test obj

>> test: obj {move 1}



define Witnesses existsev2 test : pred test


>> Witnesses: [(.pred_1:[(x_2:obj) => (---:prop)]),
>>      (existsev2_1:that Exists(.pred_1)),(test_1:
>>      obj) => (.pred_1(test_1):prop)]
>>   {move 0}


\end{verbatim}

These are the declarations for the rules for the existential quantifier.  The rule of existential instantiation comes in various flavors, because the ability of
Lestrade to deduce implicit arguments in higher-order situations is nonzero but limited.  {\tt Witnesses} is a gadget for extracting an instance of an existential statement whose
surface form might not appear to be existential (so the user doesn't have to look up a definition).

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare eqev that x=y

>> eqev: that (x = y) {move 1}



declare pred [x=>prop] \
   



>> pred: [(x_1:obj) => (---:prop)]
>>   {move 1}



declare predev that pred x

>> predev: that pred(x) {move 1}



postulate Subs eqev pred, predev that pred \
   y

>> Subs: [(.x_1:obj),(.y_1:obj),(eqev_1:that
>>      (.x_1 = .y_1)),(pred_1:[(x_2:obj) => (---:
>>         prop)]),
>>      (predev_1:that pred_1(.x_1)) => (---:that
>>      pred_1(.y_1))]
>>   {move 0}



define Subs1 eqev, predev : Subs eqev pred, \
   predev

>> Subs1: [(.x_1:obj),(.y_1:obj),(eqev_1:that
>>      (.x_1 = .y_1)),(.pred_1:[(x_2:obj) =>
>>         (---:prop)]),
>>      (predev_1:that .pred_1(.x_1)) => (Subs(eqev_1,
>>      .pred_1,predev_1):that .pred_1(.y_1))]
>>   {move 0}


\end{verbatim}

The declaration of the rule of substitution (in two flavors) completes the logic of equality.  The two flavors are present because the implicit argument feature is not perfectly dependable where constructions are involved in matching, so one will sometimes want {\tt Subs} with the explicitly given predicate.

\section{Lemmas of first order logic with equality}

This is a space in which lemmas of first order logic with equality will be developed as needed below.  Substitution comes in a flavor with the predicate left implicit, but this cannot always be done.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare z obj

>> z: obj {move 1}



declare eqev1 that x=y

>> eqev1: that (x = y) {move 1}



declare eqev2 that y=z

>> eqev2: that (y = z) {move 1}



define Eqsymm eqev1 : Subs eqev1 [z=>z=x] \
   Refleq x

>> Eqsymm: [(.x_1:obj),(.y_1:obj),(eqev1_1:that
>>      (.x_1 = .y_1)) => (Subs(eqev1_1,[(z_2:
>>         obj) => ((z_2 = .x_1):prop)]
>>      ,Refleq(.x_1)):that (.y_1 = .x_1))]
>>   {move 0}



declare w obj

>> w: obj {move 1}



define Eqtrans eqev1 eqev2 : Subs1 eqev2 \
   eqev1

>> Eqtrans: [(.x_1:obj),(.y_1:obj),(eqev1_1:
>>      that (.x_1 = .y_1)),(.z_1:obj),(eqev2_1:
>>      that (.y_1 = .z_1)) => ((eqev2_1 Subs1
>>      eqev1_1):that (.x_1 = .z_1))]
>>   {move 0}


\end{verbatim}

Here are the expected symmetry and transitivity properties of equality.






We prove the classical theorem that $\neg (\forall x:\phi) \rightarrow (\exists x:\neg\phi)$ (actually in the form of a rule of inference).

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare pred [x => prop] \
   



>> pred: [(x_1:obj) => (---:prop)]
>>   {move 1}



declare negunivev that ~(Forall pred)

>> negunivev: that ~(Forall(pred)) {move 1}



open

   declare z obj

>>    z: obj {move 2}



   declare negexistev that ~(Exists [z => \
         ~(pred z)]) \
      



>>    negexistev: that ~(Exists([(z_1:obj) =>
>>         (~(pred(z_1)):prop)]))
>>      {move 2}



   open

      declare y obj

>>       y: obj {move 3}



      open

         declare absurdhyp that ~(pred y)


>>          absurdhyp: that ~(pred(y)) {move
>>            4}



         define line1 absurdhyp: Ei1 y absurdhyp


>>          line1: [(absurdhyp_1:that ~(pred(y)))
>>               => (---:that Exists([(x_3:obj)
>>                  => (~(pred(x_3)):prop)]))
>>               ]
>>            {move 3}



         define line2 absurdhyp: Mp line1 \
            absurdhyp negexistev

>>          line2: [(absurdhyp_1:that ~(pred(y)))
>>               => (---:that ??)]
>>            {move 3}



         close

      define line3 y: Dneg Negintro line2


>>       line3: [(y_1:obj) => (---:that pred(y_1))]
>>         {move 2}



      close

   define line4 negexistev : Mp (Ug line3, \
      negunivev)

>>    line4: [(negexistev_1:that ~(Exists([(z_2:
>>            obj) => (~(pred(z_2)):prop)]))
>>         ) => (---:that ??)]
>>      {move 1}



   close

define Counterexample negunivev: Dneg (Negintro \
   line4)

>> Counterexample: [(.pred_1:[(x_2:obj) => (---:
>>         prop)]),
>>      (negunivev_1:that ~(Forall(.pred_1)))
>>      => (Dneg(Negintro([(negexistev_5:that
>>         ~(Exists([(z_6:obj) => (~(.pred_1(z_6)):
>>            prop)]))
>>         ) => ((Ug([(y_7:obj) => (Dneg(Negintro([(absurdhyp_8:
>>               that ~(.pred_1(y_7))) => (((y_7
>>               Ei1 absurdhyp_8) Mp negexistev_5):
>>               that ??)]))
>>            :that .pred_1(y_7))])
>>         Mp negunivev_1):that ??)]))
>>      :that Exists([(z_11:obj) => (~(.pred_1(z_11)):
>>         prop)]))
>>      ]
>>   {move 0}


\end{verbatim}





\section{Definite description}

In this section we define the uniqueness quantifier and definite description.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare pred [x => prop] \
   



>> pred: [(x_1:obj) => (---:prop)]
>>   {move 1}



define One pred : Exists [x => Forall [y \
         => (pred y) == y=x] \
      ] \
   



>> One: [(pred_1:[(x_2:obj) => (---:prop)])
>>      => (Exists([(x_3:obj) => (Forall([(y_4:
>>            obj) => ((pred_1(y_4) == (y_4 =
>>            x_3)):prop)])
>>         :prop)])
>>      :prop)]
>>   {move 0}



declare oneev that One pred

>> oneev: that One(pred) {move 1}



postulate The oneev : obj

>> The: [(.pred_1:[(x_2:obj) => (---:prop)]),
>>      (oneev_1:that One(.pred_1)) => (---:obj)]
>>   {move 0}



postulate Theax oneev that pred (The oneev)


>> Theax: [(.pred_1:[(x_2:obj) => (---:prop)]),
>>      (oneev_1:that One(.pred_1)) => (---:that
>>      .pred_1(The(oneev_1)))]
>>   {move 0}


\end{verbatim}

Here we develop the universal quantifier and definite description operator.  Note that the definite description operator and its axiom are for us primitives.



\section{Basic concepts of set theory:  the axioms of extensionality and pairing}

In this section, we start to declare the basic notions and axioms of 1908 Zermelo set theory.  The membership relation is declared.  The axioms declared here are existence of the empty set, weak extensionality (atoms are allowed), and pairing.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



postulate E x y prop

>> E: [(x_1:obj),(y_1:obj) => (---:prop)]
>>   {move 0}



postulate 0 obj

>> 0: obj {move 0}



postulate Empty x that ~ (x E 0)

>> Empty: [(x_1:obj) => (---:that ~((x_1 E 0)))]
>>   {move 0}



define Isset x : (x=0) V Exists [y=>y E x] \
   



>> Isset: [(x_1:obj) => (((x_1 = 0) V Exists([(y_2:
>>         obj) => ((y_2 E x_1):prop)]))
>>      :prop)]
>>   {move 0}



declare u1 obj

>> u1: obj {move 1}



declare v1 obj

>> v1: obj {move 1}



declare nonemptyev that u1 E v1

>> nonemptyev: that (u1 E v1) {move 1}



define Inhabited nonemptyev: Fixform(Isset \
   v1,Add2(v1=0,Ei1 u1 nonemptyev))

>> Inhabited: [(.u1_1:obj),(.v1_1:obj),(nonemptyev_1:
>>      that (.u1_1 E .v1_1)) => ((Isset(.v1_1)
>>      Fixform ((.v1_1 = 0) Add2 (.u1_1 Ei1 nonemptyev_1))):
>>      that Isset(.v1_1))]
>>   {move 0}



declare z obj

>> z: obj {move 1}



declare setev1 that Isset x

>> setev1: that Isset(x) {move 1}



declare setev2 that Isset y

>> setev2: that Isset(y) {move 1}



declare extev [z=>that (z E x) == (z E y)] \
   



>> extev: [(z_1:obj) => (---:that ((z_1 E x)
>>      == (z_1 E y)))]
>>   {move 1}



postulate Ext setev1 setev2 extev that x=y


>> Ext: [(.x_1:obj),(setev1_1:that Isset(.x_1)),
>>      (.y_1:obj),(setev2_1:that Isset(.y_1)),
>>      (extev_1:[(z_2:obj) => (---:that ((z_2
>>         E .x_1) == (z_2 E .y_1)))])
>>      => (---:that (.x_1 = .y_1))]
>>   {move 0}


clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare z obj

>> z: obj {move 1}



declare setev that z E x

>> setev: that (z E x) {move 1}



declare setev2 that z E y

>> setev2: that (z E y) {move 1}



declare extev1 [setev => that z E y] \
   



>> extev1: [(setev_1:that (z E x)) => (---:that
>>      (z E y))]
>>   {move 1}



declare extev2 [setev2 => that z E y] \
   



>> extev2: [(setev2_1:that (z E y)) => (---:
>>      that (z E y))]
>>   {move 1}



postulate Ext1 setev extev1, extev2 that \
   x=y

>> Ext1: [(.z_1:obj),(.x_1:obj),(setev_1:that
>>      (.z_1 E .x_1)),(.y_1:obj),(extev1_1:[(setev_2:
>>         that (.z_1 E .x_1)) => (---:that (.z_1
>>         E .y_1))]),
>>      (extev2_1:[(setev2_3:that (.z_1 E .y_1))
>>         => (---:that (.z_1 E .y_1))])
>>      => (---:that (.x_1 = .y_1))]
>>   {move 0}


\end{verbatim}

Above we have declared the membership relation $x \in y$, the empty set 0 and the axiom that it has no members, defined sets as elements and 0, and stated the weak axiom of extensionality:  sets which have the same extension are equal.

The alternative formulation {\tt Ext1} is better in not involving logic primitives, which would add a little more burden to needed definitions.  I should define one of these in terms of the other.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare z obj

>> z: obj {move 1}



postulate ; x y obj

>> ;: [(x_1:obj),(y_1:obj) => (---:obj)]
>>   {move 0}



postulate Pair x y that Forall [z=>(z E x;y) \
      == (z = x) V z = y] \
   



>> Pair: [(x_1:obj),(y_1:obj) => (---:that Forall([(z_2:
>>         obj) => (((z_2 E (x_1 ; y_1)) == ((z_2
>>         = x_1) V (z_2 = y_1))):prop)]))
>>      ]
>>   {move 0}



define Usc x : x;x

>> Usc: [(x_1:obj) => ((x_1 ; x_1):obj)]
>>   {move 0}



define $ x y : (x;x);(x;y)

>> $: [(x_1:obj),(y_1:obj) => (((x_1 ; x_1)
>>      ; (x_1 ; y_1)):obj)]
>>   {move 0}


\end{verbatim}

Above we present the operation of unordered pairing and the axiom of pairing which determines the extension of the pair.  We write {\tt x ; y} for $\{x,y\}$.  We define
 the singleton operation, borrowing Rosser's notation ${\tt USC}(x)$ for $\{x\}$.

We define the Kuratowski ordered pair, using the notation $x \$ y$ for $(x,y)$.  This is of course a notion unknown to Zermelo, but it is a formal feature of his system even if he did not know about it.

\section{Developments from pairing, including the properties of the ordered pair}

Herein we do some development work with the notion of pair.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare inev that y E x;x

>> inev: that (y E (x ; x)) {move 1}



open

   define line1 : Ui (y, Pair x x)

>>    line1: [(---:that ((y E (x ; x)) == ((y
>>         = x) V (y = x))))]
>>      {move 1}



   define line2 : Iff1 inev line1

>>    line2: [(---:that ((y = x) V (y = x)))]
>>      {move 1}



   define line3 : Oridem line2

>>    line3: [(---:that (y = x))]
>>      {move 1}



   close

define Inusc1 inev : line3

>> Inusc1: [(.y_1:obj),(.x_1:obj),(inev_1:that
>>      (.y_1 E (.x_1 ; .x_1))) => (Oridem((inev_1
>>      Iff1 (.y_1 Ui (.x_1 Pair .x_1)))):that
>>      (.y_1 = .x_1))]
>>   {move 0}


clearcurrent


declare x obj

>> x: obj {move 1}



open

   define line1 : Add1 (x=x,Refleq x)

>>    line1: [(---:that ((x = x) V (x = x)))]
>>      {move 1}



   define line2 : Iff2 (line1,Ui(x,Pair x \
      x))

>>    line2: [(---:that (x E (x ; x)))]
>>      {move 1}



   close

define Inusc2 x : line2

>> Inusc2: [(x_1:obj) => ((((x_1 = x_1) Add1
>>      Refleq(x_1)) Iff2 (x_1 Ui (x_1 Pair x_1))):
>>      that (x_1 E (x_1 ; x_1)))]
>>   {move 0}


clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



open

   define scratch1 : Ui x (Pair x y)

>>    scratch1: [(---:that ((x E (x ; y)) ==
>>         ((x = x) V (x = y))))]
>>      {move 1}



   define scratch2 : Add1 (x=y,Refleq x)


>>    scratch2: [(---:that ((x = x) V (x = y)))]
>>      {move 1}



   define scratch3 :Iff2(scratch2 ,scratch1)


>>    scratch3: [(---:that (x E (x ; y)))]
>>      {move 1}



   close

define Inpair1 x y:scratch3

>> Inpair1: [(x_1:obj),(y_1:obj) => ((((x_1
>>      = y_1) Add1 Refleq(x_1)) Iff2 (x_1 Ui
>>      (x_1 Pair y_1))):that (x_1 E (x_1 ; y_1)))]
>>   {move 0}


clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



open

   define scratch1: Ui y (Pair x y)

>>    scratch1: [(---:that ((y E (x ; y)) ==
>>         ((y = x) V (y = y))))]
>>      {move 1}



   define scratch2: Add2 (y=x,Refleq y)

>>    scratch2: [(---:that ((y = x) V (y = y)))]
>>      {move 1}



   define scratch3 : Iff2 scratch2 scratch1


>>    scratch3: [(---:that (y E (x ; y)))]
>>      {move 1}



   close

define Inpair2 x y:scratch3

>> Inpair2: [(x_1:obj),(y_1:obj) => ((((y_1
>>      = x_1) Add2 Refleq(y_1)) Iff2 (y_1 Ui
>>      (x_1 Pair y_1))):that (y_1 E (x_1 ; y_1)))]
>>   {move 0}


clearcurrent


declare x obj

>> x: obj {move 1}



open

   declare y obj

>>    y: obj {move 2}



   open

      declare inev1 that y E Usc x

>>       inev1: that (y E Usc(x)) {move 3}



      declare inev2 that y=x

>>       inev2: that (y = x) {move 3}



      define dir1 inev1 : Inusc1 inev1

>>       dir1: [(inev1_1:that (y E Usc(x)))
>>            => (---:that (y = x))]
>>         {move 2}



      define line3 inev2: Eqsymm inev2

>>       line3: [(inev2_1:that (y = x)) => (---:
>>            that (x = y))]
>>         {move 2}



      define line4 : Fixform(x E Usc x, Inusc2 \
         x)

>>       line4: [(---:that (x E Usc(x)))]
>>         {move 2}



      declare z1 obj

>>       z1: obj {move 3}



      define dir2 inev2 : Subs (Eqsymm inev2, \
         [z1 =>z1 E Usc x] \
         , line4)

>>       dir2: [(inev2_1:that (y = x)) => (---:
>>            that (y E Usc(x)))]
>>         {move 2}



      define inuscone : Fixform((y E Usc \
         x)==y=x, Dediff dir1, dir2)

>>       inuscone: [(---:that ((y E Usc(x))
>>            == (y = x)))]
>>         {move 2}



      close

   define inuscone2 y:inuscone

>>    inuscone2: [(y_1:obj) => (---:that ((y_1
>>         E Usc(x)) == (y_1 = x)))]
>>      {move 1}



   define one1 : Ug inuscone2

>>    one1: [(---:that Forall([(y_2:obj) =>
>>            (((y_2 E Usc(x)) == (y_2 = x)):prop)]))
>>         ]
>>      {move 1}



   declare w obj

>>    w: obj {move 2}



   declare y2 obj

>>    y2: obj {move 2}



   define one2 : Fixform(One [w=>w E Usc \
         x] \
      ,Ei(x, [w=>Forall[y2 => (y2 E Usc x)==y2=w] \
         ] \
      ,one1))

>>    one2: [(---:that One([(w_4:obj) => ((w_4
>>            E Usc(x)):prop)]))
>>         ]
>>      {move 1}



   define one3 : Theax one2

>>    one3: [(---:that (The(one2) E Usc(x)))]
>>      {move 1}



   define one4 : Inusc1 one3

>>    one4: [(---:that (The(one2) = x))]
>>      {move 1}



   close

define Theeltthm x:one2

>> Theeltthm: [(x_1:obj) => ((One([(w_2:obj)
>>         => ((w_2 E Usc(x_1)):prop)])
>>      Fixform Ei(x_1,[(w_3:obj) => (Forall([(y2_4:
>>            obj) => (((y2_4 E Usc(x_1)) == (y2_4
>>            = w_3)):prop)])
>>         :prop)]
>>      ,Ug([(y_6:obj) => ((((y_6 E Usc(x_1))
>>         == (y_6 = x_1)) Fixform Dediff([(inev1_7:
>>            that (y_6 E Usc(x_1))) => (Inusc1(inev1_7):
>>            that (y_6 = x_1))]
>>         ,[(inev2_8:that (y_6 = x_1)) => (Subs(Eqsymm(inev2_8),
>>            [(z1_9:obj) => ((z1_9 E Usc(x_1)):
>>               prop)]
>>            ,((x_1 E Usc(x_1)) Fixform Inusc2(x_1))):
>>            that (y_6 E Usc(x_1)))]))
>>         :that ((y_6 E Usc(x_1)) == (y_6 = x_1)))]))
>>      ):that One([(w_10:obj) => ((w_10 E Usc(x_1)):
>>         prop)]))
>>      ]
>>   {move 0}



define Theelt x: Fixform(The(Theeltthm x)=x, \
   one4)

>> Theelt: [(x_1:obj) => (((The(Theeltthm(x_1))
>>      = x_1) Fixform Inusc1(Theax((One([(w_13:
>>         obj) => ((w_13 E Usc(x_1)):prop)])
>>      Fixform Ei(x_1,[(w_14:obj) => (Forall([(y2_15:
>>            obj) => (((y2_15 E Usc(x_1)) ==
>>            (y2_15 = w_14)):prop)])
>>         :prop)]
>>      ,Ug([(y_17:obj) => ((((y_17 E Usc(x_1))
>>         == (y_17 = x_1)) Fixform Dediff([(inev1_18:
>>            that (y_17 E Usc(x_1))) => (Inusc1(inev1_18):
>>            that (y_17 = x_1))]
>>         ,[(inev2_19:that (y_17 = x_1)) => (Subs(Eqsymm(inev2_19),
>>            [(z1_20:obj) => ((z1_20 E Usc(x_1)):
>>               prop)]
>>            ,((x_1 E Usc(x_1)) Fixform Inusc2(x_1))):
>>            that (y_17 E Usc(x_1)))]))
>>         :that ((y_17 E Usc(x_1)) == (y_17 =
>>         x_1)))]))
>>      )))):that (The(Theeltthm(x_1)) = x_1))]
>>   {move 0}


\end{verbatim}

We prove that $y \in \{x\}$ iff $y=x$, and that $(\theta y: y \in \{x\})=x$.  This involves careful manipulations of environments and forms of statements to avoid blowup.

We should also prove that if there is only one element in a set, it is the singleton of its element.

Our aim in the next blocks of code is to characterize projections of the pair.  $x$ is the unique object which belongs to all elements of $x;y$.  $y$ is the unique object which belongs to exactly one element of $x;y$.  These theorems allow us to prove that an ordered pair is determined by its projections.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



open

   declare z obj

>>    z: obj {move 2}



   open

      declare inev that z E x$y

>>       inev: that (z E (x $ y)) {move 3}



      open

         define line1 : Ui z (Pair x;x x;y)


>>          line1: [(---:that ((z E ((x ; x)
>>               ; (x ; y))) == ((z = (x ; x))
>>               V (z = (x ; y)))))]
>>            {move 3}



         define line2 : Iff1 inev line1

>>          line2: [(---:that ((z = (x ; x))
>>               V (z = (x ; y))))]
>>            {move 3}



         declare eqev1 that z=x;x

>>          eqev1: that (z = (x ; x)) {move
>>            4}



         declare w obj

>>          w: obj {move 4}



         define dir1 eqev1: Subs1 (Eqsymm \
            eqev1, Inusc2 x)

>>          dir1: [(eqev1_1:that (z = (x ; x)))
>>               => (---:that (x E z))]
>>            {move 3}



         declare eqev2 that z=x;y

>>          eqev2: that (z = (x ; y)) {move
>>            4}



         define dir2 eqev2: Subs1(Eqsymm \
            eqev2, Inpair1 x y)

>>          dir2: [(eqev2_1:that (z = (x ; y)))
>>               => (---:that (x E z))]
>>            {move 3}



         define line3 : Cases line2 dir1, \
            dir2

>>          line3: [(---:that (x E z))]
>>            {move 3}



         close

      define scratch inev: line3

>>       scratch: [(inev_1:that (z E (x $ y)))
>>            => (---:that (x E z))]
>>         {move 2}



      define scratch2 : Ded scratch

>>       scratch2: [(---:that ((z E (x $ y))
>>            -> (x E z)))]
>>         {move 2}



      close

   define scratch3 z: scratch2

>>    scratch3: [(z_1:obj) => (---:that ((z_1
>>         E (x $ y)) -> (x E z_1)))]
>>      {move 1}



   close

define Firstprojthm1 x y:Ug scratch3

>> Firstprojthm1: [(x_1:obj),(y_1:obj) => (Ug([(z_3:
>>         obj) => (Ded([(inev_4:that (z_3 E (x_1
>>            $ y_1))) => (Cases((inev_4 Iff1
>>            (z_3 Ui ((x_1 ; x_1) Pair (x_1 ;
>>            y_1)))),[(eqev1_6:that (z_3 = (x_1
>>               ; x_1))) => ((Eqsymm(eqev1_6)
>>               Subs1 Inusc2(x_1)):that (x_1
>>               E z_3))]
>>            ,[(eqev2_8:that (z_3 = (x_1 ; y_1)))
>>               => ((Eqsymm(eqev2_8) Subs1 (x_1
>>               Inpair1 y_1)):that (x_1 E z_3))])
>>            :that (x_1 E z_3))])
>>         :that ((z_3 E (x_1 $ y_1)) -> (x_1
>>         E z_3)))])
>>      :that Forall([(z_10:obj) => (((z_10 E
>>         (x_1 $ y_1)) -> (x_1 E z_10)):prop)]))
>>      ]
>>   {move 0}


clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



open

   declare w obj

>>    w: obj {move 2}



   open

      declare z obj

>>       z: obj {move 3}



      declare firstev that Forall [z=>(z \
            E x$y)->w E z] \
         



>>       firstev: that Forall([(z_1:obj) =>
>>            (((z_1 E (x $ y)) -> (w E z_1)):
>>            prop)])
>>         {move 3}



      define line1 firstev : Ui(Usc x,firstev)


>>       line1: [(firstev_1:that Forall([(z_2:
>>               obj) => (((z_2 E (x $ y)) ->
>>               (w E z_2)):prop)]))
>>            => (---:that ((Usc(x) E (x $ y))
>>            -> (w E Usc(x))))]
>>         {move 2}



      define line2 firstev: Fixform((Usc \
         x) E x $ y,Inpair1(x;x,x;y))

>>       line2: [(firstev_1:that Forall([(z_2:
>>               obj) => (((z_2 E (x $ y)) ->
>>               (w E z_2)):prop)]))
>>            => (---:that (Usc(x) E (x $ y)))]
>>         {move 2}



      define line3 firstev: Mp (line2 firstev, \
         line1 firstev)

>>       line3: [(firstev_1:that Forall([(z_2:
>>               obj) => (((z_2 E (x $ y)) ->
>>               (w E z_2)):prop)]))
>>            => (---:that (w E Usc(x)))]
>>         {move 2}



      define line4 firstev : Inusc1 line3 \
         firstev

>>       line4: [(firstev_1:that Forall([(z_2:
>>               obj) => (((z_2 E (x $ y)) ->
>>               (w E z_2)):prop)]))
>>            => (---:that (w = x))]
>>         {move 2}



      close

   define line5 w: Ded line4

>>    line5: [(w_1:obj) => (---:that (Forall([(z_6:
>>            obj) => (((z_6 E (x $ y)) -> (w_1
>>            E z_6)):prop)])
>>         -> (w_1 = x)))]
>>      {move 1}



   close

define Firstprojthm2 x y: Ug line5

>> Firstprojthm2: [(x_1:obj),(y_1:obj) => (Ug([(w_4:
>>         obj) => (Ded([(firstev_6:that Forall([(z_7:
>>               obj) => (((z_7 E (x_1 $ y_1))
>>               -> (w_4 E z_7)):prop)]))
>>            => (Inusc1((((Usc(x_1) E (x_1 $
>>            y_1)) Fixform ((x_1 ; x_1) Inpair1
>>            (x_1 ; y_1))) Mp (Usc(x_1) Ui firstev_6))):
>>            that (w_4 = x_1))])
>>         :that (Forall([(z_9:obj) => (((z_9
>>            E (x_1 $ y_1)) -> (w_4 E z_9)):prop)])
>>         -> (w_4 = x_1)))])
>>      :that Forall([(w_10:obj) => ((Forall([(z_11:
>>            obj) => (((z_11 E (x_1 $ y_1)) ->
>>            (w_10 E z_11)):prop)])
>>         -> (w_10 = x_1)):prop)]))
>>      ]
>>   {move 0}


\end{verbatim}

At this point we have proved that $x$ belongs to all (both) elements of $(x,y)$, and that any $w$ which belongs to both elements of $(x,y)$ is actually equal to $x$.

The corresponding result for $y$ will be a bit harder.  We first want to prove $(\exists! z: z \in (x,y) \wedge y \in z)$.
Then we want to prove for any $w$ that if $(\exists! z: z \in (x,y) \wedge w \in z)$, then $w=y$.

Expanding things a bit, for the first part we want to prove $(\exists z:(\forall w: w \in (x,y) \wedge y \in w) \leftrightarrow w=z)$.

To be exact, this $w$ is $\{x,y\}$, so we want to prove $(\forall w: (w \in (x,y) \wedge y \in w) \leftrightarrow w = \{x,y\})$.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



open

   declare w obj

>>    w: obj {move 2}



   open

      declare yinitinpairev that (w E x$y) \
         & y E w

>>       yinitinpairev: that ((w E (x $ y))
>>         & (y E w)) {move 3}



      open

         define line1 : Simp1 yinitinpairev


>>          line1: [(---:that (w E (x $ y)))]
>>            {move 3}



         define line2 : Ui(w,Pair(x;x,x;y))


>>          line2: [(---:that ((w E ((x ; x)
>>               ; (x ; y))) == ((w = (x ; x))
>>               V (w = (x ; y)))))]
>>            {move 3}



         open

            declare casehyp1 that w=x;x

>>             casehyp1: that (w = (x ; x))
>>               {move 5}



            define line3 casehyp1 : Subs1 \
               (casehyp1, Simp2 \
               yinitinpairev)

>>             line3: [(casehyp1_1:that (w =
>>                  (x ; x))) => (---:that (y
>>                  E (x ; x)))]
>>               {move 4}



            define line4 casehyp1: Inusc1 \
               line3 casehyp1

>>             line4: [(casehyp1_1:that (w =
>>                  (x ; x))) => (---:that (y
>>                  = x))]
>>               {move 4}



            declare q obj

>>             q: obj {move 5}



            define dir1 casehyp1 : Subs(Eqsymm \
               line4 casehyp1, [q=>w=x;q] \
               ,casehyp1)

>>             dir1: [(casehyp1_1:that (w =
>>                  (x ; x))) => (---:that (w
>>                  = (x ; y)))]
>>               {move 4}



            declare casehyp2 that w=x;y

>>             casehyp2: that (w = (x ; y))
>>               {move 5}



            define dir2 casehyp2:casehyp2


>>             dir2: [(casehyp2_1:that (w =
>>                  (x ; y))) => (---:that (w
>>                  = (x ; y)))]
>>               {move 4}



            close

         define line5 : Iff1 line1 line2


>>          line5: [(---:that ((w = (x ; x))
>>               V (w = (x ; y))))]
>>            {move 3}



         define line6 : Cases line5 dir1, \
            dir2

>>          line6: [(---:that (w = (x ; y)))]
>>            {move 3}



         close

      define Line6 yinitinpairev: line6

>>       Line6: [(yinitinpairev_1:that ((w E
>>            (x $ y)) & (y E w))) => (---:that
>>            (w = (x ; y)))]
>>         {move 2}



      declare isunorderedxy that w=x;y

>>       isunorderedxy: that (w = (x ; y)) {move
>>         3}



      declare q obj

>>       q: obj {move 3}



      define Line7 isunorderedxy: Subs(Eqsymm \
         isunorderedxy,[q=>(q E \
            x$y)&y E q] \
         , Conj(Inpair2(x;x,x;y),Inpair2 x \
         y))

>>       Line7: [(isunorderedxy_1:that (w =
>>            (x ; y))) => (---:that ((w E (x
>>            $ y)) & (y E w)))]
>>         {move 2}



      close

   define line8 w: Dediff Line6, Line7

>>    line8: [(w_1:obj) => (---:that (((w_1
>>         E (x $ y)) & (y E w_1)) == (w_1 = (x
>>         ; y))))]
>>      {move 1}



   define line9: Ug line8

>>    line9: [(---:that Forall([(w_2:obj) =>
>>            ((((w_2 E (x $ y)) & (y E w_2))
>>            == (w_2 = (x ; y))):prop)]))
>>         ]
>>      {move 1}



   declare q obj

>>    q: obj {move 2}



   define line10 : Fixform(One [q=>(q E x$y)&y \
         E q] \
      ,Ei1 (x;y,line9))

>>    line10: [(---:that One([(q_4:obj) => (((q_4
>>            E (x $ y)) & (y E q_4)):prop)]))
>>         ]
>>      {move 1}



   close

define Secondprojthm1 x y:line10

>> Secondprojthm1: [(x_1:obj),(y_1:obj) => ((One([(q_2:
>>         obj) => (((q_2 E (x_1 $ y_1)) & (y_1
>>         E q_2)):prop)])
>>      Fixform ((x_1 ; y_1) Ei1 Ug([(w_6:obj)
>>         => (Dediff([(yinitinpairev_7:that ((w_6
>>            E (x_1 $ y_1)) & (y_1 E w_6))) =>
>>            (Cases((Simp1(yinitinpairev_7) Iff1
>>            (w_6 Ui ((x_1 ; x_1) Pair (x_1 ;
>>            y_1)))),[(casehyp1_9:that (w_6 =
>>               (x_1 ; x_1))) => (Subs(Eqsymm(Inusc1((casehyp1_9
>>               Subs1 Simp2(yinitinpairev_7)))),
>>               [(q_11:obj) => ((w_6 = (x_1 ;
>>                  q_11)):prop)]
>>               ,casehyp1_9):that (w_6 = (x_1
>>               ; y_1)))]
>>            ,[(casehyp2_12:that (w_6 = (x_1
>>               ; y_1))) => (casehyp2_12:that
>>               (w_6 = (x_1 ; y_1)))])
>>            :that (w_6 = (x_1 ; y_1)))]
>>         ,[(isunorderedxy_13:that (w_6 = (x_1
>>            ; y_1))) => (Subs(Eqsymm(isunorderedxy_13),
>>            [(q_14:obj) => (((q_14 E (x_1 $
>>               y_1)) & (y_1 E q_14)):prop)]
>>            ,(((x_1 ; x_1) Inpair2 (x_1 ; y_1))
>>            Conj (x_1 Inpair2 y_1))):that ((w_6
>>            E (x_1 $ y_1)) & (y_1 E w_6)))])
>>         :that (((w_6 E (x_1 $ y_1)) & (y_1
>>         E w_6)) == (w_6 = (x_1 ; y_1))))]))
>>      ):that One([(q_15:obj) => (((q_15 E (x_1
>>         $ y_1)) & (y_1 E q_15)):prop)]))
>>      ]
>>   {move 0}


\end{verbatim}

We report that our text plan given just before the block of Lestrade code worked exactly to plan the proof.  We still have the second part, to show that for any $w$ that if $(\exists! z: z \in (x,y) \wedge w \in z)$, then $w=y$.

We used environment nesting carefully to avoid declaring anything in move 0 in this block other than {\tt Secondprojthm1}.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare w obj

>> w: obj {move 1}



declare z obj

>> z: obj {move 1}



declare secondprojev that One[z => (z E x$y) \
      & w E z] \
   



>> secondprojev: that One([(z_1:obj) => (((z_1
>>      E (x $ y)) & (w E z_1)):prop)])
>>   {move 1}



open

   declare u obj

>>    u: obj {move 2}



   declare wev that Witnesses secondprojev \
      u

>>    wev: that (secondprojev Witnesses u) {move
>>      2}



   open

      define fact1 : Ui (u, wev)

>>       fact1: [(---:that (((u E (x $ y)) &
>>            (w E u)) == (u = u)))]
>>         {move 2}



      define fact2: Iff2 (Refleq u, fact1)


>>       fact2: [(---:that ((u E (x $ y)) &
>>            (w E u)))]
>>         {move 2}



      define fact3: Simp1 fact2

>>       fact3: [(---:that (u E (x $ y)))]
>>         {move 2}



      define fact4: Simp2 fact2

>>       fact4: [(---:that (w E u))]
>>         {move 2}



      define fact5: Ui u (x;x) Pair (x;y)


>>       fact5: [(---:that ((u E ((x ; x) ;
>>            (x ; y))) == ((u = (x ; x)) V (u
>>            = (x ; y)))))]
>>         {move 2}



      define fact6: Iff1 fact3 fact5

>>       fact6: [(---:that ((u = (x ; x)) V
>>            (u = (x ; y))))]
>>         {move 2}



      open

         declare casehyp1 that u=x;x

>>          casehyp1: that (u = (x ; x)) {move
>>            4}



         declare casehyp2 that u=x;y

>>          casehyp2: that (u = (x ; y)) {move
>>            4}



         define line1 casehyp1 : Inusc1(Subs1 \
            casehyp1 fact4)

>>          line1: [(casehyp1_1:that (u = (x
>>               ; x))) => (---:that (w = x))]
>>            {move 3}



         define fact7 : Ui (x;y,wev)

>>          fact7: [(---:that ((((x ; y) E (x
>>               $ y)) & (w E (x ; y))) == ((x
>>               ; y) = u)))]
>>            {move 3}



         define line2 casehyp1 : Subs1 (line1 \
            casehyp1, fact7)

>>          line2: [(casehyp1_1:that (u = (x
>>               ; x))) => (---:that ((((x ; y)
>>               E (x $ y)) & (x E (x ; y))) ==
>>               ((x ; y) = u)))]
>>            {move 3}



         define line3 casehyp1 : Subs1(casehyp1, \
            line2 casehyp1)

>>          line3: [(casehyp1_1:that (u = (x
>>               ; x))) => (---:that ((((x ; y)
>>               E (x $ y)) & (x E (x ; y))) ==
>>               ((x ; y) = (x ; x))))]
>>            {move 3}



         define line4 casehyp1: Iff1(Conj(Inpair2(x;x, \
            x;y), Inpair1(x,y)),line3 casehyp1)


>>          line4: [(casehyp1_1:that (u = (x
>>               ; x))) => (---:that ((x ; y)
>>               = (x ; x)))]
>>            {move 3}



         define line5 casehyp1: Inusc1(Subs1(line4 \
            casehyp1, Inpair2 x y))

>>          line5: [(casehyp1_1:that (u = (x
>>               ; x))) => (---:that (y = x))]
>>            {move 3}



         define line6 casehyp1: Subs1(Eqsymm \
            line5 casehyp1,line1 casehyp1)


>>          line6: [(casehyp1_1:that (u = (x
>>               ; x))) => (---:that (w = y))]
>>            {move 3}



         define line7 casehyp2 : (Subs1 casehyp2 \
            fact4)

>>          line7: [(casehyp2_1:that (u = (x
>>               ; y))) => (---:that (w E (x ;
>>               y)))]
>>            {move 3}



         define line8 casehyp2: Iff1(line7 \
            casehyp2, Ui w x Pair \
            y)

>>          line8: [(casehyp2_1:that (u = (x
>>               ; y))) => (---:that ((w = x)
>>               V (w = y)))]
>>            {move 3}



         open

            declare case1 that w=x

>>             case1: that (w = x) {move 5}



            declare case2 that w=y

>>             case2: that (w = y) {move 5}



            define dir2 case2: case2

>>             dir2: [(case2_1:that (w = y))
>>                  => (---:that (w = y))]
>>               {move 4}



            define fact8: Ui(x;x,wev)

>>             fact8: [(---:that ((((x ; x)
>>                  E (x $ y)) & (w E (x ; x)))
>>                  == ((x ; x) = u)))]
>>               {move 4}



            define line9 case1: Subs1(casehyp2, \
               Subs1(case1,fact8))

>>             line9: [(case1_1:that (w = x))
>>                  => (---:that ((((x ; x) E
>>                  (x $ y)) & (x E (x ; x)))
>>                  == ((x ; x) = (x ; y))))]
>>               {move 4}



            define line10 case1: Iff1(Conj(Inpair1(x;x, \
               x;y), Inusc2 x),line9 case1)


>>             line10: [(case1_1:that (w = x))
>>                  => (---:that ((x ; x) = (x
>>                  ; y)))]
>>               {move 4}



            define line11 case1: Inusc1(Subs1(Eqsymm(line10 \
               case1), Inpair2 x y))

>>             line11: [(case1_1:that (w = x))
>>                  => (---:that (y = x))]
>>               {move 4}



            define dir1 case1: Subs1(Eqsymm \
               line11 case1,case1)

>>             dir1: [(case1_1:that (w = x))
>>                  => (---:that (w = y))]
>>               {move 4}



            close

         define line13 casehyp2:Cases(line8 \
            casehyp2, dir1,dir2)

>>          line13: [(casehyp2_1:that (u = (x
>>               ; y))) => (---:that (w = y))]
>>            {move 3}



         close

      define line14: Cases(fact6,line6,line13)


>>       line14: [(---:that (w = y))]
>>         {move 2}



      close

   define line15 u wev: line14

>>    line15: [(u_1:obj),(wev_1:that (secondprojev
>>         Witnesses u_1)) => (---:that (w = y))]
>>      {move 1}



   define line16: Eg secondprojev line15


>>    line16: [(---:that (w = y))]
>>      {move 1}



   close

define Secondprojthm2 x y w secondprojev: \
   line16

>> Secondprojthm2: [(x_1:obj),(y_1:obj),(w_1:
>>      obj),(secondprojev_1:that One([(z_2:obj)
>>         => (((z_2 E (x_1 $ y_1)) & (w_1 E z_2)):
>>         prop)]))
>>      => ((secondprojev_1 Eg [(u_5:obj),(wev_5:
>>         that (secondprojev_1 Witnesses u_5))
>>         => (Cases((Simp1((Refleq(u_5) Iff2
>>         (u_5 Ui wev_5))) Iff1 (u_5 Ui ((x_1
>>         ; x_1) Pair (x_1 ; y_1)))),[(casehyp1_10:
>>            that (u_5 = (x_1 ; x_1))) => ((Eqsymm(Inusc1((((((x_1
>>            ; x_1) Inpair2 (x_1 ; y_1)) Conj
>>            (x_1 Inpair1 y_1)) Iff1 (casehyp1_10
>>            Subs1 (Inusc1((casehyp1_10 Subs1
>>            Simp2((Refleq(u_5) Iff2 (u_5 Ui
>>            wev_5))))) Subs1 ((x_1 ; y_1) Ui
>>            wev_5)))) Subs1 (x_1 Inpair2 y_1))))
>>            Subs1 Inusc1((casehyp1_10 Subs1
>>            Simp2((Refleq(u_5) Iff2 (u_5 Ui
>>            wev_5)))))):that (w_1 = y_1))]
>>         ,[(casehyp2_20:that (u_5 = (x_1 ; y_1)))
>>            => (Cases(((casehyp2_20 Subs1 Simp2((Refleq(u_5)
>>            Iff2 (u_5 Ui wev_5)))) Iff1 (w_1
>>            Ui (x_1 Pair y_1))),[(case1_24:that
>>               (w_1 = x_1)) => ((Eqsymm(Inusc1((Eqsymm(((((x_1
>>               ; x_1) Inpair1 (x_1 ; y_1)) Conj
>>               Inusc2(x_1)) Iff1 (casehyp2_20
>>               Subs1 (case1_24 Subs1 ((x_1 ;
>>               x_1) Ui wev_5))))) Subs1 (x_1
>>               Inpair2 y_1)))) Subs1 case1_24):
>>               that (w_1 = y_1))]
>>            ,[(case2_30:that (w_1 = y_1)) =>
>>               (case2_30:that (w_1 = y_1))])
>>            :that (w_1 = y_1))])
>>         :that (w_1 = y_1))])
>>      :that (w_1 = y_1))]
>>   {move 0}


\end{verbatim}

This completes the proof of the characterizations of first and second projections.  Now we prove that pairs are characterized exactly by their projections.  It is worth noting that
the size of the Lestrade proof is more accurately determined if one ignores Lestrade's responses in the dialogue and considers only the input lines.  Another alternative would be to consider the size of the Lestrade terms saved at move 0.  We are currently generating this text with a setting in the prover which suppresses display of proof terms
(and more generally of the definitions of defined terms) except at move 0.  At move 0, displayed proof terms/definitions can be quite large because all definitions at higher indexed moves are expanded out.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare z obj

>> z: obj {move 1}



declare w obj

>> w: obj {move 1}



declare paireqev that (x$y) = z$w

>> paireqev: that ((x $ y) = (z $ w)) {move
>>   1}



open

   define line1: Firstprojthm1 x y

>>    line1: [(---:that Forall([(z_1:obj) =>
>>            (((z_1 E (x $ y)) -> (x E z_1)):
>>            prop)]))
>>         ]
>>      {move 1}



   define line2: Subs1 paireqev line1

>>    line2: [(---:that Forall([(z_3:obj) =>
>>            (((z_3 E (z $ w)) -> (x E z_3)):
>>            prop)]))
>>         ]
>>      {move 1}



   define line3: Firstprojthm2 z w

>>    line3: [(---:that Forall([(w_1:obj) =>
>>            ((Forall([(z_2:obj) => (((z_2 E
>>               (z $ w)) -> (w_1 E z_2)):prop)])
>>            -> (w_1 = z)):prop)]))
>>         ]
>>      {move 1}



   define line4 : Ui x line3

>>    line4: [(---:that (Forall([(z_3:obj) =>
>>            (((z_3 E (z $ w)) -> (x E z_3)):
>>            prop)])
>>         -> (x = z)))]
>>      {move 1}



   define line5: Mp line2 line4

>>    line5: [(---:that (x = z))]
>>      {move 1}



   define line6 : Secondprojthm1 x y

>>    line6: [(---:that One([(q_1:obj) => (((q_1
>>            E (x $ y)) & (y E q_1)):prop)]))
>>         ]
>>      {move 1}



   define line7: Subs1 paireqev line6

>>    line7: [(---:that One([(q_3:obj) => (((q_3
>>            E (z $ w)) & (y E q_3)):prop)]))
>>         ]
>>      {move 1}



   define line8: Secondprojthm2 z w y line7


>>    line8: [(---:that (y = w))]
>>      {move 1}



   close

define Pairseq paireqev : Conj(line5,line8)


>> Pairseq: [(.x_1:obj),(.y_1:obj),(.z_1:obj),
>>      (.w_1:obj),(paireqev_1:that ((.x_1 $ .y_1)
>>      = (.z_1 $ .w_1))) => ((((paireqev_1 Subs1
>>      (.x_1 Firstprojthm1 .y_1)) Mp (.x_1 Ui
>>      (.z_1 Firstprojthm2 .w_1))) Conj Secondprojthm2(.z_1,
>>      .w_1,.y_1,(paireqev_1 Subs1 (.x_1 Secondprojthm1
>>      .y_1)))):that ((.x_1 = .z_1) & (.y_1 =
>>      .w_1)))]
>>   {move 0}


\end{verbatim}

The details of the implementation of the ordered pair take up quite a lot of space but it is an important feature of the system.

It is very interesting to observe that a definition of the pair local to the collection of relations from a given set to a given other set appears to be implicit in Zermelo's definition of correspondences;  I'll be explicit about this in constructions to appear below in this document, when I add them.

\section{The axioms of power set and union}

In this section, we introduce the axioms of power set and union, which allow construction of more specific sets.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare z obj

>> z: obj {move 1}



define <<= x y : Forall [z=>(zE x) -> zE \
      y] \
   & (Isset x) & Isset y

>> <<=: [(x_1:obj),(y_1:obj) => ((Forall([(z_2:
>>         obj) => (((z_2 E x_1) -> (z_2 E y_1)):
>>         prop)])
>>      & (Isset(x_1) & Isset(y_1))):prop)]
>>   {move 0}



declare subsev1 that x <<= y

>> subsev1: that (x <<= y) {move 1}



declare subsev2 that y <<= z

>> subsev2: that (y <<= z) {move 1}



open

   declare u obj

>>    u: obj {move 2}



   open

      declare uinev that u E x

>>       uinev: that (u E x) {move 3}



      define line1 uinev: Mp uinev, Ui u \
         Simp1 subsev1

>>       line1: [(uinev_1:that (u E x)) => (---:
>>            that (u E y))]
>>         {move 2}



      define line2 uinev: Mp(line1 uinev, \
         Ui u Simp1 subsev2)

>>       line2: [(uinev_1:that (u E x)) => (---:
>>            that (u E z))]
>>         {move 2}



      close

   define linea3 u: Ded line2

>>    linea3: [(u_1:obj) => (---:that ((u_1
>>         E x) -> (u_1 E z)))]
>>      {move 1}



   close

define Transsub subsev1 subsev2:Fixform(x \
   <<= z,(Ug linea3) Conj (Simp1 Simp2 subsev1) \
   Conj (Simp2 Simp2 subsev2))

>> Transsub: [(.x_1:obj),(.y_1:obj),(subsev1_1:
>>      that (.x_1 <<= .y_1)),(.z_1:obj),(subsev2_1:
>>      that (.y_1 <<= .z_1)) => (((.x_1 <<= .z_1)
>>      Fixform (Ug([(u_4:obj) => (Ded([(uinev_5:
>>            that (u_4 E .x_1)) => (((uinev_5
>>            Mp (u_4 Ui Simp1(subsev1_1))) Mp
>>            (u_4 Ui Simp1(subsev2_1))):that
>>            (u_4 E .z_1))])
>>         :that ((u_4 E .x_1) -> (u_4 E .z_1)))])
>>      Conj (Simp1(Simp2(subsev1_1)) Conj Simp2(Simp2(subsev2_1))))):
>>      that (.x_1 <<= .z_1))]
>>   {move 0}



declare issetx that Isset x

>> issetx: that Isset(x) {move 1}



open

   declare u obj

>>    u: obj {move 2}



   open

      declare uinev that u E x

>>       uinev: that (u E x) {move 3}



      define line1 uinev: uinev

>>       line1: [(uinev_1:that (u E x)) => (---:
>>            that (u E x))]
>>         {move 2}



      close

   define linea2 u: Ded line1

>>    linea2: [(u_1:obj) => (---:that ((u_1
>>         E x) -> (u_1 E x)))]
>>      {move 1}



   close

define Reflsubset issetx: Fixform(x<<= x, \
   (Ug linea2) Conj issetx Conj issetx)

>> Reflsubset: [(.x_1:obj),(issetx_1:that Isset(.x_1))
>>      => (((.x_1 <<= .x_1) Fixform (Ug([(u_4:
>>         obj) => (Ded([(uinev_5:that (u_4 E
>>            .x_1)) => (uinev_5:that (u_4 E .x_1))])
>>         :that ((u_4 E .x_1) -> (u_4 E .x_1)))])
>>      Conj (issetx_1 Conj issetx_1))):that (.x_1
>>      <<= .x_1))]
>>   {move 0}



declare inev that x E y

>> inev: that (x E y) {move 1}



declare subev that y <<= z

>> subev: that (y <<= z) {move 1}



define Mpsubs inev subev: Mp(inev,Ui x Simp1 \
   subev)

>> Mpsubs: [(.x_1:obj),(.y_1:obj),(inev_1:that
>>      (.x_1 E .y_1)),(.z_1:obj),(subev_1:that
>>      (.y_1 <<= .z_1)) => ((inev_1 Mp (.x_1
>>      Ui Simp1(subev_1))):that (.x_1 E .z_1))]
>>   {move 0}



declare sev1 that x <<= y

>> sev1: that (x <<= y) {move 1}



declare sev2 that y <<= x

>> sev2: that (y <<= x) {move 1}



open

   declare u obj

>>    u: obj {move 2}



   open

      declare ineva1 that u E x

>>       ineva1: that (u E x) {move 3}



      declare ineva2 that u E y

>>       ineva2: that (u E y) {move 3}



      define dir1 ineva1 : Mpsubs ineva1 \
         sev1

>>       dir1: [(ineva1_1:that (u E x)) => (---:
>>            that (u E y))]
>>         {move 2}



      define dir2 ineva2 : Mpsubs ineva2 \
         sev2

>>       dir2: [(ineva2_1:that (u E y)) => (---:
>>            that (u E x))]
>>         {move 2}



      close

   define bothways u: Dediff dir1, dir2

>>    bothways: [(u_1:obj) => (---:that ((u_1
>>         E x) == (u_1 E y)))]
>>      {move 1}



   close

define Antisymsub sev1 sev2 : Ext(Simp1(Simp2 \
   sev1),Simp2(Simp2 sev1),bothways)

>> Antisymsub: [(.x_1:obj),(.y_1:obj),(sev1_1:
>>      that (.x_1 <<= .y_1)),(sev2_1:that (.y_1
>>      <<= .x_1)) => (Ext(Simp1(Simp2(sev1_1)),
>>      Simp2(Simp2(sev1_1)),[(u_4:obj) => (Dediff([(ineva1_5:
>>            that (u_4 E .x_1)) => ((ineva1_5
>>            Mpsubs sev1_1):that (u_4 E .y_1))]
>>         ,[(ineva2_6:that (u_4 E .y_1)) => ((ineva2_6
>>            Mpsubs sev2_1):that (u_4 E .x_1))])
>>         :that ((u_4 E .x_1) == (u_4 E .y_1)))])
>>      :that (.x_1 = .y_1))]
>>   {move 0}



open

   declare X obj

>>    X: obj {move 2}



   open

      declare Xsetev that Isset X

>>       Xsetev: that Isset(X) {move 3}



      open

         declare u obj

>>          u: obj {move 4}



         open

            declare uinxev that u E X

>>             uinxev: that (u E X) {move 5}



            define line1 uinxev : uinxev


>>             line1: [(uinxev_1:that (u E X))
>>                  => (---:that (u E X))]
>>               {move 4}



            close

         define line2 u : Ded line1

>>          line2: [(u_1:obj) => (---:that ((u_1
>>               E X) -> (u_1 E X)))]
>>            {move 3}



         close

      define line3 : Ug line2

>>       line3: [(---:that Forall([(u_3:obj)
>>               => (((u_3 E X) -> (u_3 E X)):
>>               prop)]))
>>            ]
>>         {move 2}



      define line4 Xsetev : Fixform(X <<= \
         X,line3 Conj Xsetev Conj Xsetev)

>>       line4: [(Xsetev_1:that Isset(X)) =>
>>            (---:that (X <<= X))]
>>         {move 2}



      close

   define line5 X: Ded line4

>>    line5: [(X_1:obj) => (---:that (Isset(X_1)
>>         -> (X_1 <<= X_1)))]
>>      {move 1}



   close

define Subsetrefl : Ug line5

>> Subsetrefl: [(Ug([(X_1:obj) => (Ded([(Xsetev_2:
>>            that Isset(X_1)) => (((X_1 <<= X_1)
>>            Fixform (Ug([(u_5:obj) => (Ded([(uinxev_6:
>>                  that (u_5 E X_1)) => (uinxev_6:
>>                  that (u_5 E X_1))])
>>               :that ((u_5 E X_1) -> (u_5 E
>>               X_1)))])
>>            Conj (Xsetev_2 Conj Xsetev_2))):
>>            that (X_1 <<= X_1))])
>>         :that (Isset(X_1) -> (X_1 <<= X_1)))])
>>      :that Forall([(X_7:obj) => ((Isset(X_7)
>>         -> (X_7 <<= X_7)):prop)]))
>>      ]
>>   {move 0}



define Zeroisset : Fixform(Isset 0,Add1(Exists[x=>x \
      E 0] \
   ,Refleq 0))

>> Zeroisset: [((Isset(0) Fixform (Exists([(x_1:
>>         obj) => ((x_1 E 0):prop)])
>>      Add1 Refleq(0))):that Isset(0))]
>>   {move 0}



declare sethyp that Isset x

>> sethyp: that Isset(x) {move 1}



open

   declare W obj

>>    W: obj {move 2}



   open

      declare absurdhyp that W E 0

>>       absurdhyp: that (W E 0) {move 3}



      define line1 absurdhyp: Giveup(W E \
         x, Mp absurdhyp Empty W)

>>       line1: [(absurdhyp_1:that (W E 0))
>>            => (---:that (W E x))]
>>         {move 2}



      close

   define lineb2 W: Ded line1

>>    lineb2: [(W_1:obj) => (---:that ((W_1
>>         E 0) -> (W_1 E x)))]
>>      {move 1}



   close

define Zeroissubset sethyp: Fixform(0 <<= \
   x,Conj(Ug lineb2,Conj(Zeroisset,sethyp))) \
   



>> Zeroissubset: [(.x_1:obj),(sethyp_1:that
>>      Isset(.x_1)) => (((0 <<= .x_1) Fixform
>>      (Ug([(W_4:obj) => (Ded([(absurdhyp_5:that
>>            (W_4 E 0)) => (((W_4 E .x_1) Giveup
>>            (absurdhyp_5 Mp Empty(W_4))):that
>>            (W_4 E .x_1))])
>>         :that ((W_4 E 0) -> (W_4 E .x_1)))])
>>      Conj (Zeroisset Conj sethyp_1))):that
>>      (0 <<= .x_1))]
>>   {move 0}



declare firstev that Isset x

>> firstev: that Isset(x) {move 1}



declare secondev that Isset y

>> secondev: that Isset(y) {move 1}



declare thirdev that ~(x <<= y)

>> thirdev: that ~((x <<= y)) {move 1}



open

   define linec1 : Counterexample(Notconj(thirdev, \
      Conj firstev secondev))

>>    linec1: [(---:that Exists([(z_3:obj) =>
>>            (~(((z_3 E x) -> (z_3 E y))):prop)]))
>>         ]
>>      {move 1}



   open

      declare z1 obj

>>       z1: obj {move 3}



      declare u1 obj

>>       u1: obj {move 3}



      declare evu1 that ~((u1 E x) -> u1 \
         E y)

>>       evu1: that ~(((u1 E x) -> (u1 E y)))
>>         {move 3}



      define linec2 u1 evu1 : Ei1 u1, Conj(Notimp2 \
         evu1,Notimp1 evu1)

>>       linec2: [(u1_1:obj),(evu1_1:that ~(((u1_1
>>            E x) -> (u1_1 E y)))) => (---:that
>>            Exists([(x_3:obj) => (((x_3 E x)
>>               & ~((x_3 E y))):prop)]))
>>            ]
>>         {move 2}



      close

   define Subsetcounter1 : Eg linec1,linec2


>>    Subsetcounter1: [(---:that Exists([(x_4:
>>            obj) => (((x_4 E x) & ~((x_4 E y))):
>>            prop)]))
>>         ]
>>      {move 1}



   close

define Subsetcounter firstev secondev thirdev: \
   Subsetcounter1

>> Subsetcounter: [(.x_1:obj),(firstev_1:that
>>      Isset(.x_1)),(.y_1:obj),(secondev_1:that
>>      Isset(.y_1)),(thirdev_1:that ~((.x_1 <<=
>>      .y_1))) => ((Counterexample((thirdev_1
>>      Notconj (firstev_1 Conj secondev_1)))
>>      Eg [(u1_6:obj),(evu1_6:that ~(((u1_6 E
>>         .x_1) -> (u1_6 E .y_1)))) => ((u1_6
>>         Ei1 (Notimp2(evu1_6) Conj Notimp1(evu1_6))):
>>         that Exists([(x_8:obj) => (((x_8 E
>>            .x_1) & ~((x_8 E .y_1))):prop)]))
>>         ])
>>      :that Exists([(x_9:obj) => (((x_9 E .x_1)
>>         & ~((x_9 E .y_1))):prop)]))
>>      ]
>>   {move 0}



postulate Sc x obj

>> Sc: [(x_1:obj) => (---:obj)]
>>   {move 0}



postulate Scthm x : that Forall [z=>(z E \
      Sc x) == z <<= x] \
   



>> Scthm: [(x_1:obj) => (---:that Forall([(z_2:
>>         obj) => (((z_2 E Sc(x_1)) == (z_2 <<=
>>         x_1)):prop)]))
>>      ]
>>   {move 0}



open

   declare X obj

>>    X: obj {move 2}



   open

      declare Xisset that Isset X

>>       Xisset: that Isset(X) {move 3}



      define line1 : Ui X Subsetrefl

>>       line1: [(---:that (Isset(X) -> (X <<=
>>            X)))]
>>         {move 2}



      define line2 Xisset: Xisset Mp line1


>>       line2: [(Xisset_1:that Isset(X)) =>
>>            (---:that (X <<= X))]
>>         {move 2}



      define line3 : Scthm X

>>       line3: [(---:that Forall([(z_1:obj)
>>               => (((z_1 E Sc(X)) == (z_1 <<=
>>               X)):prop)]))
>>            ]
>>         {move 2}



      define line4 : Ui X line3

>>       line4: [(---:that ((X E Sc(X)) == (X
>>            <<= X)))]
>>         {move 2}



      define linea5 Xisset: line2 Xisset \
         Iff2 line4

>>       linea5: [(Xisset_1:that Isset(X)) =>
>>            (---:that (X E Sc(X)))]
>>         {move 2}



      declare v obj

>>       v: obj {move 3}



      define line6 Xisset: Fixform(Isset \
         Sc X,Add2((Sc X)=0,Ei(X, \
         [v=>v E (Sc X)] \
         ,linea5 Xisset)))

>>       line6: [(Xisset_1:that Isset(X)) =>
>>            (---:that Isset(Sc(X)))]
>>         {move 2}



      close

   define line7 X: Ded line6

>>    line7: [(X_1:obj) => (---:that (Isset(X_1)
>>         -> Isset(Sc(X_1))))]
>>      {move 1}



   define linea7 X: Ded linea5

>>    linea7: [(X_1:obj) => (---:that (Isset(X_1)
>>         -> (X_1 E Sc(X_1))))]
>>      {move 1}



   close

define Scofsetisset: Ug line7

>> Scofsetisset: [(Ug([(X_1:obj) => (Ded([(Xisset_2:
>>            that Isset(X_1)) => ((Isset(Sc(X_1))
>>            Fixform ((Sc(X_1) = 0) Add2 Ei(X_1,
>>            [(v_4:obj) => ((v_4 E Sc(X_1)):prop)]
>>            ,((Xisset_2 Mp (X_1 Ui Subsetrefl))
>>            Iff2 (X_1 Ui Scthm(X_1)))))):that
>>            Isset(Sc(X_1)))])
>>         :that (Isset(X_1) -> Isset(Sc(X_1))))])
>>      :that Forall([(X_7:obj) => ((Isset(X_7)
>>         -> Isset(Sc(X_7))):prop)]))
>>      ]
>>   {move 0}



define Inownpowerset: Ug linea7

>> Inownpowerset: [(Ug([(X_1:obj) => (Ded([(Xisset_2:
>>            that Isset(X_1)) => (((Xisset_2
>>            Mp (X_1 Ui Subsetrefl)) Iff2 (X_1
>>            Ui Scthm(X_1))):that (X_1 E Sc(X_1)))])
>>         :that (Isset(X_1) -> (X_1 E Sc(X_1))))])
>>      :that Forall([(X_5:obj) => ((Isset(X_5)
>>         -> (X_5 E Sc(X_5))):prop)]))
>>      ]
>>   {move 0}



postulate Sc2 x: that Isset Sc x

>> Sc2: [(x_1:obj) => (---:that Isset(Sc(x_1)))]
>>   {move 0}


\end{verbatim}

Above we have defined the subset relation and declared the power set operation  (using Rosser's notation ${\tt SC}(x)$.  We have proved a number of theorems and rules of inference involving subset which came up in developments below.

Further, we proved reflexivity of equality, the fact that a set belongs to its own power set and that the power set of a set is a set,
and added a further axiom that all power sets are sets (so that atoms have the empty set as their power set).

\begin{verbatim}Lestrade execution:


declare w obj

>> w: obj {move 1}



postulate Union x obj

>> Union: [(x_1:obj) => (---:obj)]
>>   {move 0}



postulate Uthm x: that Forall [z=> (z E Union \
      x) == Exists [w=>(z E w) & w E x] \
      ] \
   



>> Uthm: [(x_1:obj) => (---:that Forall([(z_2:
>>         obj) => (((z_2 E Union(x_1)) == Exists([(w_3:
>>            obj) => (((z_2 E w_3) & (w_3 E x_1)):
>>            prop)]))
>>         :prop)]))
>>      ]
>>   {move 0}



define ++ x y: Union x ; y

>> ++: [(x_1:obj),(y_1:obj) => ((Union(x_1)
>>      ; y_1):obj)]
>>   {move 0}


\end{verbatim}


Here we declare the set union operation and its defining theorem, and define binary union.  Various utilities need to be developed.

\section{The axiom scheme of separation}

We now develop the signature axiom scheme of Zermelo set theory, which may be thought of as its solution to the ``paradoxes of naive set theory".  An arbitrary predicate of untyped objects can be converted to a set, if restricted to an already given set.

\begin{verbatim}Lestrade execution:

clearcurrent


declare A obj

>> A: obj {move 1}



declare x obj

>> x: obj {move 1}



declare pred [x=>prop] \
   



>> pred: [(x_1:obj) => (---:prop)]
>>   {move 1}



postulate Set A pred obj

>> Set: [(A_1:obj),(pred_1:[(x_2:obj) => (---:
>>         prop)])
>>      => (---:obj)]
>>   {move 0}



postulate Separation A pred that Forall[x=>(x \
      E Set A pred)==(x E A) & pred x] \
   



>> Separation: [(A_1:obj),(pred_1:[(x_2:obj)
>>         => (---:prop)])
>>      => (---:that Forall([(x_3:obj) => (((x_3
>>         E (A_1 Set pred_1)) == ((x_3 E A_1)
>>         & pred_1(x_3))):prop)]))
>>      ]
>>   {move 0}



postulate Separation2 A pred that Isset (Set \
   A pred)

>> Separation2: [(A_1:obj),(pred_1:[(x_2:obj)
>>         => (---:prop)])
>>      => (---:that Isset((A_1 Set pred_1)))]
>>   {move 0}



declare sillyeq that x = Set A pred

>> sillyeq: that (x = (A Set pred)) {move 1}



define Separation3 sillyeq : Separation2 \
   A pred

>> Separation3: [(.x_1:obj),(.A_1:obj),(.pred_1:
>>      [(x_2:obj) => (---:prop)]),
>>      (sillyeq_1:that (.x_1 = (.A_1 Set .pred_1)))
>>      => ((.A_1 Separation2 .pred_1):that Isset((.A_1
>>      Set .pred_1)))]
>>   {move 0}



define Separation4 sillyeq : Separation A \
   pred

>> Separation4: [(.x_1:obj),(.A_1:obj),(.pred_1:
>>      [(x_2:obj) => (---:prop)]),
>>      (sillyeq_1:that (.x_1 = (.A_1 Set .pred_1)))
>>      => ((.A_1 Separation .pred_1):that Forall([(x_3:
>>         obj) => (((x_3 E (.A_1 Set .pred_1))
>>         == ((x_3 E .A_1) & .pred_1(x_3))):prop)]))
>>      ]
>>   {move 0}



declare X7 obj

>> X7: obj {move 1}



declare Y7 obj

>> Y7: obj {move 1}



declare Z7 obj

>> Z7: obj {move 1}



declare xinyev that X7 E Y7

>> xinyev: that (X7 E Y7) {move 1}



declare pred7 [Z7 => prop] \
   



>> pred7: [(Z7_1:obj) => (---:prop)]
>>   {move 1}



declare univev that Forall[Z7 => (Z7 E Y7) \
      -> pred7 Z7] \
   



>> univev: that Forall([(Z7_1:obj) => (((Z7_1
>>      E Y7) -> pred7(Z7_1)):prop)])
>>   {move 1}



define Univcheat xinyev univev: Mp xinyev, \
   Ui X7 univev

>> Univcheat: [(.X7_1:obj),(.Y7_1:obj),(xinyev_1:
>>      that (.X7_1 E .Y7_1)),(.pred7_1:[(Z7_2:
>>         obj) => (---:prop)]),
>>      (univev_1:that Forall([(Z7_3:obj) => (((Z7_3
>>         E .Y7_1) -> .pred7_1(Z7_3)):prop)]))
>>      => ((xinyev_1 Mp (.X7_1 Ui univev_1)):
>>      that .pred7_1(.X7_1))]
>>   {move 0}



declare inev7 that X7 E Set Y7, pred7

>> inev7: that (X7 E (Y7 Set pred7)) {move 1}



define Separation5 inev7: Iff1 inev7, Ui \
   X7, Separation4 Refleq Set Y7, pred7

>> Separation5: [(.X7_1:obj),(.Y7_1:obj),(.pred7_1:
>>      [(Z7_2:obj) => (---:prop)]),
>>      (inev7_1:that (.X7_1 E (.Y7_1 Set .pred7_1)))
>>      => ((inev7_1 Iff1 (.X7_1 Ui Separation4(Refleq((.Y7_1
>>      Set .pred7_1))))):that ((.X7_1 E .Y7_1)
>>      & .pred7_1(.X7_1)))]
>>   {move 0}



declare y obj

>> y: obj {move 1}



declare z obj

>> z: obj {move 1}



define ** x y : Set x [z=>z E y] \
   



>> **: [(x_1:obj),(y_1:obj) => ((x_1 Set [(z_2:
>>         obj) => ((z_2 E y_1):prop)])
>>      :obj)]
>>   {move 0}



declare Aisset that Isset A

>> Aisset: that Isset(A) {move 1}



open

   declare X obj

>>    X: obj {move 2}



   open

      declare Xinev that X E (Set A pred)


>>       Xinev: that (X E (A Set pred)) {move
>>         3}



      define line1 Xinev: Simp1 Iff1 Xinev, \
         Ui X, Separation A pred

>>       line1: [(Xinev_1:that (X E (A Set pred)))
>>            => (---:that (X E A))]
>>         {move 2}



      close

   define line2 X: Ded line1

>>    line2: [(X_1:obj) => (---:that ((X_1 E
>>         (A Set pred)) -> (X_1 E A)))]
>>      {move 1}



   close

define Sepsub A pred, Aisset: Fixform((Set \
   A pred)<<=A,Conj(Ug line2,Conj(Separation2 \
   A pred,Aisset)))

>> Sepsub: [(A_1:obj),(pred_1:[(x_2:obj) =>
>>         (---:prop)]),
>>      (Aisset_1:that Isset(A_1)) => ((((A_1
>>      Set pred_1) <<= A_1) Fixform (Ug([(X_5:
>>         obj) => (Ded([(Xinev_6:that (X_5 E
>>            (A_1 Set pred_1))) => (Simp1((Xinev_6
>>            Iff1 (X_5 Ui (A_1 Separation pred_1)))):
>>            that (X_5 E A_1))])
>>         :that ((X_5 E (A_1 Set pred_1)) ->
>>         (X_5 E A_1)))])
>>      Conj ((A_1 Separation2 pred_1) Conj Aisset_1))):
>>      that ((A_1 Set pred_1) <<= A_1))]
>>   {move 0}



declare eqev that (Set A pred)=Set A pred


>> eqev: that ((A Set pred) = (A Set pred))
>>   {move 1}



define Sepsub2 Aisset eqev:Sepsub A pred, \
   Aisset

>> Sepsub2: [(.A_1:obj),(Aisset_1:that Isset(.A_1)),
>>      (.pred_1:[(x_2:obj) => (---:prop)]),
>>      (eqev_1:that ((.A_1 Set .pred_1) = (.A_1
>>      Set .pred_1))) => (Sepsub(.A_1,.pred_1,
>>      Aisset_1):that ((.A_1 Set .pred_1) <<=
>>      .A_1))]
>>   {move 0}


\end{verbatim}

Above we declare the construction of sets by restriction from classes and the separation axiom scheme.  Further, we declare the binary intersection operation.  There are lots of utility operations and theorems to be developed.  {\tt Separation2} is a mere footnote to avoid annoyances involving the empty set.

{\tt Separation3} allows one to show that an object $X$ defined by separation is a set by supplying it with the evidence for $X=X$ as the only explicit argument.
The lovely part of this is that we do not need to write out the condition defining $X$:  the implicit argument mechanism extracts it!  {\tt Separation4} similarly extracts
the defining instance of separation associated with $X$.  {\tt Separation5} applies the defining instance of separation to a membership statement (without the need to know the defining predicate of the set defined explicitly).  {\tt Univcheat} is a tool for exploiting universal statements about all members of a set whose identity you want to leave implicit.  {\tt Sepsub} is the theorem that $\{x \in A:\phi\}$ is a subset of $A$, and {\tt Sepsub2} is a version
which works without needing the explicit defining formula of its argument, again using the implicit argument mechanism to extract the definition of $X$ from the
proof of $X=X$.

The following development makes use of the reasoning in Russell's paradox to show that for every set there is some object not belonging to it.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x1 obj

>> x1: obj {move 1}



declare y obj

>> y: obj {move 1}



define Russell x1 : Set x1 [y=> ~(y E y)] \
   



>> Russell: [(x1_1:obj) => ((x1_1 Set [(y_2:
>>         obj) => (~((y_2 E y_2)):prop)])
>>      :obj)]
>>   {move 0}



define Russellax x1 : Fixform(Forall[y=>(y \
      E Russell x1) == (y E x1) & ~(y E y)] \
   ,Separation x1 [y=> ~(y E y)]) \
   



>> Russellax: [(x1_1:obj) => ((Forall([(y_2:
>>         obj) => (((y_2 E Russell(x1_1)) ==
>>         ((y_2 E x1_1) & ~((y_2 E y_2)))):prop)])
>>      Fixform (x1_1 Separation [(y_3:obj) =>
>>         (~((y_3 E y_3)):prop)]))
>>      :that Forall([(y_4:obj) => (((y_4 E Russell(x1_1))
>>         == ((y_4 E x1_1) & ~((y_4 E y_4)))):
>>         prop)]))
>>      ]
>>   {move 0}



open

   declare x obj

>>    x: obj {move 2}



   open

      declare rhyp1 that (Russell x) E x


>>       rhyp1: that (Russell(x) E x) {move
>>         3}



      open

         declare rhyp2 that (Russell x) E \
            Russell x

>>          rhyp2: that (Russell(x) E Russell(x))
>>            {move 4}



         open

            declare y1 obj

>>             y1: obj {move 5}



            define line1 : Ui (Russell x, \
               Russellax x)

>>             line1: [(---:that ((Russell(x)
>>                  E Russell(x)) == ((Russell(x)
>>                  E x) & ~((Russell(x) E Russell(x))))))]
>>               {move 4}



            define linea1: Ui(Russell x,Separation \
               x [y1 => ~(y1 E y1)]) \
               



>>             linea1: [(---:that ((Russell(x)
>>                  E (x Set [(y1_4:obj) => (~((y1_4
>>                     E y1_4)):prop)]))
>>                  == ((Russell(x) E x) & ~((Russell(x)
>>                  E Russell(x))))))]
>>               {move 4}



            define line2: Iff1 rhyp2 linea1


>>             line2: [(---:that ((Russell(x)
>>                  E x) & ~((Russell(x) E Russell(x)))))]
>>               {move 4}



            define line3: Simp2 line2

>>             line3: [(---:that ~((Russell(x)
>>                  E Russell(x))))]
>>               {move 4}



            define line4: Mp rhyp2 line3


>>             line4: [(---:that ??)]
>>               {move 4}



            close

         define line5 rhyp2: line4

>>          line5: [(rhyp2_1:that (Russell(x)
>>               E Russell(x))) => (---:that ??)]
>>            {move 3}



         define line6: Negintro line5

>>          line6: [(---:that ~((Russell(x)
>>               E Russell(x))))]
>>            {move 3}



         define line7: Ui (Russell x,Russellax \
            x)

>>          line7: [(---:that ((Russell(x) E
>>               Russell(x)) == ((Russell(x) E
>>               x) & ~((Russell(x) E Russell(x))))))]
>>            {move 3}



         declare z obj

>>          z: obj {move 4}



         define linea7: Ui(Russell x,Separation \
            x [z=> ~(z E z)]) \
            



>>          linea7: [(---:that ((Russell(x)
>>               E (x Set [(z_4:obj) => (~((z_4
>>                  E z_4)):prop)]))
>>               == ((Russell(x) E x) & ~((Russell(x)
>>               E Russell(x))))))]
>>            {move 3}



         define line8: Iff2(Conj(rhyp1,line6), \
            linea7)

>>          line8: [(---:that (Russell(x) E
>>               (x Set [(z_2:obj) => (~((z_2
>>                  E z_2)):prop)]))
>>               )]
>>            {move 3}



         define line9: Mp line8 line6

>>          line9: [(---:that ??)]
>>            {move 3}



         close

      define notin rhyp1:line9

>>       notin: [(rhyp1_1:that (Russell(x) E
>>            x)) => (---:that ??)]
>>         {move 2}



      define Notin1:Negintro notin

>>       Notin1: [(---:that ~((Russell(x) E
>>            x)))]
>>         {move 2}



      define Enotin1: Ei1 (Russell x,Notin1)


>>       Enotin1: [(---:that Exists([(x_2:obj)
>>               => (~((x_2 E x)):prop)]))
>>            ]
>>         {move 2}



      close

   define Notin2 x: Notin1

>>    Notin2: [(x_1:obj) => (---:that ~((Russell(x_1)
>>         E x_1)))]
>>      {move 1}



   define Enotin x : Enotin1

>>    Enotin: [(x_1:obj) => (---:that Exists([(x_17:
>>            obj) => (~((x_17 E x_1)):prop)]))
>>         ]
>>      {move 1}



   close

define Notin x1: Notin2 x1

>> Notin: [(x1_1:obj) => (Negintro([(rhyp1_2:
>>         that (Russell(x1_1) E x1_1)) => ((((rhyp1_2
>>         Conj Negintro([(rhyp2_4:that (Russell(x1_1)
>>            E Russell(x1_1))) => ((rhyp2_4 Mp
>>            Simp2((rhyp2_4 Iff1 (Russell(x1_1)
>>            Ui (x1_1 Separation [(y1_7:obj)
>>               => (~((y1_7 E y1_7)):prop)]))
>>            ))):that ??)]))
>>         Iff2 (Russell(x1_1) Ui (x1_1 Separation
>>         [(z_11:obj) => (~((z_11 E z_11)):prop)]))
>>         ) Mp Negintro([(rhyp2_12:that (Russell(x1_1)
>>            E Russell(x1_1))) => ((rhyp2_12
>>            Mp Simp2((rhyp2_12 Iff1 (Russell(x1_1)
>>            Ui (x1_1 Separation [(y1_15:obj)
>>               => (~((y1_15 E y1_15)):prop)]))
>>            ))):that ??)]))
>>         :that ??)])
>>      :that ~((Russell(x1_1) E x1_1)))]
>>   {move 0}



define Uenotin: Ug Enotin

>> Uenotin: [(Ug([(x_1:obj) => ((Russell(x_1)
>>         Ei1 Negintro([(rhyp1_4:that (Russell(x_1)
>>            E x_1)) => ((((rhyp1_4 Conj Negintro([(rhyp2_6:
>>               that (Russell(x_1) E Russell(x_1)))
>>               => ((rhyp2_6 Mp Simp2((rhyp2_6
>>               Iff1 (Russell(x_1) Ui (x_1 Separation
>>               [(y1_9:obj) => (~((y1_9 E y1_9)):
>>                  prop)]))
>>               ))):that ??)]))
>>            Iff2 (Russell(x_1) Ui (x_1 Separation
>>            [(z_13:obj) => (~((z_13 E z_13)):
>>               prop)]))
>>            ) Mp Negintro([(rhyp2_14:that (Russell(x_1)
>>               E Russell(x_1))) => ((rhyp2_14
>>               Mp Simp2((rhyp2_14 Iff1 (Russell(x_1)
>>               Ui (x_1 Separation [(y1_17:obj)
>>                  => (~((y1_17 E y1_17)):prop)]))
>>               ))):that ??)]))
>>            :that ??)]))
>>         :that Exists([(x_2:obj) => (~((x_2
>>            E x_1)):prop)]))
>>         ])
>>      :that Forall([(x_18:obj) => (Exists([(x_19:
>>            obj) => (~((x_19 E x_18)):prop)])
>>         :prop)]))
>>      ]
>>   {move 0}


\end{verbatim}

By a diagonalization similar to that in the Russell argument, we are able to uniformly select an element from the complement of each set.

The use of the definitions {\tt linea1} and {\tt linea7} (which eliminate the need to define {\t Russellax}) are a test of the matching capabilities of Lestrade.  But the formulation of something like {\tt Russellax} for a defined set construction is probably a good idea.

I believe I may use the constructions here to implement some of Zermelo's constructions where he speaks generally of choosing something not in a set.

\section{The axiom of infinity}

The axiom of infinity is introduced in the original form used by Zermelo.  0 is implemented as $\emptyset$ and the successor operation is implemented as the singleton operation.

\begin{verbatim}Lestrade execution:


declare x obj

>> x: obj {move 1}



declare pred [x=> prop] \
   



>> pred: [(x_1:obj) => (---:prop)]
>>   {move 1}



define inductive pred : (Forall [x=> pred \
      x -> pred Usc x]) \
   & pred 0

>> inductive: [(pred_1:[(x_2:obj) => (---:prop)])
>>      => ((Forall([(x_3:obj) => ((pred_1(x_3)
>>         -> pred_1(Usc(x_3))):prop)])
>>      & pred_1(0)):prop)]
>>   {move 0}



postulate N obj

>> N: obj {move 0}



postulate Nax1 that inductive [x => x E N] \
   



>> Nax1: that inductive([(x_1:obj) => ((x_1
>>      E N):prop)])
>>   {move 0}



declare predindev that inductive pred

>> predindev: that inductive(pred) {move 1}



declare isnatev that x E N

>> isnatev: that (x E N) {move 1}



postulate Nax2 predindev isnatev : that x \
   E N

>> Nax2: [(.pred_1:[(x_2:obj) => (---:prop)]),
>>      (predindev_1:that inductive(.pred_1)),
>>      (.x_1:obj),(isnatev_1:that (.x_1 E N))
>>      => (---:that (.x_1 E N))]
>>   {move 0}


\end{verbatim}

Natural numbers are defined as those objects which have all inductive properties, and it is declared that the collection of natural numbers is a set (and that belonging to this set
is an inductive property).

Some declarations related to arithmetic and finite sets should appear here.

\section{The axiom of choice}

Here we state the axiom of choice in its original form:  each partition has a choice set.

\begin{verbatim}Lestrade execution:

clearcurrent


declare x obj

>> x: obj {move 1}



declare y obj

>> y: obj {move 1}



declare z obj

>> z: obj {move 1}



declare w obj

>> w: obj {move 1}



define Ispartition x : (Forall [y => (y E \
      x) -> Exists[z => z E y] \
      ]) \
   & Forall [y => (y E (Union x)) -> One[z \
         => (y E z) & z E x] \
      ] \
   



>> Ispartition: [(x_1:obj) => ((Forall([(y_2:
>>         obj) => (((y_2 E x_1) -> Exists([(z_3:
>>            obj) => ((z_3 E y_2):prop)]))
>>         :prop)])
>>      & Forall([(y_4:obj) => (((y_4 E Union(x_1))
>>         -> One([(z_5:obj) => (((y_4 E z_5)
>>            & (z_5 E x_1)):prop)]))
>>         :prop)]))
>>      :prop)]
>>   {move 0}



postulate Ac that Forall [x => (Ispartition \
      x) -> Exists[y => (y <<= Union x) & Forall \
         [z=> (z E x) -> One [w => (w E y) \
               & w E z] \
            ] \
         ] \
      ] \
   



>> Ac: that Forall([(x_1:obj) => ((Ispartition(x_1)
>>      -> Exists([(y_2:obj) => (((y_2 <<= Union(x_1))
>>         & Forall([(z_3:obj) => (((z_3 E x_1)
>>            -> One([(w_4:obj) => (((w_4 E y_2)
>>               & (w_4 E z_3)):prop)]))
>>            :prop)]))
>>         :prop)]))
>>      :prop)])
>>   {move 0}


\end{verbatim}

Examples of use of this axiom are needed.

This completes the development of the axioms of 1908 Zermelo set theory under Lestrade.

\section{Zermelo's 1908 proof of the well-ordering theorem}

I am now going to carry out or at least attempt a significant piece of mathematics in Lestrade.  I shall attempt to directly translate Zermelo's 1908 proof of the well-ordering theorem
(which was published at about the same time as the axiomatization implemented above:  they are intimately connected) into a Lestrade proof.

Zermelo starts by stating prerequisites which are found in the axiomatization.  Point I:  he requires the axiom of Separation, stated above.  He points out as an important corollary the existence of
relative complements.

\begin{verbatim}Lestrade execution:

clearcurrent


declare M obj

>> M: obj {move 1}



declare M1 obj

>> M1: obj {move 1}



declare x obj

>> x: obj {move 1}



define Complement M M1 : Set M [x => ~(x \
      E M1)] \
   



>> Complement: [(M_1:obj),(M1_1:obj) => ((M_1
>>      Set [(x_2:obj) => (~((x_2 E M1_1)):prop)])
>>      :obj)]
>>   {move 0}



define Compax M M1 : Fixform(Forall[x=>(x \
      E Complement M M1)==(x E M)& ~(x E M1)] \
   ,Separation M [x => ~(x E M1)]) \
   



>> Compax: [(M_1:obj),(M1_1:obj) => ((Forall([(x_2:
>>         obj) => (((x_2 E (M_1 Complement M1_1))
>>         == ((x_2 E M_1) & ~((x_2 E M1_1)))):
>>         prop)])
>>      Fixform (M_1 Separation [(x_3:obj) =>
>>         (~((x_3 E M1_1)):prop)]))
>>      :that Forall([(x_4:obj) => (((x_4 E (M_1
>>         Complement M1_1)) == ((x_4 E M_1) &
>>         ~((x_4 E M1_1)))):prop)]))
>>      ]
>>   {move 0}


\end{verbatim}

Above we implement the relative complement and its defining axiom.

As point II he requires the existence of power sets, provided by us in the axiomatization above. 

As point III, he notes that Separation implies the existence of intersections of (nonempty) sets.

\begin{verbatim}Lestrade execution:

clearcurrent


declare T obj

>> T: obj {move 1}



declare A obj

>> A: obj {move 1}



declare x obj

>> x: obj {move 1}



declare B obj

>> B: obj {move 1}



define Intersection T A : Set A [x => Forall[B \
         => (B E T) -> x E B] \
      ] \
   



>> Intersection: [(T_1:obj),(A_1:obj) => ((A_1
>>      Set [(x_2:obj) => (Forall([(B_3:obj) =>
>>            (((B_3 E T_1) -> (x_2 E B_3)):prop)])
>>         :prop)])
>>      :obj)]
>>   {move 0}



open

   declare inev that A E T

>>    inev: that (A E T) {move 2}



   open

      declare u obj

>>       u: obj {move 3}



      open

         declare hyp1 that u E Intersection \
            T A

>>          hyp1: that (u E (T Intersection
>>            A)) {move 4}



         declare x1 obj

>>          x1: obj {move 4}



         declare B1 obj

>>          B1: obj {move 4}



         declare hyp2 that Forall[B1 =>(B1 \
               E T)-> u E B1] \
            



>>          hyp2: that Forall([(B1_1:obj) =>
>>               (((B1_1 E T) -> (u E B1_1)):prop)])
>>            {move 4}



         define line1 hyp2: Ui A hyp2

>>          line1: [(hyp2_1:that Forall([(B1_2:
>>                  obj) => (((B1_2 E T) -> (u
>>                  E B1_2)):prop)]))
>>               => (---:that ((A E T) -> (u E
>>               A)))]
>>            {move 3}



         define line2 hyp2: Mp inev line1 \
            hyp2

>>          line2: [(hyp2_1:that Forall([(B1_2:
>>                  obj) => (((B1_2 E T) -> (u
>>                  E B1_2)):prop)]))
>>               => (---:that (u E A))]
>>            {move 3}



         define line3 hyp2: Conj (line2 hyp2, \
            hyp2)

>>          line3: [(hyp2_1:that Forall([(B1_2:
>>                  obj) => (((B1_2 E T) -> (u
>>                  E B1_2)):prop)]))
>>               => (---:that ((u E A) & Forall([(B1_4:
>>                  obj) => (((B1_4 E T) -> (u
>>                  E B1_4)):prop)]))
>>               )]
>>            {move 3}



         define line4 hyp2: Fixform(u E Intersection \
            T A,Iff2(line3 hyp2,Ui(u,Separation \
            A [x1 => Forall[B1 => (B1 E T) \
                  -> x1 E B1] \
               ])) \
            )

>>          line4: [(hyp2_1:that Forall([(B1_2:
>>                  obj) => (((B1_2 E T) -> (u
>>                  E B1_2)):prop)]))
>>               => (---:that (u E (T Intersection
>>               A)))]
>>            {move 3}



         define line5 hyp1 : Simp2(Iff1(hyp1, \
            Ui(u, Separation A [x1 => Forall[B1 \
                  => (B1 E T) -> x1 E B1] \
               ])) \
            )

>>          line5: [(hyp1_1:that (u E (T Intersection
>>               A))) => (---:that Forall([(B1_10:
>>                  obj) => (((B1_10 E T) -> (u
>>                  E B1_10)):prop)]))
>>               ]
>>            {move 3}



         close

      define bothways u : Dediff line5,line4


>>       bothways: [(u_1:obj) => (---:that ((u_1
>>            E (T Intersection A)) == Forall([(B1_26:
>>               obj) => (((B1_26 E T) -> (u_1
>>               E B1_26)):prop)]))
>>            )]
>>         {move 2}



      close

   define Intax1 inev: Ug bothways

>>    Intax1: [(inev_1:that (A E T)) => (---:
>>         that Forall([(u_30:obj) => (((u_30
>>            E (T Intersection A)) == Forall([(B1_31:
>>               obj) => (((B1_31 E T) -> (u_30
>>               E B1_31)):prop)]))
>>            :prop)]))
>>         ]
>>      {move 1}



   close

define Intax T A: Ded Intax1

>> Intax: [(T_1:obj),(A_1:obj) => (Ded([(inev_4:
>>         that (A_1 E T_1)) => (Ug([(u_7:obj)
>>            => (Dediff([(hyp1_9:that (u_7 E
>>               (T_1 Intersection A_1))) => (Simp2((hyp1_9
>>               Iff1 (u_7 Ui (A_1 Separation
>>               [(x1_16:obj) => (Forall([(B1_17:
>>                     obj) => (((B1_17 E T_1)
>>                     -> (x1_16 E B1_17)):prop)])
>>                  :prop)]))
>>               )):that Forall([(B1_18:obj) =>
>>                  (((B1_18 E T_1) -> (u_7 E
>>                  B1_18)):prop)]))
>>               ]
>>            ,[(hyp2_19:that Forall([(B1_20:obj)
>>                  => (((B1_20 E T_1) -> (u_7
>>                  E B1_20)):prop)]))
>>               => (((u_7 E (T_1 Intersection
>>               A_1)) Fixform (((inev_4 Mp (A_1
>>               Ui hyp2_19)) Conj hyp2_19) Iff2
>>               (u_7 Ui (A_1 Separation [(x1_30:
>>                  obj) => (Forall([(B1_31:obj)
>>                     => (((B1_31 E T_1) -> (x1_30
>>                     E B1_31)):prop)])
>>                  :prop)]))
>>               )):that (u_7 E (T_1 Intersection
>>               A_1)))])
>>            :that ((u_7 E (T_1 Intersection
>>            A_1)) == Forall([(B1_32:obj) =>
>>               (((B1_32 E T_1) -> (u_7 E B1_32)):
>>               prop)]))
>>            )])
>>         :that Forall([(u_33:obj) => (((u_33
>>            E (T_1 Intersection A_1)) == Forall([(B1_34:
>>               obj) => (((B1_34 E T_1) -> (u_33
>>               E B1_34)):prop)]))
>>            :prop)]))
>>         ])
>>      :that ((A_1 E T_1) -> Forall([(u_35:obj)
>>         => (((u_35 E (T_1 Intersection A_1))
>>         == Forall([(B1_36:obj) => (((B1_36
>>            E T_1) -> (u_35 E B1_36)):prop)]))
>>         :prop)]))
>>      )]
>>   {move 0}


\end{verbatim}

Above we develop the set intersection operation and prove the natural symmetric form of its associated comprehension axiom (without the asymmetric special role of $A$).

Zermelo states the following Theorem, the central result in his argument (the well ordering theorem follows immediately from this theorem and the axiom of choice, as we will verify below).

\begin{description}

\item[Theorem:]  If with every nonempty subset of a set $M$ an element of the subset is associated by some law as ``distinguished element", then ${\cal P}(x)$, the set of all subsets of $M$, possesses one and only one subset ${\bf M}$ such that to every arbitrary subset $P$ of $M$  there always corresponds one and only one element $P_0$ of $M$ that includes $P$ as a subset and contains an element of $P$ as its distinguished element.  The set $M$ is well-ordered by ${\bf M}$.

\end{description}

The apparent second-order quality of this theorem is dispelled by the proof in Lestrade, in which we see how we can introduce the ``law" referred to as a hypothetical without in fact allowing quantification over such laws (and nonetheless successfully carry out the proof of the corollary).



We declare the hypotheses of the theorem, the set $M$ and the unspecified law that, given a subset $S$ of $M$, allows us to select a distinguished element of $S$.

\begin{verbatim}Lestrade execution:

clearcurrent


declare M obj

>> M: obj {move 1}



declare Misset that Isset M

>> Misset: that Isset(M) {move 1}



open

   declare S obj

>>    S: obj {move 2}



   declare x obj

>>    x: obj {move 2}



   declare subsetev that S <<= M

>>    subsetev: that (S <<= M) {move 2}



   declare inev that Exists [x => x E S] \
      



>>    inev: that Exists([(x_1:obj) => ((x_1
>>         E S):prop)])
>>      {move 2}



   postulate thelaw S : obj

>>    thelaw: [(S_1:obj) => (---:obj)]
>>      {move 1}



   postulate thelawchooses subsetev inev \
      : that (thelaw S) E S

>>    thelawchooses: [(.S_1:obj),(subsetev_1:
>>         that (.S_1 <<= M)),(inev_1:that Exists([(x_2:
>>            obj) => ((x_2 E .S_1):prop)]))
>>         => (---:that (thelaw(.S_1) E .S_1))]
>>      {move 1}



   close
\end{verbatim}

It appears for direct implementation of Zermelo's argument that the choice of a distinguished element should return something arbitrary when the argument is empty,
and further it is convenient for the choice to work for any set (or indeed atom) at all, formally, though we make no assumptions about the result.  Otherwise we need
axioms handling proof indifference and there are other embarrassments.

This seems to be a general fact:  operations taking sets to sets (or more generally, sets and atoms to sets and atoms) should be universal, or we end up stumbling over the Lestrade type system.

\begin{verbatim}Lestrade execution:


open

   declare S obj

>>    S: obj {move 2}



   declare subsetev that S <<= M

>>    subsetev: that (S <<= M) {move 2}



   define prime1 S : Complement(S,Usc(thelaw \
      S))

>>    prime1: [(S_1:obj) => (---:obj)]
>>      {move 1}



   save

   close

declare S1 obj

>> S1: obj {move 1}



define prime2 thelaw, S1:prime1 S1

>> prime2: [(thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (S1_1:obj) => ((S1_1 Complement Usc(thelaw_1(S1_1))):
>>      obj)]
>>   {move 0}



open

   define prime S: prime2 thelaw, S

>>    prime: [(S_1:obj) => (---:obj)]
>>      {move 1}


\end{verbatim}

An important operation in Zermelo's argument takes each subset $A$ of $M$ to the subset $A' = A \setminus \{a\}$, where $a$ is the distinguished element of $A$ if
$A$ is nonempty.  This is defined above.  Below, we prove its natural comprehension axiom.

\begin{verbatim}Lestrade execution:


   open

      declare u obj

>>       u: obj {move 3}



      open

         declare hyp1 that u E prime S

>>          hyp1: that (u E prime(S)) {move
>>            4}



         declare hyp2 that (u E S) & ~(u \
            = thelaw S)

>>          hyp2: that ((u E S) & ~((u = thelaw(S))))
>>            {move 4}



         define line1 hyp1: Iff1(hyp1,Ui(u, \
            Compax(S, Usc(thelaw S))))

>>          line1: [(hyp1_1:that (u E prime(S)))
>>               => (---:that ((u E S) & ~((u
>>               E Usc(thelaw(S))))))]
>>            {move 3}



         define line2 hyp1: Simp2(line1 hyp1)


>>          line2: [(hyp1_1:that (u E prime(S)))
>>               => (---:that ~((u E Usc(thelaw(S)))))]
>>            {move 3}



         open

            declare hyp3 that u = thelaw \
               S

>>             hyp3: that (u = thelaw(S)) {move
>>               5}



            define line3: Inusc2(thelaw S)


>>             line3: [(---:that (thelaw(S)
>>                  E (thelaw(S) ; thelaw(S))))]
>>               {move 4}



            declare v obj

>>             v: obj {move 5}



            define line4 hyp3: Subs(Eqsymm \
               hyp3, [v => v E (Usc(thelaw \
                  S))] \
               ,line3)

>>             line4: [(hyp3_1:that (u = thelaw(S)))
>>                  => (---:that (u E Usc(thelaw(S))))]
>>               {move 4}



            define line5 hyp3: line4 hyp3 \
               Mp line2 hyp1

>>             line5: [(hyp3_1:that (u = thelaw(S)))
>>                  => (---:that ??)]
>>               {move 4}



            close

         define line6 hyp1 : Conj(Simp1 line1 \
            hyp1, Negintro line5)

>>          line6: [(hyp1_1:that (u E prime(S)))
>>               => (---:that ((u E S) & ~((u
>>               = thelaw(S)))))]
>>            {move 3}



         open

            declare hyp4 that u E Usc(thelaw \
               S)

>>             hyp4: that (u E Usc(thelaw(S)))
>>               {move 5}



            define line8 hyp4: Mp(Inusc1 \
               hyp4,Simp2 \
               hyp2)

>>             line8: [(hyp4_1:that (u E Usc(thelaw(S))))
>>                  => (---:that ??)]
>>               {move 4}



            close

         define line9 hyp2: Conj(Simp1 hyp2, \
            Negintro line8)

>>          line9: [(hyp2_1:that ((u E S) &
>>               ~((u = thelaw(S))))) => (---:
>>               that ((u E S) & ~((u E Usc(thelaw(S))))))]
>>            {move 3}



         define line10 hyp2: Iff2(line9 hyp2, \
            Ui(u, Compax(S,Usc(thelaw \
            S))))

>>          line10: [(hyp2_1:that ((u E S) &
>>               ~((u = thelaw(S))))) => (---:
>>               that (u E (S Complement Usc(thelaw(S)))))]
>>            {move 3}



         close

      define bothways u : Dediff line6, line10


>>       bothways: [(u_1:obj) => (---:that ((u_1
>>            E prime(S)) == ((u_1 E S) & ~((u_1
>>            = thelaw(S))))))]
>>         {move 2}



      close

   define primeax subsetev : Ug bothways


>>    primeax: [(.S_1:obj),(subsetev_1:that
>>         (.S_1 <<= M)) => (---:that Forall([(u_12:
>>            obj) => (((u_12 E prime(.S_1)) ==
>>            ((u_12 E .S_1) & ~((u_12 = thelaw(.S_1))))):
>>            prop)]))
>>         ]
>>      {move 1}



   close
\end{verbatim}

Now we are ready to define the central concept of this central argument, the idea of a $\Theta$-chain.

\begin{verbatim}Lestrade execution:


declare C11 obj

>> C11: obj {move 1}



declare D11 obj

>> D11: obj {move 1}



declare F11 obj

>> F11: obj {move 1}



define thetachain1 M thelaw, C11: (M E C11) \
   & (C11 <<= Sc(M)) & Forall [D11 => \
      (D11 E C11) -> (prime D11) E C11] \
   & Forall [D11 => Forall [F11 => ((D11 <<= \
         C11) & (F11 E D11)) -> \
         (Intersection D11 F11) E C11] \
      ] \
   



>> thetachain1: [(M_1:obj),(thelaw_1:[(S_2:obj)
>>         => (---:obj)]),
>>      (C11_1:obj) => (((M_1 E C11_1) & ((C11_1
>>      <<= Sc(M_1)) & (Forall([(D11_3:obj) =>
>>         (((D11_3 E C11_1) -> (prime2(thelaw_1,
>>         D11_3) E C11_1)):prop)])
>>      & Forall([(D11_4:obj) => (Forall([(F11_5:
>>            obj) => ((((D11_4 <<= C11_1) & (F11_5
>>            E D11_4)) -> ((D11_4 Intersection
>>            F11_5) E C11_1)):prop)])
>>         :prop)]))
>>      )):prop)]
>>   {move 0}



open

   declare C obj

>>    C: obj {move 2}



   declare D obj

>>    D: obj {move 2}



   declare F obj

>>    F: obj {move 2}



   define thetachain C: thetachain1 M thelaw, \
      C

>>    thetachain: [(C_1:obj) => (---:prop)]
>>      {move 1}



   declare thetaev that thetachain C

>>    thetaev: that thetachain(C) {move 2}



   declare G obj

>>    G: obj {move 2}



   declare ginev that G E C

>>    ginev: that (G E C) {move 2}



   define Setsinchains1 thetaev ginev: Simp1(Simp2(Iff1(Mp(ginev, \
      Ui (G, Simp1(Simp1 (Simp2 thetaev)))), \
      Ui G Scthm M)))

>>    Setsinchains1: [(.C_1:obj),(thetaev_1:
>>         that thetachain(.C_1)),(.G_1:obj),(ginev_1:
>>         that (.G_1 E .C_1)) => (---:that Isset(.G_1))]
>>      {move 1}



   save

   close

declare C100 obj

>> C100: obj {move 1}



declare thetaev100 that thetachain C100

>> thetaev100: that thetachain(C100) {move 1}



declare G100 obj

>> G100: obj {move 1}



declare ginev100 that G100 E C100

>> ginev100: that (G100 E C100) {move 1}



define Setsinchains2 Misset thelawchooses, \
   thetaev100 ginev100: Setsinchains1 thetaev100 \
   ginev100

>> Setsinchains2: [(.M_1:obj),(Misset_1:that
>>      Isset(.M_1)),(.thelaw_1:[(S_2:obj) =>
>>         (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))]),
>>      (.C100_1:obj),(thetaev100_1:that thetachain1(.M_1,
>>      .thelaw_1,.C100_1)),(.G100_1:obj),(ginev100_1:
>>      that (.G100_1 E .C100_1)) => (Simp1(Simp2(((ginev100_1
>>      Mp (.G100_1 Ui Simp1(Simp1(Simp2(thetaev100_1)))))
>>      Iff1 (.G100_1 Ui Scthm(.M_1))))):that
>>      Isset(.G100_1))]
>>   {move 0}



open

   define Setsinchains thetaev ginev: Setsinchains2 \
      Misset thelawchooses, thetaev ginev

>>    Setsinchains: [(.C_1:obj),(thetaev_1:that
>>         thetachain(.C_1)),(.G_1:obj),(ginev_1:
>>         that (.G_1 E .C_1)) => (---:that Isset(.G_1))]
>>      {move 1}



   close
\end{verbatim}

We did some extra work to ensure that {\tt thetachain} is defined in terms of a notion at move 0 which will not be expanded everywhere it occurs.

We then need to prove that ${\cal P}(M)$ is a $\Theta$-chain.

\begin{verbatim}Lestrade execution:


open

   open

      define line1 : Misset Mp Ui M Inownpowerset \
         



>>       line1: [(---:that (M E Sc(M)))]
>>         {move 2}



      define line2 : (Misset Mp Ui M Scofsetisset) \
         Mp Ui Sc M Subsetrefl

>>       line2: [(---:that (Sc(M) <<= Sc(M)))]
>>         {move 2}



      open

         declare u obj

>>          u: obj {move 4}



         open

            declare usinev that u E Sc M


>>             usinev: that (u E Sc(M)) {move
>>               5}



            define line3 : Fixform (Isset(prime \
               u),Separation3(Refleq prime \
               u))

>>             line3: [(---:that Isset(prime(u)))]
>>               {move 4}


\end{verbatim}

Note the devious use of {\tt Separation3} to avoid having to write out the defining predicate of the prime operation.  The use of the axiom
{\tt Separation2} is essential:  the result of applying the prime operation might be empty, and we do want it to be a set.


\begin{verbatim}Lestrade execution:


            define line4 usinev: Simp1(Simp2(Iff1(usinev, \
               Ui u (Scthm M))))

>>             line4: [(usinev_1:that (u E Sc(M)))
>>                  => (---:that Isset(u))]
>>               {move 4}



            open

               declare v obj

>>                v: obj {move 6}



               open

                  declare vinev that v E \
                     prime u

>>                   vinev: that (v E prime(u))
>>                     {move 7}



                  define line5 : Ui v primeax( \
                     Iff1(usinev, Ui u Scthm \
                     M))

>>                   line5: [(---:that ((v E
>>                        prime(u)) == ((v E u)
>>                        & ~((v = thelaw(u))))))]
>>                     {move 6}



                  define line6 vinev: Simp1(Iff1(vinev, \
                     line5))

>>                   line6: [(vinev_1:that (v
>>                        E prime(u))) => (---:
>>                        that (v E u))]
>>                     {move 6}



                  define line7 vinev: Mp \
                     line6 vinev (Ui v Simp1(Iff1(usinev, \
                     Ui u Scthm M)))

>>                   line7: [(vinev_1:that (v
>>                        E prime(u))) => (---:
>>                        that (v E M))]
>>                     {move 6}



                  close

               define line8 v: Ded line7


>>                line8: [(v_1:obj) => (---:
>>                     that ((v_1 E prime(u))
>>                     -> (v_1 E M)))]
>>                  {move 5}



               close

            define line9 usinev: Ug line8


>>             line9: [(usinev_1:that (u E Sc(M)))
>>                  => (---:that Forall([(v_10:
>>                     obj) => (((v_10 E prime(u))
>>                     -> (v_10 E M)):prop)]))
>>                  ]
>>               {move 4}



            define line10 usinev: Fixform((prime \
               u) <<= M,Conj(line9 usinev,Conj(line3, \
               Misset)))

>>             line10: [(usinev_1:that (u E
>>                  Sc(M))) => (---:that (prime(u)
>>                  <<= M))]
>>               {move 4}



            define line11 usinev: Iff2(line10 \
               usinev, Ui(prime \
               u, Scthm M))

>>             line11: [(usinev_1:that (u E
>>                  Sc(M))) => (---:that (prime(u)
>>                  E Sc(M)))]
>>               {move 4}



            close

         define line12 u: Ded line11

>>          line12: [(u_1:obj) => (---:that
>>               ((u_1 E Sc(M)) -> (prime(u_1)
>>               E Sc(M))))]
>>            {move 3}



         close

      define line13 : Ug line12

>>       line13: [(---:that Forall([(u_14:obj)
>>               => (((u_14 E Sc(M)) -> (prime(u_14)
>>               E Sc(M))):prop)]))
>>            ]
>>         {move 2}



      open

         declare u obj

>>          u: obj {move 4}



         open

            declare v obj

>>             v: obj {move 5}



            open

               declare hyp that (u <<= Sc \
                  M) & v E u

>>                hyp: that ((u <<= Sc(M)) &
>>                  (v E u)) {move 6}



               define line14 hyp: Simp2 hyp \
                  Mp Intax u v

>>                line14: [(hyp_1:that ((u <<=
>>                     Sc(M)) & (v E u))) => (---:
>>                     that Forall([(u_4:obj)
>>                        => (((u_4 E (u Intersection
>>                        v)) == Forall([(B1_5:
>>                           obj) => (((B1_5 E
>>                           u) -> (u_4 E B1_5)):
>>                           prop)]))
>>                        :prop)]))
>>                     ]
>>                  {move 5}



               open

                  declare w obj

>>                   w: obj {move 7}



                  open

                     declare hyp2 that w \
                        E Intersection u v


>>                      hyp2: that (w E (u Intersection
>>                        v)) {move 8}



                     define line15 hyp2:Mp \
                        (Simp2 hyp,Ui v(Iff1(hyp2, \
                        Ui w line14 hyp)))


>>                      line15: [(hyp2_1:that
>>                           (w E (u Intersection
>>                           v))) => (---:that
>>                           (w E v))]
>>                        {move 7}



                     define line16 : Mp(Simp2 \
                        hyp,Ui v Simp1(Simp1 \
                        hyp))

>>                      line16: [(---:that (v
>>                           E Sc(M)))]
>>                        {move 7}



                     define line17 : Iff1(line16, \
                        Ui v Scthm M)

>>                      line17: [(---:that (v
>>                           <<= M))]
>>                        {move 7}



                     define line18 hyp2: \
                        Mp(line15 hyp2,Ui w \
                        Simp1 line17)

>>                      line18: [(hyp2_1:that
>>                           (w E (u Intersection
>>                           v))) => (---:that
>>                           (w E M))]
>>                        {move 7}



                     close

                  define line19 w: Ded line18


>>                   line19: [(w_1:obj) => (---:
>>                        that ((w_1 E (u Intersection
>>                        v)) -> (w_1 E M)))]
>>                     {move 6}



                  close

               define line20 hyp : Ug line19


>>                line20: [(hyp_1:that ((u <<=
>>                     Sc(M)) & (v E u))) => (---:
>>                     that Forall([(w_14:obj)
>>                        => (((w_14 E (u Intersection
>>                        v)) -> (w_14 E M)):prop)]))
>>                     ]
>>                  {move 5}



               define line21 : Fixform(Isset(Intersection \
                  u v),Separation3 (Refleq(Intersection \
                  u v)))

>>                line21: [(---:that Isset((u
>>                     Intersection v)))]
>>                  {move 5}



               define line22 hyp: Fixform((Intersection \
                  u v)<<= M,Conj(line20 hyp, \
                  Conj(line21, Misset)))

>>                line22: [(hyp_1:that ((u <<=
>>                     Sc(M)) & (v E u))) => (---:
>>                     that ((u Intersection v)
>>                     <<= M))]
>>                  {move 5}



               define line23 hyp: Iff2(line22 \
                  hyp,Ui (Intersection u v, \
                  Scthm M))

>>                line23: [(hyp_1:that ((u <<=
>>                     Sc(M)) & (v E u))) => (---:
>>                     that ((u Intersection v)
>>                     E Sc(M)))]
>>                  {move 5}



               close

            define line24 v: Ded line23

>>             line24: [(v_1:obj) => (---:that
>>                  (((u <<= Sc(M)) & (v_1 E u))
>>                  -> ((u Intersection v_1) E
>>                  Sc(M))))]
>>               {move 4}



            close

         define line25 u: Ug line24

>>          line25: [(u_1:obj) => (---:that
>>               Forall([(v_23:obj) => ((((u_1
>>                  <<= Sc(M)) & (v_23 E u_1))
>>                  -> ((u_1 Intersection v_23)
>>                  E Sc(M))):prop)]))
>>               ]
>>            {move 3}



         close

      define line26: Ug line25

>>       line26: [(---:that Forall([(u_24:obj)
>>               => (Forall([(v_25:obj) => ((((u_24
>>                  <<= Sc(M)) & (v_25 E u_24))
>>                  -> ((u_24 Intersection v_25)
>>                  E Sc(M))):prop)])
>>               :prop)]))
>>            ]
>>         {move 2}



      close

   define thetascm1 : Fixform(thetachain \
      (Sc M),Conj(line1,Conj(line2,Conj(line13, \
      line26))))

>>    thetascm1: [(---:that thetachain(Sc(M)))]
>>      {move 1}



   close

define thetascm2 Misset thelawchooses: thetascm1


>> thetascm2: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))])
>>      => ((thetachain1(.M_1,.thelaw_1,Sc(.M_1))
>>      Fixform ((Misset_1 Mp (.M_1 Ui Inownpowerset))
>>      Conj (((Misset_1 Mp (.M_1 Ui Scofsetisset))
>>      Mp (Sc(.M_1) Ui Subsetrefl)) Conj (Ug([(u_16:
>>         obj) => (Ded([(usinev_17:that (u_16
>>            E Sc(.M_1))) => ((((prime2(.thelaw_1,
>>            u_16) <<= .M_1) Fixform (Ug([(v_20:
>>               obj) => (Ded([(vinev_21:that
>>                  (v_20 E prime2(.thelaw_1,u_16)))
>>                  => ((Simp1((vinev_21 Iff1
>>                  (v_20 Ui Ug([(u_24:obj) =>
>>                     (Dediff([(hyp1_25:that
>>                        (u_24 E prime2(.thelaw_1,
>>                        u_16))) => ((Simp1((hyp1_25
>>                        Iff1 (u_24 Ui (u_16
>>                        Compax Usc(.thelaw_1(u_16))))))
>>                        Conj Negintro([(hyp3_27:
>>                           that (u_24 = .thelaw_1(u_16)))
>>                           => ((Subs(Eqsymm(hyp3_27),
>>                           [(v_28:obj) => ((v_28
>>                              E Usc(.thelaw_1(u_16))):
>>                              prop)]
>>                           ,Inusc2(.thelaw_1(u_16)))
>>                           Mp Simp2((hyp1_25
>>                           Iff1 (u_24 Ui (u_16
>>                           Compax Usc(.thelaw_1(u_16))))))):
>>                           that ??)]))
>>                        :that ((u_24 E u_16)
>>                        & ~((u_24 = .thelaw_1(u_16)))))]
>>                     ,[(hyp2_30:that ((u_24
>>                        E u_16) & ~((u_24 =
>>                        .thelaw_1(u_16)))))
>>                        => (((Simp1(hyp2_30)
>>                        Conj Negintro([(hyp4_31:
>>                           that (u_24 E Usc(.thelaw_1(u_16))))
>>                           => ((Inusc1(hyp4_31)
>>                           Mp Simp2(hyp2_30)):
>>                           that ??)]))
>>                        Iff2 (u_24 Ui (u_16
>>                        Compax Usc(.thelaw_1(u_16))))):
>>                        that (u_24 E (u_16 Complement
>>                        Usc(.thelaw_1(u_16)))))])
>>                     :that ((u_24 E prime2(.thelaw_1,
>>                     u_16)) == ((u_24 E u_16)
>>                     & ~((u_24 = .thelaw_1(u_16))))))]))
>>                  )) Mp (v_20 Ui Simp1((usinev_17
>>                  Iff1 (u_16 Ui Scthm(.M_1)))))):
>>                  that (v_20 E .M_1))])
>>               :that ((v_20 E prime2(.thelaw_1,
>>               u_16)) -> (v_20 E .M_1)))])
>>            Conj ((Isset(prime2(.thelaw_1,u_16))
>>            Fixform Separation3(Refleq(prime2(.thelaw_1,
>>            u_16)))) Conj Misset_1))) Iff2 (prime2(.thelaw_1,
>>            u_16) Ui Scthm(.M_1))):that (prime2(.thelaw_1,
>>            u_16) E Sc(.M_1)))])
>>         :that ((u_16 E Sc(.M_1)) -> (prime2(.thelaw_1,
>>         u_16) E Sc(.M_1))))])
>>      Conj Ug([(u_42:obj) => (Ug([(v_44:obj)
>>            => (Ded([(hyp_45:that ((u_42 <<=
>>               Sc(.M_1)) & (v_44 E u_42))) =>
>>               (((((u_42 Intersection v_44)
>>               <<= .M_1) Fixform (Ug([(w_48:
>>                  obj) => (Ded([(hyp2_49:that
>>                     (w_48 E (u_42 Intersection
>>                     v_44))) => (((Simp2(hyp_45)
>>                     Mp (v_44 Ui (hyp2_49 Iff1
>>                     (w_48 Ui (Simp2(hyp_45)
>>                     Mp (u_42 Intax v_44))))))
>>                     Mp (w_48 Ui Simp1(((Simp2(hyp_45)
>>                     Mp (v_44 Ui Simp1(Simp1(hyp_45))))
>>                     Iff1 (v_44 Ui Scthm(.M_1)))))):
>>                     that (w_48 E .M_1))])
>>                  :that ((w_48 E (u_42 Intersection
>>                  v_44)) -> (w_48 E .M_1)))])
>>               Conj ((Isset((u_42 Intersection
>>               v_44)) Fixform Separation3(Refleq((u_42
>>               Intersection v_44)))) Conj Misset_1)))
>>               Iff2 ((u_42 Intersection v_44)
>>               Ui Scthm(.M_1))):that ((u_42
>>               Intersection v_44) E Sc(.M_1)))])
>>            :that (((u_42 <<= Sc(.M_1)) & (v_44
>>            E u_42)) -> ((u_42 Intersection
>>            v_44) E Sc(.M_1))))])
>>         :that Forall([(v_64:obj) => ((((u_42
>>            <<= Sc(.M_1)) & (v_64 E u_42)) ->
>>            ((u_42 Intersection v_64) E Sc(.M_1))):
>>            prop)]))
>>         ]))
>>      ))):that thetachain1(.M_1,.thelaw_1,Sc(.M_1)))]
>>   {move 0}



open

   define thetascm: thetascm2 Misset thelawchooses


>>    thetascm: [(---:that thetachain1(M,thelaw,
>>         Sc(M)))]
>>      {move 1}


\end{verbatim}

Here we have proved that ${\cal P}(M)$ is a $\Theta$-chain.


\begin{verbatim}Lestrade execution:

     clearcurrent


   define Thetachain : Set ((Sc(Sc M)), thetachain)


>>    Thetachain: [(---:obj)]
>>      {move 1}



   open

      declare C obj

>>       C: obj {move 3}



      open

         declare hyp1 that thetachain C

>>          hyp1: that thetachain(C) {move 4}



         declare hyp2 that C E Thetachain


>>          hyp2: that (C E Thetachain) {move
>>            4}



         define line1 hyp1: Iff2(Simp1(Simp2 \
            hyp1),Ui C Scthm Sc M)

>>          line1: [(hyp1_1:that thetachain(C))
>>               => (---:that (C E Sc(Sc(M))))]
>>            {move 3}



         define line2 hyp1: Fixform(C E Thetachain, \
            Iff2(Conj(line1 hyp1,hyp1),Ui(C, \
            Separation ((Sc(Sc M)) ,thetachain))))


>>          line2: [(hyp1_1:that thetachain(C))
>>               => (---:that (C E Thetachain))]
>>            {move 3}



         define line3 hyp2: Simp2(Iff1(hyp2, \
            Ui(C,Separation ((Sc(Sc M)),thetachain))))


>>          line3: [(hyp2_1:that (C E Thetachain))
>>               => (---:that thetachain(C))]
>>            {move 3}



         close

      define line4 C: Dediff line3, line2


>>       line4: [(C_1:obj) => (---:that ((C_1
>>            E Thetachain) == thetachain(C_1)))]
>>         {move 2}



      close

   define Thetachainax: Ug line4

>>    Thetachainax: [(---:that Forall([(C_13:
>>            obj) => (((C_13 E Thetachain) ==
>>            thetachain(C_13)):prop)]))
>>         ]
>>      {move 1}


\end{verbatim}

We prove that the collection of all $\Theta$-chains is a set, and in particular a subset of ${\cal P}^2(M)$.

We now define the $\Theta$-chain which implements the desired well-ordering (though we have to verify subsequently that that is what it is).

\begin{verbatim}Lestrade execution:


   define Mbold1 : Intersection Thetachain \
      Sc M

>>    Mbold1: [(---:obj)]
>>      {move 1}



   close

define Mbold2 Misset thelawchooses:Mbold1


>> Mbold2: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))])
>>      => (((Sc(Sc(.M_1)) Set [(C_5:obj) => (thetachain1(.M_1,
>>         .thelaw_1,C_5):prop)])
>>      Intersection Sc(.M_1)):obj)]
>>   {move 0}



open

   define Mbold: Mbold2 Misset thelawchooses


>>    Mbold: [(---:obj)]
>>      {move 1}


\end{verbatim}

We now have the tedious task of directly verifying that {\bf M} is a $\Theta$-chain, which Zermelo dismisses as a side remark!

We note that Zermelo's text suggests that we should prove that any intersection of $\Theta$-chains is a $\Theta$-chain, but it appears that the only case
of this we need is that  {\bf M} itself is a $\Theta$-chain.


\begin{verbatim}Lestrade execution:

     clearcurrent


   declare C obj

>>    C: obj {move 2}



   declare D obj

>>    D: obj {move 2}



   open

      define Mboldax1: Intax Thetachain Sc \
         M

>>       Mboldax1: [(---:that ((Sc(M) E Thetachain)
>>            -> Forall([(u_1:obj) => (((u_1 E
>>               (Thetachain Intersection Sc(M)))
>>               == Forall([(B1_2:obj) => (((B1_2
>>                  E Thetachain) -> (u_1 E B1_2)):
>>                  prop)]))
>>               :prop)]))
>>            )]
>>         {move 2}



      define line1: Ui Sc M Thetachainax


>>       line1: [(---:that ((Sc(M) E Thetachain)
>>            == thetachain(Sc(M))))]
>>         {move 2}



      define line2: Iff2 thetascm line1

>>       line2: [(---:that (Sc(M) E Thetachain))]
>>         {move 2}



      close

   define Mboldax : Fixform(Forall [C=> (C \
         E Mbold) == Forall[D=>(D \
            E Thetachain) -> C \
            E D] \
         ] \
      , Mp line2 Mboldax1)

>>    Mboldax: [(---:that Forall([(C_5:obj)
>>            => (((C_5 E Mbold) == Forall([(D_6:
>>               obj) => (((D_6 E Thetachain)
>>               -> (C_5 E D_6)):prop)]))
>>            :prop)]))
>>         ]
>>      {move 1}


\end{verbatim}

above, we develop the most convenient definition of the extension of {\bf M}.

\begin{verbatim}Lestrade execution:

     clearcurrent


   open

      declare F obj

>>       F: obj {move 3}



      open

         declare ftheta that F E Thetachain


>>          ftheta: that (F E Thetachain) {move
>>            4}



         define line1 ftheta: Iff1(ftheta, \
            Ui F Thetachainax)

>>          line1: [(ftheta_1:that (F E Thetachain))
>>               => (---:that thetachain(F))]
>>            {move 3}



         define line2 ftheta: Simp1 line1 \
            ftheta

>>          line2: [(ftheta_1:that (F E Thetachain))
>>               => (---:that (M E F))]
>>            {move 3}



         close

      define Linea1 F: Ded line2

>>       Linea1: [(F_1:obj) => (---:that ((F_1
>>            E Thetachain) -> (M E F_1)))]
>>         {move 2}



      close

   define Lineb1: Ug Linea1

>>    Lineb1: [(---:that Forall([(F_7:obj) =>
>>            (((F_7 E Thetachain) -> (M E F_7)):
>>            prop)]))
>>         ]
>>      {move 1}



   define Line1 : Iff2(Lineb1,Ui M Mboldax)


>>    Line1: [(---:that (M E Mbold))]
>>      {move 1}


          clearcurrent


   open

      open

         declare A obj

>>          A: obj {move 4}



         open

            declare ainev that A E Mbold


>>             ainev: that (A E Mbold) {move
>>               5}



            define line1 ainev: Mp (Iff2(thetascm, \
               Ui Sc M Thetachainax), \
               Ui Sc M, Iff1(ainev, Ui A Mboldax))


>>             line1: [(ainev_1:that (A E Mbold))
>>                  => (---:that (A E Sc(M)))]
>>               {move 4}



            close

         define line2 A: Ded line1

>>          line2: [(A_1:obj) => (---:that ((A_1
>>               E Mbold) -> (A_1 E Sc(M))))]
>>            {move 3}



         close

      define Line3 : Ug line2

>>       Line3: [(---:that Forall([(A_8:obj)
>>               => (((A_8 E Mbold) -> (A_8 E
>>               Sc(M))):prop)]))
>>            ]
>>         {move 2}



      close

   define Line4 : Fixform((Mbold)<<= Sc M, \
      Conj(Line3,Conj(Inhabited Line1, Sc2 \
      M)))

>>    Line4: [(---:that (Mbold <<= Sc(M)))]
>>      {move 1}


          clearcurrent


   open

      declare F obj

>>       F: obj {move 3}



      open

         declare finmbold that F E (Mbold)


>>          finmbold: that (F E Mbold) {move
>>            4}



         open

            declare G obj

>>             G: obj {move 5}



            open

               declare gtheta that G E Thetachain


>>                gtheta: that (G E Thetachain)
>>                  {move 6}



               define line1 gtheta: Ui( F, \
                  Simp1 Simp2 Simp2 Iff1(gtheta, \
                  Ui G Thetachainax))

>>                line1: [(gtheta_1:that (G
>>                     E Thetachain)) => (---:
>>                     that ((F E G) -> (prime2(thelaw,
>>                     F) E G)))]
>>                  {move 5}



               define line2 gtheta: Mp (gtheta, \
                  Ui (G, Iff1(finmbold, Ui \
                  F Mboldax)))

>>                line2: [(gtheta_1:that (G
>>                     E Thetachain)) => (---:
>>                     that (F E G))]
>>                  {move 5}



               define line3 gtheta : Mp line2 \
                  gtheta line1 gtheta

>>                line3: [(gtheta_1:that (G
>>                     E Thetachain)) => (---:
>>                     that (prime2(thelaw,F)
>>                     E G))]
>>                  {move 5}



               close

            define line4 G : Ded line3

>>             line4: [(G_1:obj) => (---:that
>>                  ((G_1 E Thetachain) -> (prime2(thelaw,
>>                  F) E G_1)))]
>>               {move 4}



            close

         define line5 finmbold: Ug line4


>>          line5: [(finmbold_1:that (F E Mbold))
>>               => (---:that Forall([(G_20:obj)
>>                  => (((G_20 E Thetachain) ->
>>                  (prime2(thelaw,F) E G_20)):
>>                  prop)]))
>>               ]
>>            {move 3}



         define line6 finmbold: Iff2(line5 \
            finmbold, Ui(prime F,Mboldax))


>>          line6: [(finmbold_1:that (F E Mbold))
>>               => (---:that (prime(F) E Mbold))]
>>            {move 3}



         close

      define line7 F: Ded line6

>>       line7: [(F_1:obj) => (---:that ((F_1
>>            E Mbold) -> (prime(F_1) E Mbold)))]
>>         {move 2}



      close

   define Linea8 : Ug line7

>>    Linea8: [(---:that Forall([(F_24:obj)
>>            => (((F_24 E Mbold) -> (prime(F_24)
>>            E Mbold)):prop)]))
>>         ]
>>      {move 1}



   save

   close

define Lineb8 Misset thelawchooses: Linea8


>> Lineb8: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))])
>>      => (Ug([(F_6:obj) => (Ded([(finmbold_7:
>>            that (F_6 E (Misset_1 Mbold2 thelawchooses_1)))
>>            => ((Ug([(G_12:obj) => (Ded([(gtheta_14:
>>                  that (G_12 E (Sc(Sc(.M_1))
>>                  Set [(C_15:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_15):prop)]))
>>                  ) => (((gtheta_14 Mp (G_12
>>                  Ui (finmbold_7 Iff1 (F_6 Ui
>>                  (Forall([(C_24:obj) => (((C_24
>>                     E (Misset_1 Mbold2 thelawchooses_1))
>>                     == Forall([(D_25:obj) =>
>>                        (((D_25 E (Sc(Sc(.M_1))
>>                        Set [(C_26:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_26):prop)]))
>>                        -> (C_24 E D_25)):prop)]))
>>                     :prop)])
>>                  Fixform (((Misset_1 thetascm2
>>                  thelawchooses_1) Iff2 (Sc(.M_1)
>>                  Ui Ug([(C_33:obj) => (Dediff([(hyp2_35:
>>                        that (C_33 E (Sc(Sc(.M_1))
>>                        Set [(C_36:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_36):prop)]))
>>                        ) => (Simp2((hyp2_35
>>                        Iff1 (C_33 Ui (Sc(Sc(.M_1))
>>                        Separation [(C_40:obj)
>>                           => (thetachain1(.M_1,
>>                           .thelaw_1,C_40):prop)]))
>>                        )):that thetachain1(.M_1,
>>                        .thelaw_1,C_33))]
>>                     ,[(hyp1_41:that thetachain1(.M_1,
>>                        .thelaw_1,C_33)) =>
>>                        (((C_33 E (Sc(Sc(.M_1))
>>                        Set [(C_42:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_42):prop)]))
>>                        Fixform (((Simp1(Simp2(hyp1_41))
>>                        Iff2 (C_33 Ui Scthm(Sc(.M_1))))
>>                        Conj hyp1_41) Iff2 (C_33
>>                        Ui (Sc(Sc(.M_1)) Separation
>>                        [(C_53:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_53):prop)]))
>>                        )):that (C_33 E (Sc(Sc(.M_1))
>>                        Set [(C_54:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_54):prop)]))
>>                        )])
>>                     :that ((C_33 E (Sc(Sc(.M_1))
>>                     Set [(C_55:obj) => (thetachain1(.M_1,
>>                        .thelaw_1,C_55):prop)]))
>>                     == thetachain1(.M_1,.thelaw_1,
>>                     C_33)))]))
>>                  ) Mp ((Sc(Sc(.M_1)) Set [(C_60:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_60):prop)])
>>                  Intax Sc(.M_1)))))))) Mp (F_6
>>                  Ui Simp1(Simp2(Simp2((gtheta_14
>>                  Iff1 (G_12 Ui Ug([(C_76:obj)
>>                     => (Dediff([(hyp2_78:that
>>                        (C_76 E (Sc(Sc(.M_1))
>>                        Set [(C_79:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_79):prop)]))
>>                        ) => (Simp2((hyp2_78
>>                        Iff1 (C_76 Ui (Sc(Sc(.M_1))
>>                        Separation [(C_83:obj)
>>                           => (thetachain1(.M_1,
>>                           .thelaw_1,C_83):prop)]))
>>                        )):that thetachain1(.M_1,
>>                        .thelaw_1,C_76))]
>>                     ,[(hyp1_84:that thetachain1(.M_1,
>>                        .thelaw_1,C_76)) =>
>>                        (((C_76 E (Sc(Sc(.M_1))
>>                        Set [(C_85:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_85):prop)]))
>>                        Fixform (((Simp1(Simp2(hyp1_84))
>>                        Iff2 (C_76 Ui Scthm(Sc(.M_1))))
>>                        Conj hyp1_84) Iff2 (C_76
>>                        Ui (Sc(Sc(.M_1)) Separation
>>                        [(C_96:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_96):prop)]))
>>                        )):that (C_76 E (Sc(Sc(.M_1))
>>                        Set [(C_97:obj) => (thetachain1(.M_1,
>>                           .thelaw_1,C_97):prop)]))
>>                        )])
>>                     :that ((C_76 E (Sc(Sc(.M_1))
>>                     Set [(C_98:obj) => (thetachain1(.M_1,
>>                        .thelaw_1,C_98):prop)]))
>>                     == thetachain1(.M_1,.thelaw_1,
>>                     C_76)))]))
>>                  )))))):that (prime2(.thelaw_1,
>>                  F_6) E G_12))])
>>               :that ((G_12 E (Sc(Sc(.M_1))
>>               Set [(C_99:obj) => (thetachain1(.M_1,
>>                  .thelaw_1,C_99):prop)]))
>>               -> (prime2(.thelaw_1,F_6) E G_12)))])
>>            Iff2 (prime2(.thelaw_1,F_6) Ui (Forall([(C_103:
>>               obj) => (((C_103 E (Misset_1
>>               Mbold2 thelawchooses_1)) == Forall([(D_104:
>>                  obj) => (((D_104 E (Sc(Sc(.M_1))
>>                  Set [(C_105:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_105):prop)]))
>>                  -> (C_103 E D_104)):prop)]))
>>               :prop)])
>>            Fixform (((Misset_1 thetascm2 thelawchooses_1)
>>            Iff2 (Sc(.M_1) Ui Ug([(C_112:obj)
>>               => (Dediff([(hyp2_114:that (C_112
>>                  E (Sc(Sc(.M_1)) Set [(C_115:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_115):prop)]))
>>                  ) => (Simp2((hyp2_114 Iff1
>>                  (C_112 Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_119:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_119):prop)]))
>>                  )):that thetachain1(.M_1,.thelaw_1,
>>                  C_112))]
>>               ,[(hyp1_120:that thetachain1(.M_1,
>>                  .thelaw_1,C_112)) => (((C_112
>>                  E (Sc(Sc(.M_1)) Set [(C_121:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_121):prop)]))
>>                  Fixform (((Simp1(Simp2(hyp1_120))
>>                  Iff2 (C_112 Ui Scthm(Sc(.M_1))))
>>                  Conj hyp1_120) Iff2 (C_112
>>                  Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_132:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_132):prop)]))
>>                  )):that (C_112 E (Sc(Sc(.M_1))
>>                  Set [(C_133:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_133):prop)]))
>>                  )])
>>               :that ((C_112 E (Sc(Sc(.M_1))
>>               Set [(C_134:obj) => (thetachain1(.M_1,
>>                  .thelaw_1,C_134):prop)]))
>>               == thetachain1(.M_1,.thelaw_1,
>>               C_112)))]))
>>            ) Mp ((Sc(Sc(.M_1)) Set [(C_139:
>>               obj) => (thetachain1(.M_1,.thelaw_1,
>>               C_139):prop)])
>>            Intax Sc(.M_1)))))):that (prime2(.thelaw_1,
>>            F_6) E (Misset_1 Mbold2 thelawchooses_1)))])
>>         :that ((F_6 E (Misset_1 Mbold2 thelawchooses_1))
>>         -> (prime2(.thelaw_1,F_6) E (Misset_1
>>         Mbold2 thelawchooses_1))))])
>>      :that Forall([(F_140:obj) => (((F_140
>>         E (Misset_1 Mbold2 thelawchooses_1))
>>         -> (prime2(.thelaw_1,F_140) E (Misset_1
>>         Mbold2 thelawchooses_1))):prop)]))
>>      ]
>>   {move 0}



open

   define Line8: Lineb8 Misset thelawchooses


>>    Line8: [(---:that Forall([(F_1:obj) =>
>>            (((F_1 E (Misset Mbold2 thelawchooses))
>>            -> (prime2(thelaw,F_1) E (Misset
>>            Mbold2 thelawchooses))):prop)]))
>>         ]
>>      {move 1}



   open

      declare H obj

>>       H: obj {move 3}



      open

         declare J obj

>>          J: obj {move 4}



         open

            declare thehyp that (H <<= Mbold) \
               & J E H

>>             thehyp: that ((H <<= Mbold) &
>>               (J E H)) {move 5}



            open

               declare K obj

>>                K: obj {move 6}



               open

                  declare ktheta that \
                     K E Thetachain

>>                   ktheta: that (K E Thetachain)
>>                     {move 7}



                  define line1 ktheta: Iff1(ktheta, \
                     Ui K Thetachainax)

>>                   line1: [(ktheta_1:that
>>                        (K E Thetachain)) =>
>>                        (---:that thetachain(K))]
>>                     {move 6}



                  define line2 ktheta: Ui \
                     J, Ui H,Simp2 Simp2 Simp2 \
                     line1 ktheta

>>                   line2: [(ktheta_1:that
>>                        (K E Thetachain)) =>
>>                        (---:that (((H <<= K)
>>                        & (J E H)) -> ((H Intersection
>>                        J) E K)))]
>>                     {move 6}



                  open

                     declare P obj

>>                      P: obj {move 8}



                     open

                        declare phyp that \
                           P E H

>>                         phyp: that (P E H)
>>                           {move 9}



                        define line3 phyp: \
                           Mp(phyp, Ui P Simp1 \
                           Simp1 thehyp)

>>                         line3: [(phyp_1:that
>>                              (P E H)) => (---:
>>                              that (P E Mbold))]
>>                           {move 8}



                        define line4 phyp: \
                           Mp(ktheta,K Ui Iff1 \
                           line3 phyp, Ui P \
                           Mboldax)

>>                         line4: [(phyp_1:that
>>                              (P E H)) => (---:
>>                              that (P E K))]
>>                           {move 8}



                        close

                     define line5 P :Ded \
                        line4

>>                      line5: [(P_1:obj) =>
>>                           (---:that ((P_1 E
>>                           H) -> (P_1 E K)))]
>>                        {move 7}



                     close

                  define test1 ktheta: Ug \
                     line5

>>                   test1: [(ktheta_1:that
>>                        (K E Thetachain)) =>
>>                        (---:that Forall([(P_11:
>>                           obj) => (((P_11 E
>>                           H) -> (P_11 E K)):
>>                           prop)]))
>>                        ]
>>                     {move 6}



                  define test2 ktheta: Inhabited \
                     Simp2 thehyp

>>                   test2: [(ktheta_1:that
>>                        (K E Thetachain)) =>
>>                        (---:that Isset(H))]
>>                     {move 6}



                  define test3 ktheta: Inhabited(Mp(Simp2 \
                     thehyp, line5 J))

>>                   test3: [(ktheta_1:that
>>                        (K E Thetachain)) =>
>>                        (---:that Isset(K))]
>>                     {move 6}



                  define line6 ktheta \
                     : Fixform(H <<= K,Conj(test1 \
                     ktheta,Conj(test2 ktheta, \
                     test3 ktheta)))

>>                   line6: [(ktheta_1:that
>>                        (K E Thetachain)) =>
>>                        (---:that (H <<= K))]
>>                     {move 6}



                  define linea7 ktheta: Mp(Conj(line6 \
                     ktheta, Simp2 thehyp), \
                     line2 ktheta)

>>                   linea7: [(ktheta_1:that
>>                        (K E Thetachain)) =>
>>                        (---:that ((H Intersection
>>                        J) E K))]
>>                     {move 6}



                  close

               define line8 K: Ded linea7


>>                line8: [(K_1:obj) => (---:
>>                     that ((K_1 E Thetachain)
>>                     -> ((H Intersection J)
>>                     E K_1)))]
>>                  {move 5}



               close

            define line9 thehyp: Ug line8


>>             line9: [(thehyp_1:that ((H <<=
>>                  Mbold) & (J E H))) => (---:
>>                  that Forall([(K_35:obj) =>
>>                     (((K_35 E Thetachain) ->
>>                     ((H Intersection J) E K_35)):
>>                     prop)]))
>>                  ]
>>               {move 4}



            define line10: Ui (H Intersection \
               J, Mboldax)

>>             line10: [(---:that (((H Intersection
>>                  J) E Mbold) == Forall([(D_3:
>>                     obj) => (((D_3 E Thetachain)
>>                     -> ((H Intersection J)
>>                     E D_3)):prop)]))
>>                  )]
>>               {move 4}



            define line11 thehyp: Iff2(line9 \
               thehyp, line10)

>>             line11: [(thehyp_1:that ((H <<=
>>                  Mbold) & (J E H))) => (---:
>>                  that ((H Intersection J) E
>>                  Mbold))]
>>               {move 4}



            close

         define line12 J: Ded line11

>>          line12: [(J_1:obj) => (---:that
>>               (((H <<= Mbold) & (J_1 E H))
>>               -> ((H Intersection J_1) E Mbold)))]
>>            {move 3}



         close

      define line13 H: Ug line12

>>       line13: [(H_1:obj) => (---:that Forall([(J_41:
>>               obj) => ((((H_1 <<= Mbold) &
>>               (J_41 E H_1)) -> ((H_1 Intersection
>>               J_41) E Mbold)):prop)]))
>>            ]
>>         {move 2}



      close

   define Linea14: Ug line13

>>    Linea14: [(---:that Forall([(H_42:obj)
>>            => (Forall([(J_43:obj) => ((((H_42
>>               <<= Mbold) & (J_43 E H_42)) ->
>>               ((H_42 Intersection J_43) E Mbold)):
>>               prop)])
>>            :prop)]))
>>         ]
>>      {move 1}



   save

   close

define Lineb14 Misset thelawchooses:Linea14


>> Lineb14: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))])
>>      => (Ug([(H_7:obj) => (Ug([(J_9:obj) =>
>>            (Ded([(thehyp_10:that ((H_7 <<=
>>               (Misset_1 Mbold2 thelawchooses_1))
>>               & (J_9 E H_7))) => ((Ug([(K_15:
>>                  obj) => (Ded([(ktheta_17:that
>>                     (K_15 E (Sc(Sc(.M_1)) Set
>>                     [(C_18:obj) => (thetachain1(.M_1,
>>                        .thelaw_1,C_18):prop)]))
>>                     ) => (((((H_7 <<= K_15)
>>                     Fixform (Ug([(P_21:obj)
>>                        => (Ded([(phyp_22:that
>>                           (P_21 E H_7)) =>
>>                           ((ktheta_17 Mp (K_15
>>                           Ui ((phyp_22 Mp (P_21
>>                           Ui Simp1(Simp1(thehyp_10))))
>>                           Iff1 (P_21 Ui (Forall([(C_33:
>>                              obj) => (((C_33
>>                              E (Misset_1 Mbold2
>>                              thelawchooses_1))
>>                              == Forall([(D_34:
>>                                 obj) => (((D_34
>>                                 E (Sc(Sc(.M_1))
>>                                 Set [(C_35:
>>                                    obj) =>
>>                                    (thetachain1(.M_1,
>>                                    .thelaw_1,
>>                                    C_35):prop)]))
>>                                 -> (C_33 E
>>                                 D_34)):prop)]))
>>                              :prop)])
>>                           Fixform (((Misset_1
>>                           thetascm2 thelawchooses_1)
>>                           Iff2 (Sc(.M_1) Ui
>>                           Ug([(C_42:obj) =>
>>                              (Dediff([(hyp2_44:
>>                                 that (C_42
>>                                 E (Sc(Sc(.M_1))
>>                                 Set [(C_45:
>>                                    obj) =>
>>                                    (thetachain1(.M_1,
>>                                    .thelaw_1,
>>                                    C_45):prop)]))
>>                                 ) => (Simp2((hyp2_44
>>                                 Iff1 (C_42
>>                                 Ui (Sc(Sc(.M_1))
>>                                 Separation
>>                                 [(C_49:obj)
>>                                    => (thetachain1(.M_1,
>>                                    .thelaw_1,
>>                                    C_49):prop)]))
>>                                 )):that thetachain1(.M_1,
>>                                 .thelaw_1,C_42))]
>>                              ,[(hyp1_50:that
>>                                 thetachain1(.M_1,
>>                                 .thelaw_1,C_42))
>>                                 => (((C_42
>>                                 E (Sc(Sc(.M_1))
>>                                 Set [(C_51:
>>                                    obj) =>
>>                                    (thetachain1(.M_1,
>>                                    .thelaw_1,
>>                                    C_51):prop)]))
>>                                 Fixform (((Simp1(Simp2(hyp1_50))
>>                                 Iff2 (C_42
>>                                 Ui Scthm(Sc(.M_1))))
>>                                 Conj hyp1_50)
>>                                 Iff2 (C_42
>>                                 Ui (Sc(Sc(.M_1))
>>                                 Separation
>>                                 [(C_62:obj)
>>                                    => (thetachain1(.M_1,
>>                                    .thelaw_1,
>>                                    C_62):prop)]))
>>                                 )):that (C_42
>>                                 E (Sc(Sc(.M_1))
>>                                 Set [(C_63:
>>                                    obj) =>
>>                                    (thetachain1(.M_1,
>>                                    .thelaw_1,
>>                                    C_63):prop)]))
>>                                 )])
>>                              :that ((C_42 E
>>                              (Sc(Sc(.M_1))
>>                              Set [(C_64:obj)
>>                                 => (thetachain1(.M_1,
>>                                 .thelaw_1,C_64):
>>                                 prop)]))
>>                              == thetachain1(.M_1,
>>                              .thelaw_1,C_42)))]))
>>                           ) Mp ((Sc(Sc(.M_1))
>>                           Set [(C_69:obj) =>
>>                              (thetachain1(.M_1,
>>                              .thelaw_1,C_69):
>>                              prop)])
>>                           Intax Sc(.M_1)))))))):
>>                           that (P_21 E K_15))])
>>                        :that ((P_21 E H_7)
>>                        -> (P_21 E K_15)))])
>>                     Conj (Inhabited(Simp2(thehyp_10))
>>                     Conj Inhabited((Simp2(thehyp_10)
>>                     Mp Ded([(phyp_70:that (J_9
>>                        E H_7)) => ((ktheta_17
>>                        Mp (K_15 Ui ((phyp_70
>>                        Mp (J_9 Ui Simp1(Simp1(thehyp_10))))
>>                        Iff1 (J_9 Ui (Forall([(C_81:
>>                           obj) => (((C_81 E
>>                           (Misset_1 Mbold2
>>                           thelawchooses_1))
>>                           == Forall([(D_82:
>>                              obj) => (((D_82
>>                              E (Sc(Sc(.M_1))
>>                              Set [(C_83:obj)
>>                                 => (thetachain1(.M_1,
>>                                 .thelaw_1,C_83):
>>                                 prop)]))
>>                              -> (C_81 E D_82)):
>>                              prop)]))
>>                           :prop)])
>>                        Fixform (((Misset_1
>>                        thetascm2 thelawchooses_1)
>>                        Iff2 (Sc(.M_1) Ui Ug([(C_90:
>>                           obj) => (Dediff([(hyp2_92:
>>                              that (C_90 E (Sc(Sc(.M_1))
>>                              Set [(C_93:obj)
>>                                 => (thetachain1(.M_1,
>>                                 .thelaw_1,C_93):
>>                                 prop)]))
>>                              ) => (Simp2((hyp2_92
>>                              Iff1 (C_90 Ui
>>                              (Sc(Sc(.M_1))
>>                              Separation [(C_97:
>>                                 obj) => (thetachain1(.M_1,
>>                                 .thelaw_1,C_97):
>>                                 prop)]))
>>                              )):that thetachain1(.M_1,
>>                              .thelaw_1,C_90))]
>>                           ,[(hyp1_98:that thetachain1(.M_1,
>>                              .thelaw_1,C_90))
>>                              => (((C_90 E (Sc(Sc(.M_1))
>>                              Set [(C_99:obj)
>>                                 => (thetachain1(.M_1,
>>                                 .thelaw_1,C_99):
>>                                 prop)]))
>>                              Fixform (((Simp1(Simp2(hyp1_98))
>>                              Iff2 (C_90 Ui
>>                              Scthm(Sc(.M_1))))
>>                              Conj hyp1_98)
>>                              Iff2 (C_90 Ui
>>                              (Sc(Sc(.M_1))
>>                              Separation [(C_110:
>>                                 obj) => (thetachain1(.M_1,
>>                                 .thelaw_1,C_110):
>>                                 prop)]))
>>                              )):that (C_90
>>                              E (Sc(Sc(.M_1))
>>                              Set [(C_111:obj)
>>                                 => (thetachain1(.M_1,
>>                                 .thelaw_1,C_111):
>>                                 prop)]))
>>                              )])
>>                           :that ((C_90 E (Sc(Sc(.M_1))
>>                           Set [(C_112:obj)
>>                              => (thetachain1(.M_1,
>>                              .thelaw_1,C_112):
>>                              prop)]))
>>                           == thetachain1(.M_1,
>>                           .thelaw_1,C_90)))]))
>>                        ) Mp ((Sc(Sc(.M_1))
>>                        Set [(C_117:obj) =>
>>                           (thetachain1(.M_1,
>>                           .thelaw_1,C_117):
>>                           prop)])
>>                        Intax Sc(.M_1)))))))):
>>                        that (J_9 E K_15))]))
>>                     )))) Conj Simp2(thehyp_10))
>>                     Mp (J_9 Ui (H_7 Ui Simp2(Simp2(Simp2((ktheta_17
>>                     Iff1 (K_15 Ui Ug([(C_135:
>>                        obj) => (Dediff([(hyp2_137:
>>                           that (C_135 E (Sc(Sc(.M_1))
>>                           Set [(C_138:obj)
>>                              => (thetachain1(.M_1,
>>                              .thelaw_1,C_138):
>>                              prop)]))
>>                           ) => (Simp2((hyp2_137
>>                           Iff1 (C_135 Ui (Sc(Sc(.M_1))
>>                           Separation [(C_142:
>>                              obj) => (thetachain1(.M_1,
>>                              .thelaw_1,C_142):
>>                              prop)]))
>>                           )):that thetachain1(.M_1,
>>                           .thelaw_1,C_135))]
>>                        ,[(hyp1_143:that thetachain1(.M_1,
>>                           .thelaw_1,C_135))
>>                           => (((C_135 E (Sc(Sc(.M_1))
>>                           Set [(C_144:obj)
>>                              => (thetachain1(.M_1,
>>                              .thelaw_1,C_144):
>>                              prop)]))
>>                           Fixform (((Simp1(Simp2(hyp1_143))
>>                           Iff2 (C_135 Ui Scthm(Sc(.M_1))))
>>                           Conj hyp1_143) Iff2
>>                           (C_135 Ui (Sc(Sc(.M_1))
>>                           Separation [(C_155:
>>                              obj) => (thetachain1(.M_1,
>>                              .thelaw_1,C_155):
>>                              prop)]))
>>                           )):that (C_135 E
>>                           (Sc(Sc(.M_1)) Set
>>                           [(C_156:obj) => (thetachain1(.M_1,
>>                              .thelaw_1,C_156):
>>                              prop)]))
>>                           )])
>>                        :that ((C_135 E (Sc(Sc(.M_1))
>>                        Set [(C_157:obj) =>
>>                           (thetachain1(.M_1,
>>                           .thelaw_1,C_157):
>>                           prop)]))
>>                        == thetachain1(.M_1,
>>                        .thelaw_1,C_135)))]))
>>                     ))))))):that ((H_7 Intersection
>>                     J_9) E K_15))])
>>                  :that ((K_15 E (Sc(Sc(.M_1))
>>                  Set [(C_158:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_158):prop)]))
>>                  -> ((H_7 Intersection J_9)
>>                  E K_15)))])
>>               Iff2 ((H_7 Intersection J_9)
>>               Ui (Forall([(C_162:obj) => (((C_162
>>                  E (Misset_1 Mbold2 thelawchooses_1))
>>                  == Forall([(D_163:obj) =>
>>                     (((D_163 E (Sc(Sc(.M_1))
>>                     Set [(C_164:obj) => (thetachain1(.M_1,
>>                        .thelaw_1,C_164):prop)]))
>>                     -> (C_162 E D_163)):prop)]))
>>                  :prop)])
>>               Fixform (((Misset_1 thetascm2
>>               thelawchooses_1) Iff2 (Sc(.M_1)
>>               Ui Ug([(C_171:obj) => (Dediff([(hyp2_173:
>>                     that (C_171 E (Sc(Sc(.M_1))
>>                     Set [(C_174:obj) => (thetachain1(.M_1,
>>                        .thelaw_1,C_174):prop)]))
>>                     ) => (Simp2((hyp2_173 Iff1
>>                     (C_171 Ui (Sc(Sc(.M_1))
>>                     Separation [(C_178:obj)
>>                        => (thetachain1(.M_1,
>>                        .thelaw_1,C_178):prop)]))
>>                     )):that thetachain1(.M_1,
>>                     .thelaw_1,C_171))]
>>                  ,[(hyp1_179:that thetachain1(.M_1,
>>                     .thelaw_1,C_171)) => (((C_171
>>                     E (Sc(Sc(.M_1)) Set [(C_180:
>>                        obj) => (thetachain1(.M_1,
>>                        .thelaw_1,C_180):prop)]))
>>                     Fixform (((Simp1(Simp2(hyp1_179))
>>                     Iff2 (C_171 Ui Scthm(Sc(.M_1))))
>>                     Conj hyp1_179) Iff2 (C_171
>>                     Ui (Sc(Sc(.M_1)) Separation
>>                     [(C_191:obj) => (thetachain1(.M_1,
>>                        .thelaw_1,C_191):prop)]))
>>                     )):that (C_171 E (Sc(Sc(.M_1))
>>                     Set [(C_192:obj) => (thetachain1(.M_1,
>>                        .thelaw_1,C_192):prop)]))
>>                     )])
>>                  :that ((C_171 E (Sc(Sc(.M_1))
>>                  Set [(C_193:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_193):prop)]))
>>                  == thetachain1(.M_1,.thelaw_1,
>>                  C_171)))]))
>>               ) Mp ((Sc(Sc(.M_1)) Set [(C_198:
>>                  obj) => (thetachain1(.M_1,
>>                  .thelaw_1,C_198):prop)])
>>               Intax Sc(.M_1)))))):that ((H_7
>>               Intersection J_9) E (Misset_1
>>               Mbold2 thelawchooses_1)))])
>>            :that (((H_7 <<= (Misset_1 Mbold2
>>            thelawchooses_1)) & (J_9 E H_7))
>>            -> ((H_7 Intersection J_9) E (Misset_1
>>            Mbold2 thelawchooses_1))))])
>>         :that Forall([(J_199:obj) => ((((H_7
>>            <<= (Misset_1 Mbold2 thelawchooses_1))
>>            & (J_199 E H_7)) -> ((H_7 Intersection
>>            J_199) E (Misset_1 Mbold2 thelawchooses_1))):
>>            prop)]))
>>         ])
>>      :that Forall([(H_200:obj) => (Forall([(J_201:
>>            obj) => ((((H_200 <<= (Misset_1
>>            Mbold2 thelawchooses_1)) & (J_201
>>            E H_200)) -> ((H_200 Intersection
>>            J_201) E (Misset_1 Mbold2 thelawchooses_1))):
>>            prop)])
>>         :prop)]))
>>      ]
>>   {move 0}



open

   define Line14: Lineb14 Misset thelawchooses


>>    Line14: [(---:that Forall([(H_1:obj) =>
>>            (Forall([(J_2:obj) => ((((H_1 <<=
>>               (Misset Mbold2 thelawchooses))
>>               & (J_2 E H_1)) -> ((H_1 Intersection
>>               J_2) E (Misset Mbold2 thelawchooses))):
>>               prop)])
>>            :prop)]))
>>         ]
>>      {move 1}



   define Mboldtheta1: Fixform(thetachain \
      (Mbold),Conj(Line1,Conj(Line4,Conj(Line8, \
      Line14))))

>>    Mboldtheta1: [(---:that thetachain(Mbold))]
>>      {move 1}



   close

define Mboldtheta2 Misset thelawchooses: \
   Mboldtheta1

>> Mboldtheta2: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))])
>>      => ((thetachain1(.M_1,.thelaw_1,(Misset_1
>>      Mbold2 thelawchooses_1)) Fixform ((Ug([(F_9:
>>         obj) => (Ded([(ftheta_11:that (F_9
>>            E (Sc(Sc(.M_1)) Set [(C_12:obj)
>>               => (thetachain1(.M_1,.thelaw_1,
>>               C_12):prop)]))
>>            ) => (Simp1((ftheta_11 Iff1 (F_9
>>            Ui Ug([(C_21:obj) => (Dediff([(hyp2_23:
>>                  that (C_21 E (Sc(Sc(.M_1))
>>                  Set [(C_24:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_24):prop)]))
>>                  ) => (Simp2((hyp2_23 Iff1
>>                  (C_21 Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_28:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_28):prop)]))
>>                  )):that thetachain1(.M_1,.thelaw_1,
>>                  C_21))]
>>               ,[(hyp1_29:that thetachain1(.M_1,
>>                  .thelaw_1,C_21)) => (((C_21
>>                  E (Sc(Sc(.M_1)) Set [(C_30:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_30):prop)]))
>>                  Fixform (((Simp1(Simp2(hyp1_29))
>>                  Iff2 (C_21 Ui Scthm(Sc(.M_1))))
>>                  Conj hyp1_29) Iff2 (C_21 Ui
>>                  (Sc(Sc(.M_1)) Separation [(C_41:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_41):prop)]))
>>                  )):that (C_21 E (Sc(Sc(.M_1))
>>                  Set [(C_42:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_42):prop)]))
>>                  )])
>>               :that ((C_21 E (Sc(Sc(.M_1))
>>               Set [(C_43:obj) => (thetachain1(.M_1,
>>                  .thelaw_1,C_43):prop)]))
>>               == thetachain1(.M_1,.thelaw_1,
>>               C_21)))]))
>>            )):that (.M_1 E F_9))])
>>         :that ((F_9 E (Sc(Sc(.M_1)) Set [(C_44:
>>            obj) => (thetachain1(.M_1,.thelaw_1,
>>            C_44):prop)]))
>>         -> (.M_1 E F_9)))])
>>      Iff2 (.M_1 Ui (Forall([(C_48:obj) => (((C_48
>>         E (Misset_1 Mbold2 thelawchooses_1))
>>         == Forall([(D_49:obj) => (((D_49 E
>>            (Sc(Sc(.M_1)) Set [(C_50:obj) =>
>>               (thetachain1(.M_1,.thelaw_1,C_50):
>>               prop)]))
>>            -> (C_48 E D_49)):prop)]))
>>         :prop)])
>>      Fixform (((Misset_1 thetascm2 thelawchooses_1)
>>      Iff2 (Sc(.M_1) Ui Ug([(C_57:obj) => (Dediff([(hyp2_59:
>>            that (C_57 E (Sc(Sc(.M_1)) Set [(C_60:
>>               obj) => (thetachain1(.M_1,.thelaw_1,
>>               C_60):prop)]))
>>            ) => (Simp2((hyp2_59 Iff1 (C_57
>>            Ui (Sc(Sc(.M_1)) Separation [(C_64:
>>               obj) => (thetachain1(.M_1,.thelaw_1,
>>               C_64):prop)]))
>>            )):that thetachain1(.M_1,.thelaw_1,
>>            C_57))]
>>         ,[(hyp1_65:that thetachain1(.M_1,.thelaw_1,
>>            C_57)) => (((C_57 E (Sc(Sc(.M_1))
>>            Set [(C_66:obj) => (thetachain1(.M_1,
>>               .thelaw_1,C_66):prop)]))
>>            Fixform (((Simp1(Simp2(hyp1_65))
>>            Iff2 (C_57 Ui Scthm(Sc(.M_1))))
>>            Conj hyp1_65) Iff2 (C_57 Ui (Sc(Sc(.M_1))
>>            Separation [(C_77:obj) => (thetachain1(.M_1,
>>               .thelaw_1,C_77):prop)]))
>>            )):that (C_57 E (Sc(Sc(.M_1)) Set
>>            [(C_78:obj) => (thetachain1(.M_1,
>>               .thelaw_1,C_78):prop)]))
>>            )])
>>         :that ((C_57 E (Sc(Sc(.M_1)) Set [(C_79:
>>            obj) => (thetachain1(.M_1,.thelaw_1,
>>            C_79):prop)]))
>>         == thetachain1(.M_1,.thelaw_1,C_57)))]))
>>      ) Mp ((Sc(Sc(.M_1)) Set [(C_84:obj) =>
>>         (thetachain1(.M_1,.thelaw_1,C_84):prop)])
>>      Intax Sc(.M_1)))))) Conj ((((Misset_1
>>      Mbold2 thelawchooses_1) <<= Sc(.M_1))
>>      Fixform (Ug([(A_90:obj) => (Ded([(ainev_91:
>>            that (A_90 E (Misset_1 Mbold2 thelawchooses_1)))
>>            => ((((Misset_1 thetascm2 thelawchooses_1)
>>            Iff2 (Sc(.M_1) Ui Ug([(C_98:obj)
>>               => (Dediff([(hyp2_100:that (C_98
>>                  E (Sc(Sc(.M_1)) Set [(C_101:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_101):prop)]))
>>                  ) => (Simp2((hyp2_100 Iff1
>>                  (C_98 Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_105:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_105):prop)]))
>>                  )):that thetachain1(.M_1,.thelaw_1,
>>                  C_98))]
>>               ,[(hyp1_106:that thetachain1(.M_1,
>>                  .thelaw_1,C_98)) => (((C_98
>>                  E (Sc(Sc(.M_1)) Set [(C_107:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_107):prop)]))
>>                  Fixform (((Simp1(Simp2(hyp1_106))
>>                  Iff2 (C_98 Ui Scthm(Sc(.M_1))))
>>                  Conj hyp1_106) Iff2 (C_98
>>                  Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_118:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_118):prop)]))
>>                  )):that (C_98 E (Sc(Sc(.M_1))
>>                  Set [(C_119:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_119):prop)]))
>>                  )])
>>               :that ((C_98 E (Sc(Sc(.M_1))
>>               Set [(C_120:obj) => (thetachain1(.M_1,
>>                  .thelaw_1,C_120):prop)]))
>>               == thetachain1(.M_1,.thelaw_1,
>>               C_98)))]))
>>            ) Mp (Sc(.M_1) Ui (ainev_91 Iff1
>>            (A_90 Ui (Forall([(C_128:obj) =>
>>               (((C_128 E (Misset_1 Mbold2 thelawchooses_1))
>>               == Forall([(D_129:obj) => (((D_129
>>                  E (Sc(Sc(.M_1)) Set [(C_130:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_130):prop)]))
>>                  -> (C_128 E D_129)):prop)]))
>>               :prop)])
>>            Fixform (((Misset_1 thetascm2 thelawchooses_1)
>>            Iff2 (Sc(.M_1) Ui Ug([(C_137:obj)
>>               => (Dediff([(hyp2_139:that (C_137
>>                  E (Sc(Sc(.M_1)) Set [(C_140:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_140):prop)]))
>>                  ) => (Simp2((hyp2_139 Iff1
>>                  (C_137 Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_144:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_144):prop)]))
>>                  )):that thetachain1(.M_1,.thelaw_1,
>>                  C_137))]
>>               ,[(hyp1_145:that thetachain1(.M_1,
>>                  .thelaw_1,C_137)) => (((C_137
>>                  E (Sc(Sc(.M_1)) Set [(C_146:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_146):prop)]))
>>                  Fixform (((Simp1(Simp2(hyp1_145))
>>                  Iff2 (C_137 Ui Scthm(Sc(.M_1))))
>>                  Conj hyp1_145) Iff2 (C_137
>>                  Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_157:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_157):prop)]))
>>                  )):that (C_137 E (Sc(Sc(.M_1))
>>                  Set [(C_158:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_158):prop)]))
>>                  )])
>>               :that ((C_137 E (Sc(Sc(.M_1))
>>               Set [(C_159:obj) => (thetachain1(.M_1,
>>                  .thelaw_1,C_159):prop)]))
>>               == thetachain1(.M_1,.thelaw_1,
>>               C_137)))]))
>>            ) Mp ((Sc(Sc(.M_1)) Set [(C_164:
>>               obj) => (thetachain1(.M_1,.thelaw_1,
>>               C_164):prop)])
>>            Intax Sc(.M_1)))))))):that (A_90
>>            E Sc(.M_1)))])
>>         :that ((A_90 E (Misset_1 Mbold2 thelawchooses_1))
>>         -> (A_90 E Sc(.M_1))))])
>>      Conj (Inhabited((Ug([(F_169:obj) => (Ded([(ftheta_171:
>>            that (F_169 E (Sc(Sc(.M_1)) Set
>>            [(C_172:obj) => (thetachain1(.M_1,
>>               .thelaw_1,C_172):prop)]))
>>            ) => (Simp1((ftheta_171 Iff1 (F_169
>>            Ui Ug([(C_181:obj) => (Dediff([(hyp2_183:
>>                  that (C_181 E (Sc(Sc(.M_1))
>>                  Set [(C_184:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_184):prop)]))
>>                  ) => (Simp2((hyp2_183 Iff1
>>                  (C_181 Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_188:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_188):prop)]))
>>                  )):that thetachain1(.M_1,.thelaw_1,
>>                  C_181))]
>>               ,[(hyp1_189:that thetachain1(.M_1,
>>                  .thelaw_1,C_181)) => (((C_181
>>                  E (Sc(Sc(.M_1)) Set [(C_190:
>>                     obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_190):prop)]))
>>                  Fixform (((Simp1(Simp2(hyp1_189))
>>                  Iff2 (C_181 Ui Scthm(Sc(.M_1))))
>>                  Conj hyp1_189) Iff2 (C_181
>>                  Ui (Sc(Sc(.M_1)) Separation
>>                  [(C_201:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_201):prop)]))
>>                  )):that (C_181 E (Sc(Sc(.M_1))
>>                  Set [(C_202:obj) => (thetachain1(.M_1,
>>                     .thelaw_1,C_202):prop)]))
>>                  )])
>>               :that ((C_181 E (Sc(Sc(.M_1))
>>               Set [(C_203:obj) => (thetachain1(.M_1,
>>                  .thelaw_1,C_203):prop)]))
>>               == thetachain1(.M_1,.thelaw_1,
>>               C_181)))]))
>>            )):that (.M_1 E F_169))])
>>         :that ((F_169 E (Sc(Sc(.M_1)) Set [(C_204:
>>            obj) => (thetachain1(.M_1,.thelaw_1,
>>            C_204):prop)]))
>>         -> (.M_1 E F_169)))])
>>      Iff2 (.M_1 Ui (Forall([(C_208:obj) =>
>>         (((C_208 E (Misset_1 Mbold2 thelawchooses_1))
>>         == Forall([(D_209:obj) => (((D_209
>>            E (Sc(Sc(.M_1)) Set [(C_210:obj)
>>               => (thetachain1(.M_1,.thelaw_1,
>>               C_210):prop)]))
>>            -> (C_208 E D_209)):prop)]))
>>         :prop)])
>>      Fixform (((Misset_1 thetascm2 thelawchooses_1)
>>      Iff2 (Sc(.M_1) Ui Ug([(C_217:obj) => (Dediff([(hyp2_219:
>>            that (C_217 E (Sc(Sc(.M_1)) Set
>>            [(C_220:obj) => (thetachain1(.M_1,
>>               .thelaw_1,C_220):prop)]))
>>            ) => (Simp2((hyp2_219 Iff1 (C_217
>>            Ui (Sc(Sc(.M_1)) Separation [(C_224:
>>               obj) => (thetachain1(.M_1,.thelaw_1,
>>               C_224):prop)]))
>>            )):that thetachain1(.M_1,.thelaw_1,
>>            C_217))]
>>         ,[(hyp1_225:that thetachain1(.M_1,.thelaw_1,
>>            C_217)) => (((C_217 E (Sc(Sc(.M_1))
>>            Set [(C_226:obj) => (thetachain1(.M_1,
>>               .thelaw_1,C_226):prop)]))
>>            Fixform (((Simp1(Simp2(hyp1_225))
>>            Iff2 (C_217 Ui Scthm(Sc(.M_1))))
>>            Conj hyp1_225) Iff2 (C_217 Ui (Sc(Sc(.M_1))
>>            Separation [(C_237:obj) => (thetachain1(.M_1,
>>               .thelaw_1,C_237):prop)]))
>>            )):that (C_217 E (Sc(Sc(.M_1)) Set
>>            [(C_238:obj) => (thetachain1(.M_1,
>>               .thelaw_1,C_238):prop)]))
>>            )])
>>         :that ((C_217 E (Sc(Sc(.M_1)) Set [(C_239:
>>            obj) => (thetachain1(.M_1,.thelaw_1,
>>            C_239):prop)]))
>>         == thetachain1(.M_1,.thelaw_1,C_217)))]))
>>      ) Mp ((Sc(Sc(.M_1)) Set [(C_244:obj) =>
>>         (thetachain1(.M_1,.thelaw_1,C_244):
>>         prop)])
>>      Intax Sc(.M_1))))))) Conj Sc2(.M_1))))
>>      Conj ((Misset_1 Lineb8 thelawchooses_1)
>>      Conj (Misset_1 Lineb14 thelawchooses_1))))):
>>      that thetachain1(.M_1,.thelaw_1,(Misset_1
>>      Mbold2 thelawchooses_1)))]
>>   {move 0}



open

   define Mboldtheta: Mboldtheta2 Misset \
      thelawchooses

>>    Mboldtheta: [(---:that thetachain1(M,thelaw,
>>         (Misset Mbold2 thelawchooses)))]
>>      {move 1}


\end{verbatim}

{\tt Mboldtheta} asserts that {\bf M} is a $\Theta$-chain.  Removal of the block enclosing {\tt Line1} to {\tt Line14} would make its type information much more compact at the  cost
of having {\tt Line1}, {\tt Line4}, {\tt Line8} and {\tt Line14} reserved for the remainder of the proof.

\begin{verbatim}Lestrade execution:

     clearcurrent


   declare C obj

>>    C: obj {move 2}



   declare D obj

>>    D: obj {move 2}



   define cuts1 C: (C E Mbold) & Forall[D=>(D \
         E Mbold) -> (D <<= C) V (C <<= D)] \
      



>>    cuts1: [(C_1:obj) => (---:prop)]
>>      {move 1}



   save

   close

declare C666 obj

>> C666: obj {move 1}



define cuts2 Misset thelawchooses, C666: \
   cuts1 C666

>> cuts2: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))]),
>>      (C666_1:obj) => (((C666_1 E (Misset_1
>>      Mbold2 thelawchooses_1)) & Forall([(D_5:
>>         obj) => (((D_5 E (Misset_1 Mbold2 thelawchooses_1))
>>         -> ((D_5 <<= C666_1) V (C666_1 <<=
>>         D_5))):prop)]))
>>      :prop)]
>>   {move 0}



open

   define cuts C: cuts2 Misset thelawchooses, \
      C

>>    cuts: [(C_1:obj) => (---:prop)]
>>      {move 1}



   define Cuts1: Set (Mbold, cuts)

>>    Cuts1: [(---:obj)]
>>      {move 1}



   close

define Cuts3 Misset thelawchooses: Cuts1


>> Cuts3: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))])
>>      => (((Misset_1 Mbold2 thelawchooses_1)
>>      Set [(C_5:obj) => (cuts2(Misset_1,thelawchooses_1,
>>         C_5):prop)])
>>      :obj)]
>>   {move 0}



open

   define Cuts: Cuts3 Misset thelawchooses


>>    Cuts: [(---:obj)]
>>      {move 1}



   define line1:Simp1 Mboldtheta

>>    line1: [(---:that (M E (Misset Mbold2
>>         thelawchooses)))]
>>      {move 1}



   open

      declare F obj

>>       F: obj {move 3}



      open

         declare finmbold that F E Mbold


>>          finmbold: that (F E Mbold) {move
>>            4}



         define line2 finmbold: Iff1(Mp finmbold, \
            Ui F Simp1 Simp1 Simp2 Mboldtheta, \
            Ui F Scthm M)

>>          line2: [(finmbold_1:that (F E Mbold))
>>               => (---:that (F <<= M))]
>>            {move 3}



         define line3 finmbold: Add1(M <<= \
            F, line2 finmbold)

>>          line3: [(finmbold_1:that (F E Mbold))
>>               => (---:that ((F <<= M) V (M
>>               <<= F)))]
>>            {move 3}



         close

      define line4 F : Ded line3

>>       line4: [(F_1:obj) => (---:that ((F_1
>>            E Mbold) -> ((F_1 <<= M) V (M <<=
>>            F_1))))]
>>         {move 2}



      close

   define line5: Ug line4

>>    line5: [(---:that Forall([(F_12:obj) =>
>>            (((F_12 E Mbold) -> ((F_12 <<= M)
>>            V (M <<= F_12))):prop)]))
>>         ]
>>      {move 1}



   define line6: Fixform(cuts M,Conj(line1, \
      line5))

>>    line6: [(---:that cuts(M))]
>>      {move 1}



   define line7: Conj(Simp1 Mboldtheta, line6)


>>    line7: [(---:that ((M E (Misset Mbold2
>>         thelawchooses)) & cuts(M)))]
>>      {move 1}



   define line8: Ui M, Separation (Mbold, \
      cuts)

>>    line8: [(---:that ((M E (Mbold Set cuts))
>>         == ((M E Mbold) & cuts(M))))]
>>      {move 1}



   define Line9: Fixform(M E Cuts,Iff2(line7, \
      line8))

>>    Line9: [(---:that (M E Cuts))]
>>      {move 1}



   define line10: Fixform(Cuts <<= (Mbold), \
      Sepsub (Mbold, cuts, Inhabited (Simp1 \
      (Mboldtheta))) )

>>    line10: [(---:that (Cuts <<= Mbold))]
>>      {move 1}



   define line11 : Fixform((Mbold)<<= Sc \
      M,Sepsub2 (Sc2 M,Refleq (Mbold)))

>>    line11: [(---:that (Mbold <<= Sc(M)))]
>>      {move 1}



   define Line12: Transsub(line10, line11)


>>    Line12: [(---:that (Cuts <<= Sc(M)))]
>>      {move 1}



   open

      declare B obj

>>       B: obj {move 3}



      open

         declare bhyp that B E Cuts

>>          bhyp: that (B E Cuts) {move 4}



         define line13 bhyp: Iff1(bhyp, Ui \
            B, Separation (Mbold, cuts))

>>          line13: [(bhyp_1:that (B E Cuts))
>>               => (---:that ((B E Mbold) & cuts(B)))]
>>            {move 3}



         define line14 bhyp: Simp1 line13 \
            bhyp

>>          line14: [(bhyp_1:that (B E Cuts))
>>               => (---:that (B E Mbold))]
>>            {move 3}



         define linea14 bhyp: Setsinchains \
            Mboldtheta, line14 bhyp

>>          linea14: [(bhyp_1:that (B E Cuts))
>>               => (---:that Isset(B))]
>>            {move 3}



         define lineb14 bhyp: Iff1(Mp(line14 \
            bhyp,Ui (B, Simp1 Simp1 Simp2 Mboldtheta)), \
            Ui B, Scthm M)

>>          lineb14: [(bhyp_1:that (B E Cuts))
>>               => (---:that (B <<= M))]
>>            {move 3}



         define line15 bhyp: Simp2 Simp2 \
            line13 bhyp

>>          line15: [(bhyp_1:that (B E Cuts))
>>               => (---:that Forall([(D_3:obj)
>>                  => (((D_3 E (Misset Mbold2
>>                  thelawchooses)) -> ((D_3 <<=
>>                  B) V (B <<= D_3))):prop)]))
>>               ]
>>            {move 3}



         open

            declare F obj

>>             F: obj {move 5}



            declare fhyp that F E (Mbold)


>>             fhyp: that (F E Mbold) {move
>>               5}



            define line16 fhyp: Fixform((prime \
               F)<<=F, Sepsub2 (Setsinchains \
               Mboldtheta,fhyp, Refleq (prime \
               F)))

>>             line16: [(.F_1:obj),(fhyp_1:that
>>                  (.F_1 E Mbold)) => (---:that
>>                  (prime(.F_1) <<= .F_1))]
>>               {move 4}



            declare Y obj

>>             Y: obj {move 5}



            define cutsa2 Y: (Y <<= prime \
               B) V B <<= Y

>>             cutsa2: [(Y_1:obj) => (---:prop)]
>>               {move 4}



            save

            close

         declare Y100 obj

>>          Y100: obj {move 4}



         define cutsb2 Y100: cutsa2 Y100


>>          cutsb2: [(Y100_1:obj) => (---:prop)]
>>            {move 3}



         save

         close

      declare Y101 obj

>>       Y101: obj {move 3}



      define cutsc2 B Y101: cutsb2 Y101

>>       cutsc2: [(B_1:obj),(Y101_1:obj) =>
>>            (---:prop)]
>>         {move 2}



      save

      close

   declare Ba1 obj

>>    Ba1: obj {move 2}



   declare Y102 obj

>>    Y102: obj {move 2}



   define cutsd2 Ba1 Y102: cutsc2 Ba1 Y102


>>    cutsd2: [(Ba1_1:obj),(Y102_1:obj) => (---:
>>         prop)]
>>      {move 1}



   save

   close

declare Ba2 obj

>> Ba2: obj {move 1}



declare Y103 obj

>> Y103: obj {move 1}



define cutse2 Misset thelawchooses, Ba2 Y103: \
   cutsd2 Ba2 Y103

>> cutse2: [(.M_1:obj),(Misset_1:that Isset(.M_1)),
>>      (.thelaw_1:[(S_2:obj) => (---:obj)]),
>>      (thelawchooses_1:[(.S_3:obj),(subsetev_3:
>>         that (.S_3 <<= .M_1)),(inev_3:that
>>         Exists([(x_4:obj) => ((x_4 E .S_3):
>>            prop)]))
>>         => (---:that (.thelaw_1(.S_3) E .S_3))]),
>>      (Ba2_1:obj),(Y103_1:obj) => (((Y103_1
>>      <<= prime2(.thelaw_1,Ba2_1)) V (Ba2_1
>>      <<= Y103_1)):prop)]
>>   {move 0}



open

   define cutsf2 Ba1 Y102: cutse2 Misset, \
      thelawchooses, Ba1 Y102

>>    cutsf2: [(Ba1_1:obj),(Y102_1:obj) => (---:
>>         prop)]
>>      {move 1}



   open

      define cutsg2 B Y101: cutsf2 B Y101


>>       cutsg2: [(B_1:obj),(Y101_1:obj) =>
>>            (---:prop)]
>>         {move 2}



      open

         define cutsh2 Y100: cutsg2 B Y100


>>          cutsh2: [(Y100_1:obj) => (---:prop)]
>>            {move 3}



         open

            define cutsi2 Y: cutsh2 Y

>>             cutsi2: [(Y_1:obj) => (---:prop)]
>>               {move 4}



            define Cuts2: Set(Mbold,cutsi2)


>>             Cuts2: [(---:obj)]
>>               {move 4}



            goal that thetachain Cuts2

>>             Goal: that thetachain(Cuts2)


            test thetachain

>>             Test: thetachain

>>             [(C_1:obj) => (thetachain1(M,
>>                  thelaw,C_1):prop)]
>>               



            goal that M E Cuts2

>>             Goal: that (M E Cuts2)

            define line17 : Ui M, Separation4 \
               Refleq Cuts2

>>             line17: [(---:that ((M E (Mbold
>>                  Set cutsi2)) == ((M E Mbold)
>>                  & cutsi2(M))))]
>>               {move 4}



            define line18: Conj(Simp1 \
               Mboldtheta, Add2(M<<=prime B, \
               lineb14 bhyp))

>>             line18: [(---:that ((M E (Misset
>>                  Mbold2 thelawchooses)) & ((M
>>                  <<= prime(B)) V (B <<= M))))]
>>               {move 4}



            define line19: Fixform(M E Cuts2, \
               Iff2 line18 line17)

>>             line19: [(---:that (M E Cuts2))]
>>               {move 4}



            goal that Cuts2 <<= Sc M

>>             Goal: that (Cuts2 <<= Sc(M))


            declare D1 obj

>>             D1: obj {move 5}



            define line20: Fixform(Cuts2 \
               <<= Mbold, Sepsub2(Separation3 \
               Refleq Mbold,Refleq Cuts2))


>>             line20: [(---:that (Cuts2 <<=
>>                  Mbold))]
>>               {move 4}



            define line21 : Transsub line20 \
               Simp1 Simp2 Mboldtheta

>>             line21: [(---:that (Cuts2 <<=
>>                  Sc(M)))]
>>               {move 4}



            declare F1 obj

>>             F1: obj {move 5}



            goal that Forall[D1 => (D1 E \
                  Cuts2) -> (prime D1) E Cuts2] \
               



>>             Goal: that Forall([(D1_1297:obj)
>>                  => (((D1_1297 E Cuts2) ->
>>                  (prime(D1_1297) E Cuts2)):
>>                  prop)])
>>               

            open

               declare D2 obj

>>                D2: obj {move 6}



               open

                  declare dhyp that D2 E \
                     Cuts2

>>                   dhyp: that (D2 E Cuts2)
>>                     {move 7}



                  goal that (prime D2) E \
                     Cuts2

>>                   Goal: that (prime(D2) E
>>                     Cuts2)

                  define line22 : Ui prime \
                     D2, Separation4 Refleq \
                     Cuts2

>>                   line22: [(---:that ((prime(D2)
>>                        E (Mbold Set cutsi2))
>>                        == ((prime(D2) E Mbold)
>>                        & cutsi2(prime(D2)))))]
>>                     {move 6}



                  goal that ((prime D2) E \
                     Mbold) & ((prime D2) <<= \
                     prime B) V (B <<= prime \
                     D2)

>>                   Goal: that ((prime(D2)
>>                     E Mbold) & ((prime(D2)
>>                     <<= prime(B)) V (B <<=
>>                     prime(D2))))

                  define line23 dhyp: \
                     Iff1 dhyp,Ui D2 \
                     Separation4 Refleq Cuts2


>>                   line23: [(dhyp_1:that (D2
>>                        E Cuts2)) => (---:that
>>                        ((D2 E Mbold) & cutsi2(D2)))]
>>                     {move 6}



                  define line24 dhyp: \
                     Simp1 line23 dhyp

>>                   line24: [(dhyp_1:that (D2
>>                        E Cuts2)) => (---:that
>>                        (D2 E Mbold))]
>>                     {move 6}



                  define line25 dhyp: \
                     Simp2 line23 dhyp

>>                   line25: [(dhyp_1:that (D2
>>                        E Cuts2)) => (---:that
>>                        cutsi2(D2))]
>>                     {move 6}



                  define line26: Iff1 \
                     bhyp, Ui B, Separation4 \
                     Refleq Cuts

>>                   line26: [(---:that ((B
>>                        E (Misset Mbold2 thelawchooses))
>>                        & cuts2(Misset,thelawchooses,
>>                        B)))]
>>                     {move 6}



                  define line27 dhyp: \
                     Mp line24 dhyp, \
                     Ui D2, Simp2 Simp2 line26


>>                   line27: [(dhyp_1:that (D2
>>                        E Cuts2)) => (---:that
>>                        ((D2 <<= B) V (B <<=
>>                        D2)))]
>>                     {move 6}



                  define line28 dhyp: \
                     Mp line24 dhyp, \
                     Ui D2, Simp1 Simp2 Simp2 \
                     Mboldtheta

>>                   line28: [(dhyp_1:that (D2
>>                        E Cuts2)) => (---:that
>>                        (prime2(thelaw,D2) E
>>                        (Misset Mbold2 thelawchooses)))]
>>                     {move 6}



                  define line29 dhyp: \
                     Mp line28 dhyp, \
                     Ui prime D2, Simp2 Simp2 \
                     line26

>>                   line29: [(dhyp_1:that (D2
>>                        E Cuts2)) => (---:that
>>                        ((prime(D2) <<= B) V
>>                        (B <<= prime(D2))))]
>>                     {move 6}



                  goal that ((prime D2) <<= \
                     prime B) V (B <<= prime \
                     D2)

>>                   Goal: that ((prime(D2)
>>                     <<= prime(B)) V (B <<=
>>                     prime(D2)))

                  open

                     declare U obj

>>                      U: obj {move 8}



                     declare Casehyp1 \
                        that B=0

>>                      Casehyp1: that (B =
>>                        0) {move 8}



                     define linea29 Casehyp1: \
                        Subs1(Eqsymm Casehyp1, \
                        Add2(prime D2 <<= prime \
                        B, Zeroissubset Separation3 \
                        Refleq prime D2))

>>                      linea29: [(Casehyp1_1:
>>                           that (B = 0)) =>
>>                           (---:that ((prime(D2)
>>                           <<= prime(B)) V (B
>>                           <<= (D2 Set [(x_7:
>>                              obj) => (~((x_7
>>                              E Usc(thelaw(D2)))):
>>                              prop)]))
>>                           ))]
>>                        {move 7}



                     declare Casehyp2 \
                        that Exists[U=> U E \
                           B] \
                        



>>                      Casehyp2: that Exists([(U_1:
>>                           obj) => ((U_1 E B):
>>                           prop)])
>>                        {move 8}



                     open

                        declare casehyp1 \
                           that D2 <<= prime \
                           B

>>                         casehyp1: that (D2
>>                           <<= prime(B)) {move
>>                           9}



                        declare casehyp2 \
                           that B <<= D2

>>                         casehyp2: that (B
>>                           <<= D2) {move 9}



                        define line30 \
                           casehyp1: \
                           Transsub(line16 (line24 \
                           dhyp), casehyp1)


>>                         line30: [(casehyp1_1:
>>                              that (D2 <<= prime(B)))
>>                              => (---:that (prime(D2)
>>                              <<= prime(B)))]
>>                           {move 8}



                        define linea30 casehyp1: \
                           Add1(B <<= prime \
                           D2, line30 casehyp1)


>>                         linea30: [(casehyp1_1:
>>                              that (D2 <<= prime(B)))
>>                              => (---:that ((prime(D2)
>>                              <<= prime(B))
>>                              V (B <<= prime(D2))))]
>>                           {move 8}



                        define line31 \
                           : Excmid ((thelaw \
                           D2) = thelaw \
                           B)

>>                         line31: [(---:that
>>                              ((thelaw(D2) =
>>                              thelaw(B)) V ~((thelaw(D2)
>>                              = thelaw(B)))))]
>>                           {move 8}



                        define line32 \
                           : Separation4 \
                           Refleq prime D2

>>                         line32: [(---:that
>>                              Forall([(x_2:obj)
>>                                 => (((x_2 E
>>                                 (D2 Set [(x_3:
>>                                    obj) =>
>>                                    (~((x_3
>>                                    E Usc(thelaw(D2)))):
>>                                    prop)]))
>>                                 == ((x_2 E
>>                                 D2) & ~((x_2
>>                                 E Usc(thelaw(D2)))))):
>>                                 prop)]))
>>                              ]
>>                           {move 8}



                        open

                           declare casehypa1 \
                              that (thelaw \
                              D2 = thelaw B)


>>                            casehypa1: that
>>                              (thelaw(D2) =
>>                              thelaw(B)) {move
>>                              10}



                           declare casehypa2 \
                              that ~(thelaw \
                              D2 = thelaw B)


>>                            casehypa2: that
>>                              ~((thelaw(D2)
>>                              = thelaw(B)))
>>                              {move 10}



                           open

                              declare \
                                 G obj

>>                               G: obj {move
>>                                 11}



                              open

                                 declare \
                                    onedir \
                                    that G \
                                    E prime \
                                    D2

>>                                  onedir:
>>                                    that (G
>>                                    E prime(D2))
>>                                    {move 12}



                                 define line33 \
                                    onedir \
                                    : Iff1 \
                                    onedir, \
                                    Ui G line32


>>                                  line33:
>>                                    [(onedir_1:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))
>>                                       => (---:
>>                                       that
>>                                       ((G E
>>                                       D2) &
>>                                       ~((G
>>                                       E Usc(thelaw(D2))))))]
>>                                    {move 11}



                                 define line34 \
                                    onedir: \
                                    Simp1 line33 \
                                    onedir


>>                                  line34:
>>                                    [(onedir_1:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))
>>                                       => (---:
>>                                       that
>>                                       (G E
>>                                       D2))]
>>                                    {move 11}



                                 define line35 \
                                    onedir: \
                                    Simp2 line33 \
                                    onedir


>>                                  line35:
>>                                    [(onedir_1:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))
>>                                       => (---:
>>                                       that
>>                                       ~((G
>>                                       E Usc(thelaw(D2)))))]
>>                                    {move 11}



                                 open

                                    declare \
                                       eqhyp \
                                       that \
                                       G=(thelaw \
                                       D2)


>>                                     eqhyp:
>>                                       that
>>                                       (G =
>>                                       thelaw(D2))
>>                                       {move
>>                                       13}



                                    define \
                                       line36 \
                                       eqhyp: \
                                       Subs1 \
                                       Eqsymm \
                                       eqhyp \
                                       line35 \
                                       onedir


>>                                     line36:
>>                                       [(eqhyp_1:
>>                                          that (G
>>                                          = thelaw(D2)))
>>                                          => (---:
>>                                          that ~((G
>>                                          E Usc(G))))]
>>                                       {move
>>                                       12}



                                    define \
                                       line37 \
                                       eqhyp: \
                                       Mp (Inusc2 \
                                       G,line36 \
                                       eqhyp)


>>                                     line37:
>>                                       [(eqhyp_1:
>>                                          that (G
>>                                          = thelaw(D2)))
>>                                          => (---:
>>                                          that ??)]
>>                                       {move
>>                                       12}



                                    close


                                 define line38 \
                                    onedir: \
                                    Negintro \
                                    line37


>>                                  line38:
>>                                    [(onedir_1:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))
>>                                       => (---:
>>                                       that
>>                                       ~((G
>>                                       = thelaw(D2))))]
>>                                    {move 11}



                                 define line39 \
                                    onedir \
                                    : Subs1 \
                                    casehypa1 \
                                    line38 \
                                    onedir


>>                                  line39:
>>                                    [(onedir_1:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))
>>                                       => (---:
>>                                       that
>>                                       ~((G
>>                                       = thelaw(B))))]
>>                                    {move 11}



                                 define linea39 \
                                    onedir \
                                    : Subs1 \
                                    casehypa1 \
                                    line35 \
                                    onedir


>>                                  linea39:
>>                                    [(onedir_1:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))
>>                                       => (---:
>>                                       that
>>                                       ~((G
>>                                       E Usc(thelaw(B)))))]
>>                                    {move 11}



                                 open

                                    declare \
                                       casehypb1 \
                                       that \
                                       prime \
                                       D2 <<= \
                                       B

>>                                     casehypb1:
>>                                       that
>>                                       (prime(D2)
>>                                       <<= B)
>>                                       {move
>>                                       13}



                                    define \
                                       line40 \
                                       casehypb1: \
                                       Mp(onedir, \
                                       Ui G, \
                                       Simp1 \
                                       casehypb1)


>>                                     line40:
>>                                       [(casehypb1_1:
>>                                          that (prime(D2)
>>                                          <<= B))
>>                                          => (---:
>>                                          that (G
>>                                          E B))]
>>                                       {move
>>                                       12}



                                    declare \
                                       casehypb2 \
                                       that \
                                       B <<= \
                                       prime \
                                       D2

>>                                     casehypb2:
>>                                       that
>>                                       (B <<=
>>                                       prime(D2))
>>                                       {move
>>                                       13}



                                    define \
                                       line41 \
                                       casehypb2: \
                                       Ui thelaw \
                                       B, Simp1 \
                                       casehypb2


>>                                     line41:
>>                                       [(casehypb2_1:
>>                                          that (B
>>                                          <<= prime(D2)))
>>                                          => (---:
>>                                          that ((thelaw(B)
>>                                          E B) ->
>>                                          (thelaw(B)
>>                                          E prime(D2))))]
>>                                       {move
>>                                       12}



                                    define \
                                       line42: \
                                       thelawchooses \
                                       (lineb14 \
                                       bhyp, \
                                       Casehyp2)


>>                                     line42:
>>                                       [(---:
>>                                          that (thelaw(B)
>>                                          E B))]
>>                                       {move
>>                                       12}



                                    define \
                                       line43 \
                                       casehypb2: \
                                       Mp (line42, \
                                       line41 \
                                       casehypb2)


>>                                     line43:
>>                                       [(casehypb2_1:
>>                                          that (B
>>                                          <<= prime(D2)))
>>                                          => (---:
>>                                          that (thelaw(B)
>>                                          E prime(D2)))]
>>                                       {move
>>                                       12}



                                    define \
                                       line44 \
                                       casehypb2: \
                                       Iff1(line43 \
                                       casehypb2, \
                                       Ui thelaw \
                                       B,Separation4 \
                                       Refleq \
                                       prime \
                                       D2)


>>                                     line44:
>>                                       [(casehypb2_1:
>>                                          that (B
>>                                          <<= prime(D2)))
>>                                          => (---:
>>                                          that ((thelaw(B)
>>                                          E D2) &
>>                                          ~((thelaw(B)
>>                                          E Usc(thelaw(D2))))))]
>>                                       {move
>>                                       12}



                                    define \
                                       line45 \
                                       casehypb2: \
                                       Subs1 \
                                       Eqsymm \
                                       casehypa1 \
                                       line44 \
                                       casehypb2


>>                                     line45:
>>                                       [(casehypb2_1:
>>                                          that (B
>>                                          <<= prime(D2)))
>>                                          => (---:
>>                                          that ((thelaw(D2)
>>                                          E D2) &
>>                                          ~((thelaw(D2)
>>                                          E Usc(thelaw(D2))))))]
>>                                       {move
>>                                       12}



                                    define \
                                       line46 \
                                       casehypb2: \
                                       Simp2 \
                                       line45 \
                                       casehypb2


>>                                     line46:
>>                                       [(casehypb2_1:
>>                                          that (B
>>                                          <<= prime(D2)))
>>                                          => (---:
>>                                          that ~((thelaw(D2)
>>                                          E Usc(thelaw(D2)))))]
>>                                       {move
>>                                       12}



                                    define \
                                       line47 \
                                       casehypb2: \
                                       Giveup(G \
                                       E B, \
                                       Mp(Inusc2 \
                                       thelaw \
                                       D2, \
                                       line46 \
                                       casehypb2))


>>                                     line47:
>>                                       [(casehypb2_1:
>>                                          that (B
>>                                          <<= prime(D2)))
>>                                          => (---:
>>                                          that (G
>>                                          E B))]
>>                                       {move
>>                                       12}



                                    close


                                 define line48 \
                                    onedir: \
                                    Cases( \
                                    line29 \
                                    dhyp, line40, \
                                    line47)


>>                                  line48:
>>                                    [(onedir_1:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))
>>                                       => (---:
>>                                       that
>>                                       (G E
>>                                       B))]
>>                                    {move 11}



                                 define linea48 \
                                    onedir: \
                                    Fixform(G \
                                    E prime(B), \
                                    Iff2(Conj(line48 \
                                    onedir, \
                                    linea39 \
                                    onedir), \
                                    Ui G, Separation4 \
                                    Refleq \
                                    prime B))


>>                                  linea48:
>>                                    [(onedir_1:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))
>>                                       => (---:
>>                                       that
>>                                       (G E
>>                                       prime(B)))]
>>                                    {move 11}



                                 declare \
                                    otherdir \
                                    that G \
                                    E B

>>                                  otherdir:
>>                                    that (G
>>                                    E B) {move
>>                                    12}



                                 define line49 \
                                    otherdir: \
                                    Mp(otherdir, \
                                    Ui G Simp1 \
                                    casehyp2)


>>                                  line49:
>>                                    [(otherdir_1:
>>                                       that
>>                                       (G E
>>                                       B)) =>
>>                                       (---:
>>                                       that
>>                                       (G E
>>                                       D2))]
>>                                    {move 11}



                                 open

                                    declare \
                                       eqhyp2 \
                                       that \
                                       G E \
                                       Usc \
                                       thelaw \
                                       D2

>>                                     eqhyp2:
>>                                       that
>>                                       (G E
>>                                       Usc(thelaw(D2)))
>>                                       {move
>>                                       13}



                                    define \
                                       eqhypa2 \
                                       eqhyp2: \
                                       Oridem(Iff1(eqhyp2, \
                                       Ui G, \
                                       Pair(thelaw \
                                       D2,thelaw \
                                       D2)))


>>                                     eqhypa2:
>>                                       [(eqhyp2_1:
>>                                          that (G
>>                                          E Usc(thelaw(D2))))
>>                                          => (---:
>>                                          that (G
>>                                          = thelaw(D2)))]
>>                                       {move
>>                                       12}



                                    define \
                                       line50 \
                                       eqhyp2: \
                                       Subs1 \
                                       eqhypa2 \
                                       eqhyp2 \
                                       otherdir


>>                                     line50:
>>                                       [(eqhyp2_1:
>>                                          that (G
>>                                          E Usc(thelaw(D2))))
>>                                          => (---:
>>                                          that (thelaw(D2)
>>                                          E B))]
>>                                       {move
>>                                       12}



                                    open


                                       declare \
                                          impossiblesub \
                                          that B \
                                          <<= prime \
                                          D2

>>                                        impossiblesub:
>>                                          that (B
>>                                          <<= prime(D2))
>>                                          {move 14}



                                       define \
                                          line51 \
                                          impossiblesub: \
                                          Mp(line50 \
                                          eqhyp2, \
                                          Ui \
                                          (thelaw \
                                          D2, Simp1 \
                                          impossiblesub))


>>                                        line51:
>>                                          [(impossiblesub_1:
>>                                             that
>>                                             (B <<=
>>                                             prime(D2)))
>>                                             => (---:
>>                                             that
>>                                             (thelaw(D2)
>>                                             E prime(D2)))]
>>                                          {move 13}



                                       define \
                                          line52 \
                                          impossiblesub: \
                                          Iff1(line51 \
                                          impossiblesub, \
                                          Ui thelaw \
                                          D2,Separation4 \
                                          Refleq \
                                          prime \
                                          D2)

>>                                        line52:
>>                                          [(impossiblesub_1:
>>                                             that
>>                                             (B <<=
>>                                             prime(D2)))
>>                                             => (---:
>>                                             that
>>                                             ((thelaw(D2)
>>                                             E D2)
>>                                             & ~((thelaw(D2)
>>                                             E Usc(thelaw(D2))))))]
>>                                          {move 13}



                                       define \
                                          line53 \
                                          impossiblesub: \
                                          Mp(Inusc2 \
                                          thelaw \
                                          D2, Simp2 \
                                          line52 \
                                          impossiblesub)


>>                                        line53:
>>                                          [(impossiblesub_1:
>>                                             that
>>                                             (B <<=
>>                                             prime(D2)))
>>                                             => (---:
>>                                             that
>>                                             ??)]
>>                                          {move 13}



                                       close

                                    define \
                                       line54 \
                                       eqhyp2 \
                                       : Negintro \
                                       line53


>>                                     line54:
>>                                       [(eqhyp2_1:
>>                                          that (G
>>                                          E Usc(thelaw(D2))))
>>                                          => (---:
>>                                          that ~((B
>>                                          <<= prime(D2))))]
>>                                       {move
>>                                       12}



                                    define \
                                       line55 \
                                       eqhyp2: \
                                       Ds1 \
                                       line29 \
                                       dhyp \
                                       line54 \
                                       eqhyp2


>>                                     line55:
>>                                       [(eqhyp2_1:
>>                                          that (G
>>                                          E Usc(thelaw(D2))))
>>                                          => (---:
>>                                          that (prime(D2)
>>                                          <<= B))]
>>                                       {move
>>                                       12}



                                    open


                                       declare \
                                          H obj


>>                                        H: obj
>>                                          {move 14}



                                       open

                                          declare \
                                             hhyp \
                                             that \
                                             H E \
                                             D2


>>                                           hhyp:
>>                                             that
>>                                             (H E
>>                                             D2)
>>                                             {move
>>                                             15}



                                          define \
                                             line56: \
                                             Excmid( \
                                             H = \
                                             thelaw \
                                             D2)


>>                                           line56: [(---:
>>                                                that ((H
>>                                                = thelaw(D2))
>>                                                V ~((H
>>                                                = thelaw(D2)))))]
>>                                             {move 14}



                                          open

                                             declare \
                                                casehhyp1 \
                                                that H \
                                                = thelaw \
                                                D2

>>                                              casehhyp1:
>>                                                that (H
>>                                                = thelaw(D2))
>>                                                {move 16}



                                             declare \
                                                casehhyp2 \
                                                that ~(H \
                                                = thelaw \
                                                D2)

>>                                              casehhyp2:
>>                                                that ~((H
>>                                                = thelaw(D2)))
>>                                                {move 16}



                                             define \
                                                line57 \
                                                casehhyp1: \
                                                Subs1(Eqsymm \
                                                casehhyp1, \
                                                line50 \
                                                eqhyp2)


>>                                              line57:
>>                                                [(casehhyp1_1:
>>                                                   that
>>                                                   (H =
>>                                                   thelaw(D2)))
>>                                                   => (---:
>>                                                   that
>>                                                   (H E
>>                                                   B))]
>>                                                {move 15}



                                             open

                                                declare \
                                                   sillyhyp \
                                                   that \
                                                   H E \
                                                   Usc \
                                                   thelaw \
                                                   D2


>>                                                 sillyhyp:
>>                                                   that
>>                                                   (H E
>>                                                   Usc(thelaw(D2)))
>>                                                   {move
>>                                                   17}



                                                define \
                                                   line58 \
                                                   sillyhyp: \
                                                   Mp(Oridem(Iff1(sillyhyp, \
                                                   Ui \
                                                   H, \
                                                   Pair(thelaw \
                                                   D2, \
                                                   thelaw \
                                                   D2))), \
                                                   casehhyp2)


>>                                                 line58: [(sillyhyp_1:
>>                                                      that (H
>>                                                      E Usc(thelaw(D2))))
>>                                                      => (---:
>>                                                      that ??)]
>>                                                   {move 16}



                                                close

                                             define line59 \
                                                casehhyp2: Negintro \
                                                line58

>>                                              line59: [(casehhyp2_1:
>>                                                   that ~((H
>>                                                   = thelaw(D2))))
>>                                                   => (---:that
>>                                                   ~((H E Usc(thelaw(D2)))))]
>>                                                {move 15}



                                             define line60 \
                                                casehhyp2: Fixform(H \
                                                E prime D2, \
                                                Iff2(Conj(hhyp, \
                                                line59 casehhyp2), \
                                                Ui H,Separation4 \
                                                Refleq prime \
                                                D2))

>>                                              line60: [(casehhyp2_1:
>>                                                   that ~((H
>>                                                   = thelaw(D2))))
>>                                                   => (---:that
>>                                                   (H E prime(D2)))]
>>                                                {move 15}



                                             define line61 \
                                                casehhyp2: Mp(line60 \
                                                casehhyp2, Ui \
                                                H,Simp1 line55 \
                                                eqhyp2)

>>                                              line61: [(casehhyp2_1:
>>                                                   that ~((H
>>                                                   = thelaw(D2))))
>>                                                   => (---:that
>>                                                   (H E B))]
>>                                                {move 15}



                                             close

                                          define line62 hhyp: \
                                             Cases line56 line57, \
                                             line61

>>                                           line62: [(hhyp_1:
>>                                                that (H E D2))
>>                                                => (---:that
>>                                                (H E B))]
>>                                             {move 14}



                                          close

                                       define line63 H: Ded \
                                          line62

>>                                        line63: [(H_1:obj)
>>                                             => (---:that ((H_1
>>                                             E D2) -> (H_1 E
>>                                             B)))]
>>                                          {move 13}



                                       close

                                    define \
                                       line64 \
                                       eqhyp2: \
                                       Ug line63


>>                                     line64:
>>                                       [(eqhyp2_1:
>>                                          that (G
>>                                          E Usc(thelaw(D2))))
>>                                          => (---:
>>                                          that Forall([(H_16:
>>                                             obj)
>>                                             => (((H_16
>>                                             E D2)
>>                                             -> (H_16
>>                                             E B)):
>>                                             prop)]))
>>                                          ]
>>                                       {move
>>                                       12}



                                    define \
                                       line65 \
                                       eqhyp2: \
                                       Fixform(D2 \
                                       <<= \
                                       B, Conj(line64 \
                                       eqhyp2, \
                                       Conj(Simp2 \
                                       Simp2 \
                                       casehyp2 \
                                       ,linea14 \
                                       bhyp)))


>>                                     line65:
>>                                       [(eqhyp2_1:
>>                                          that (G
>>                                          E Usc(thelaw(D2))))
>>                                          => (---:
>>                                          that (D2
>>                                          <<= B))]
>>                                       {move
>>                                       12}



                                    define \
                                       line66 \
                                       eqhyp2 \
                                       : Antisymsub(casehyp2, \
                                       line65 \
                                       eqhyp2)


>>                                     line66:
>>                                       [(eqhyp2_1:
>>                                          that (G
>>                                          E Usc(thelaw(D2))))
>>                                          => (---:
>>                                          that (B
>>                                          = D2))]
>>                                       {move
>>                                       12}



                                    define \
                                       line67 \
                                       eqhyp2 \
                                       : Mp(Refleq \
                                       thelaw \
                                       D2, \
                                       Subs1(line66 \
                                       eqhyp2, \
                                       casehypa2))


>>                                     line67:
>>                                       [(eqhyp2_1:
>>                                          that (G
>>                                          E Usc(thelaw(D2))))
>>                                          => (---:
>>                                          that ??)]
>>                                       {move
>>                                       12}



                                    close


                                 define line68 \
                                    otherdir: \
                                    Fixform(G \
                                    E prime \
                                    D2,Iff2(Conj(line49 \
                                    otherdir, \
                                    Negintro \
                                    line67), \
                                    Ui G, Separation4 \
                                    Refleq \
                                    prime D2))


>>                                  line68:
>>                                    [(otherdir_1:
>>                                       that
>>                                       (G E
>>                                       B)) =>
>>                                       (---:
>>                                       that
>>                                       (G E
>>                                       prime(D2)))]
>>                                    {move 11}



                                 close

                              define line69 \
                                 G: Ded \
                                 line68

>>                               line69: [(G_1:
>>                                    obj) =>
>>                                    (---:that
>>                                    ((G_1 E
>>                                    B) -> (G_1
>>                                    E prime(D2))))]
>>                                 {move 10}



                              define testline \
                                 G: Ded \
                                 linea48

>>                               testline: [(G_1:
>>                                    obj) =>
>>                                    (---:that
>>                                    ((G_1 E
>>                                    prime(D2))
>>                                    -> (G_1
>>                                    E prime(B))))]
>>                                 {move 10}



                              close

                           define line70 \
                              casehypa2: Ug \
                              line69

>>                            line70: [(casehypa2_1:
>>                                 that ~((thelaw(D2)
>>                                 = thelaw(B))))
>>                                 => (---:that
>>                                 Forall([(G_39:
>>                                    obj) =>
>>                                    (((G_39
>>                                    E B) ->
>>                                    (G_39 E
>>                                    prime(D2))):
>>                                    prop)]))
>>                                 ]
>>                              {move 9}



                           define line71 \
                              casehypa2: Add2((prime \
                              D2) <<= prime \
                              B, Fixform(B \
                              <<= prime D2, \
                              Conj(line70 casehypa2, \
                              Conj(linea14 \
                              bhyp, Separation3 \
                              Refleq prime \
                              D2))))

>>                            line71: [(casehypa2_1:
>>                                 that ~((thelaw(D2)
>>                                 = thelaw(B))))
>>                                 => (---:that
>>                                 ((prime(D2)
>>                                 <<= prime(B))
>>                                 V (B <<= prime(D2))))]
>>                              {move 9}



                           define testline2 \
                              casehypa1: Ug \
                              testline

>>                            testline2: [(casehypa1_1:
>>                                 that (thelaw(D2)
>>                                 = thelaw(B)))
>>                                 => (---:that
>>                                 Forall([(G_22:
>>                                    obj) =>
>>                                    (((G_22
>>                                    E prime(D2))
>>                                    -> (G_22
>>                                    E prime(B))):
>>                                    prop)]))
>>                                 ]
>>                              {move 9}



                           define line72 \
                              casehypa1: Add1(B \
                              <<= prime D2, \
                              Fixform((prime \
                              D2) <<= prime \
                              B, Conj(testline2 \
                              casehypa1, Conj(Separation3 \
                              Refleq prime \
                              D2, Separation3 \
                              Refleq prime \
                              B))))

>>                            line72: [(casehypa1_1:
>>                                 that (thelaw(D2)
>>                                 = thelaw(B)))
>>                                 => (---:that
>>                                 ((prime(D2)
>>                                 <<= prime(B))
>>                                 V (B <<= prime(D2))))]
>>                              {move 9}



                           close

                        define line73 \
                           casehyp2:Cases line31 \
                           line72, line71

>>                         line73: [(casehyp2_1:
>>                              that (B <<= D2))
>>                              => (---:that ((prime(D2)
>>                              <<= prime(B))
>>                              V (B <<= prime(D2))))]
>>                           {move 8}



                        close

                     define line74 Casehyp2: \
                        Cases (line25 dhyp, \
                        linea30, line73)

>>                      line74: [(Casehyp2_1:
>>                           that Exists([(U_2:
>>                              obj) => ((U_2
>>                              E B):prop)]))
>>                           => (---:that ((prime(D2)
>>                           <<= prime(B)) V (B
>>                           <<= prime(D2))))]
>>                        {move 7}



                     close

                  define line75 dhyp: \
                     Cases(linea14 bhyp , linea29, \
                     line74)

>>                   line75: [(dhyp_1:that (D2
>>                        E Cuts2)) => (---:that
>>                        ((prime(D2) <<= prime(B))
>>                        V (B <<= (D2 Set [(x_86:
>>                           obj) => (~((x_86
>>                           E Usc(thelaw(D2)))):
>>                           prop)]))
>>                        ))]
>>                     {move 6}



                  define line76 dhyp: \
                     Fixform((prime D2) E Cuts2, \
                     Iff2(Conj(line28 dhyp, \
                     line75 dhyp), Ui prime \
                     D2,Separation4 Refleq \
                     Cuts2))

>>                   line76: [(dhyp_1:that (D2
>>                        E Cuts2)) => (---:that
>>                        (prime(D2) E Cuts2))]
>>                     {move 6}



                  close

               define line77 D2: Ded line76

