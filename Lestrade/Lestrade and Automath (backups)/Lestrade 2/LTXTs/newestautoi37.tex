\documentclass{article}

\begin{document}

\begin{verbatim}

begin Lestrade execution
>>>
>>>
>>>>> Inspector Lestrade says:  
>>>>> Welcome to the Lestrade Type Inspector,
>>>>>  
>>>>> User entered lambda terms (arguments)
>>>>> and function sorts (in declare)!
>>>>> literate programming with LaTeX comments in ML source
>>>>> version of  8/6/2019
>>>>>  10:30 am Boise time
>>>
>>>
>>> comment  comment  Automath file 37 translation.  This must be run with the Lestrade version of
 comment  comment  Automath file 37 translation.  This must be run with the Lestrade version of
>>> comment  comment  July 8 or later, with changes in saved world management.  The new saved world
 comment  comment  July 8 or later, with changes in saved world management.  The new saved world
>>> comment  comment  management allows simulation of the Automath context device, and prevents
 comment  comment  management allows simulation of the Automath context device, and prevents
>>> comment  name cluttering of world 1.
 comment  name cluttering of world 1.

>>>
>>> comment  this version makes full use of implicit arguments.  Proof lines are generally much shorter.
 comment  this version makes full use of implicit arguments.  Proof lines are generally much shorter.

>>>
>>> comment  comment  odd name changes because a declared identifier now cannot end with the numeral 9 unless
 comment  comment  odd name changes because a declared identifier now cannot end with the numeral 9 unless
>>> comment  it is a numeral
 comment  it is a numeral

>>>
>>> comment   * A := EB ; PROP
 comment   * A := EB ; PROP

>>>
>>>
>>>declare A prop

declare A prop

>> A: prop {move 1}


>>>
>>>>> A: prop {move 1}
>>>
>>>
>>> comment  A * B := EB  ; PROP
 comment  A * B := EB  ; PROP

>>>
>>>
>>>declare B prop

declare B prop

>> B: prop {move 1}


>>>
>>>>> B: prop {move 1}
>>>
>>>
>>> comment  B * IMP := [T,A]B  ;PROP
 comment  B * IMP := [T,A]B  ;PROP

>>>
>>>
>>>save B

save B
>>>
>>>postulate Imp A B : prop

postulate Imp A B : prop

>> Imp: [(A_1:prop),(B_1:prop) => (---:prop)]
>>   {move 0}


>>>
>>>>> Imp: [(A_1:prop),(B_1:prop) => (---:prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare T that A

   declare T that A

>>    T: that A {move 2}


>>>
>>>>>    T: that A {move 2}
>>>
>>>
>>>
>>>   postulate Ded T: that B

   postulate Ded T: that B

>>    Ded: [(T_1:that A) => (---:that B)]
>>      {move 1:B}


>>>
>>>>>    Ded: [(T_1:that A) => (---:that B)]
>>>>>      {move 1:B}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>postulate Imppf Ded : that Imp A B

postulate Imppf Ded : that Imp A B

>> Imppf: [(.A_1:prop),(.B_1:prop),(Ded_1:[(T_2:
>>         that .A_1) => (---:that .B_1)])
>>      => (---:that (.A_1 Imp .B_1))]
>>   {move 0}


>>>
>>>>> Imppf: [(.A_1:prop),(.B_1:prop),(Ded_1:[(T_2:
>>>>>         that .A_1) => (---:that .B_1)])
>>>>>      => (---:that (.A_1 Imp .B_1))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>postulate Imppffull A B Ded : that Imp A \
   B

postulate Imppffull A B Ded : that Imp A \
   B

>> Imppffull: [(A_1:prop),(B_1:prop),(Ded_1:
>>      [(T_2:that A_1) => (---:that B_1)])
>>      => (---:that (A_1 Imp B_1))]
>>   {move 0}


>>>
>>>>> Imppffull: [(A_1:prop),(B_1:prop),(Ded_1:
>>>>>      [(T_2:that A_1) => (---:that B_1)])
>>>>>      => (---:that (A_1 Imp B_1))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>declare X that A

declare X that A

>> X: that A {move 1:B}


>>>
>>>>> X: that A {move 1:B}
>>>
>>>
>>>
>>>declare Y that A Imp B

declare Y that A Imp B

>> Y: that (A Imp B) {move 1:B}


>>>
>>>>> Y: that (A Imp B) {move 1:B}
>>>
>>>
>>>
>>>postulate Mp X Y : that B

postulate Mp X Y : that B

>> Mp: [(.A_1:prop),(X_1:that .A_1),(.B_1:prop),
>>      (Y_1:that (.A_1 Imp .B_1)) => (---:that
>>      .B_1)]
>>   {move 0}


>>>
>>>>> Mp: [(.A_1:prop),(X_1:that .A_1),(.B_1:prop),
>>>>>      (Y_1:that (.A_1 Imp .B_1)) => (---:that
>>>>>      .B_1)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>postulate Mpfull A B X Y : that B

postulate Mpfull A B X Y : that B

>> Mpfull: [(A_1:prop),(B_1:prop),(X_1:that
>>      A_1),(Y_1:that (A_1 Imp B_1)) => (---:
>>      that B_1)]
>>   {move 0}


>>>
>>>>> Mpfull: [(A_1:prop),(B_1:prop),(X_1:that
>>>>>      A_1),(Y_1:that (A_1 Imp B_1)) => (---:
>>>>>      that B_1)]
>>>>>   {move 0}
>>>
>>>
>>> comment  comment  This is a universal device for 
 comment  comment  This is a universal device for 
>>> comment  comment  fixing forms of conclusions
 comment  comment  fixing forms of conclusions
>>> comment  comment  which would otherwise come out wrong 
 comment  comment  which would otherwise come out wrong 
>>> comment  due to expansion of definitions.
 comment  due to expansion of definitions.

>>>
>>>
>>>declare p66 prop

declare p66 prop

>> p66: prop {move 1:B}


>>>
>>>>> p66: prop {move 1:B}
>>>
>>>
>>>
>>>declare pp66 that p66

declare pp66 that p66

>> pp66: that p66 {move 1:B}


>>>
>>>>> pp66: that p66 {move 1:B}
>>>
>>>
>>>
>>>define Fixfun p66 pp66:pp66

define Fixfun p66 pp66:pp66

>> Fixfun: [(p66_1:prop),(pp66_1:that p66_1)
>>      => (pp66_1:that p66_1)]
>>   {move 0}


>>>
>>>>> Fixfun: [(p66_1:prop),(pp66_1:that p66_1)
>>>>>      => (pp66_1:that p66_1)]
>>>>>   {move 0}
>>>
>>>
>>> comment  open
 comment  open

>>>
>>> comment  declare pp67 that p66
 comment  declare pp67 that p66

>>>
>>> comment  define pid66 pp67: pp67
 comment  define pid66 pp67: pp67

>>>
>>> comment  close
 comment  close

>>>
>>> comment  define Fixfun p66 pp66 : Mp pp66, Imppffull p66 p66 pid66
 comment  define Fixfun p66 pp66 : Mp pp66, Imppffull p66 p66 pid66

>>>
>>> comment    *  CON  := PN  ;PROP
 comment    *  CON  := PN  ;PROP

>>>
>>>
>>>postulate Con prop

postulate Con prop

>> Con: prop {move 0}


>>>
>>>>> Con: prop {move 0}
>>>
>>>
>>> comment  A * NOT  := IMP(A,CON) ; PROP
 comment  A * NOT  := IMP(A,CON) ; PROP

>>>
>>>
>>>define Not A : A Imp Con

define Not A : A Imp Con

>> Not: [(A_1:prop) => ((A_1 Imp Con):prop)]
>>   {move 0}


>>>
>>>>> Not: [(A_1:prop) => ((A_1 Imp Con):prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare Xx that A Imp Con

   declare Xx that A Imp Con

>>    Xx: that (A Imp Con) {move 2}


>>>
>>>>>    Xx: that (A Imp Con) {move 2}
>>>
>>>
>>>
>>>   define negfix Xx : Xx

   define negfix Xx : Xx

>>    negfix: [(Xx_1:that (A Imp Con)) => (---:
>>         that (A Imp Con))]
>>      {move 1:B}


>>>
>>>>>    negfix: [(Xx_1:that (A Imp Con)) => (---:
>>>>>         that (A Imp Con))]
>>>>>      {move 1:B}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Negfix A : Imppffull (A Imp Con, Not \
   A, negfix)

define Negfix A : Imppffull (A Imp Con, Not \
   A, negfix)

>> Negfix: [(A_1:prop) => (Imppffull((A_1 Imp
>>      Con),Not(A_1),[(Xx_2:that (A_1 Imp Con))
>>         => (Xx_2:that (A_1 Imp Con))])
>>      :that ((A_1 Imp Con) Imp Not(A_1)))]
>>   {move 0}


>>>
>>>>> Negfix: [(A_1:prop) => (Imppffull((A_1 Imp
>>>>>      Con),Not(A_1),[(Xx_2:that (A_1 Imp Con))
>>>>>         => (Xx_2:that (A_1 Imp Con))])
>>>>>      :that ((A_1 Imp Con) Imp Not(A_1)))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare aa that A

   declare aa that A

>>    aa: that A {move 2}


>>>
>>>>>    aa: that A {move 2}
>>>
>>>
>>>
>>>   postulate neg aa : that Con

   postulate neg aa : that Con

>>    neg: [(aa_1:that A) => (---:that Con)]
>>      {move 1:B}


>>>
>>>>>    neg: [(aa_1:that A) => (---:that Con)]
>>>>>      {move 1:B}
>>>
>>>
>>>
>>>   close

   close
>>> comment define Negproof neg:  Mp (Imppf neg, Negfix A)
 comment define Negproof neg:  Mp (Imppf neg, Negfix A)

>>>
>>>
>>>define Negproof neg: Fixfun(Not A,Imppf neg)

define Negproof neg: Fixfun(Not A,Imppf neg)


>> Negproof: [(.A_1:prop),(neg_1:[(aa_2:that
>>         .A_1) => (---:that Con)])
>>      => ((Not(.A_1) Fixfun Imppf(neg_1)):that
>>      Not(.A_1))]
>>   {move 0}


>>>
>>>
>>>>> Negproof: [(.A_1:prop),(neg_1:[(aa_2:that
>>>>>         .A_1) => (---:that Con)])
>>>>>      => ((Not(.A_1) Fixfun Imppf(neg_1)):that
>>>>>      Not(.A_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * I  :=EB  ; IMP(A,B)
 comment  B * I  :=EB  ; IMP(A,B)

>>>
>>>clearcurrent B
clearcurrent B

>>>
>>>
>>>declare I that A Imp B

declare I that A Imp B

>> I: that (A Imp B) {move 1:B}


>>>
>>>>> I: that (A Imp B) {move 1:B}
>>>
>>>
>>>
>>>save I

save I
>>> comment  I * N  := E3  ;NOT(B)
 comment  I * N  := E3  ;NOT(B)

>>>
>>>
>>>declare N that Not B

declare N that Not B

>> N: that Not(B) {move 1:I}


>>>
>>>>> N: that Not(B) {move 1:I}
>>>
>>>
>>> comment  N *  CONTRAPOS := [T,A]<<T>I>N  ;NOT(A)
 comment  N *  CONTRAPOS := [T,A]<<T>I>N  ;NOT(A)

>>>
>>>
>>>open

open
>>>
>>>   declare T that A

   declare T that A

>>    T: that A {move 2}


>>>
>>>>>    T: that A {move 2}
>>>
>>>
>>>
>>>   define step1 T : Mp T I

   define step1 T : Mp T I

>>    step1: [(T_1:that A) => (---:that B)]
>>      {move 1:I}


>>>
>>>>>    step1: [(T_1:that A) => (---:that B)]
>>>>>      {move 1:I}
>>>
>>>
>>>
>>>   define step2 T : Mp (step1 T, N)

   define step2 T : Mp (step1 T, N)

>>    step2: [(T_1:that A) => (---:that Con)]
>>      {move 1:I}


>>>
>>>>>    step2: [(T_1:that A) => (---:that Con)]
>>>>>      {move 1:I}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Contrapos I N : Negproof step2

define Contrapos I N : Negproof step2

>> Contrapos: [(.A_1:prop),(.B_1:prop),(I_1:
>>      that (.A_1 Imp .B_1)),(N_1:that Not(.B_1))
>>      => (Negproof([(T_2:that .A_1) => (((T_2
>>         Mp I_1) Mp N_1):that Con)])
>>      :that Not(.A_1))]
>>   {move 0}


>>>
>>>>> Contrapos: [(.A_1:prop),(.B_1:prop),(I_1:
>>>>>      that (.A_1 Imp .B_1)),(N_1:that Not(.B_1))
>>>>>      => (Negproof([(T_2:that .A_1) => (((T_2
>>>>>         Mp I_1) Mp N_1):that Con)])
>>>>>      :that Not(.A_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  A * A0  := EB   ;A
 comment  A * A0  := EB   ;A

>>>
>>>clearcurrent I
clearcurrent I

>>>
>>>
>>>declare A0 that A

declare A0 that A

>> A0: that A {move 1:I}


>>>
>>>>> A0: that A {move 1:I}
>>>
>>>
>>>
>>>save A0

save A0
>>> comment  A0 * TH1  := [T,NOT(A)]<A0>[T]  ; NOT(NOT(A))
 comment  A0 * TH1  := [T,NOT(A)]<A0>[T]  ; NOT(NOT(A))

>>>
>>>
>>>open

open
>>>
>>>   declare T that Not A

   declare T that Not A

>>    T: that Not(A) {move 2}


>>>
>>>>>    T: that Not(A) {move 2}
>>>
>>>
>>>
>>>   define step1 T : Mp A0 T

   define step1 T : Mp A0 T

>>    step1: [(T_1:that Not(A)) => (---:that
>>         Con)]
>>      {move 1:A0}


>>>
>>>>>    step1: [(T_1:that Not(A)) => (---:that
>>>>>         Con)]
>>>>>      {move 1:A0}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Th1 A0 : Negproof step1

define Th1 A0 : Negproof step1

>> Th1: [(.A_1:prop),(A0_1:that .A_1) => (Negproof([(T_2:
>>         that Not(.A_1)) => ((A0_1 Mp T_2):that
>>         Con)])
>>      :that Not(Not(.A_1)))]
>>   {move 0}


>>>
>>>>> Th1: [(.A_1:prop),(A0_1:that .A_1) => (Negproof([(T_2:
>>>>>         that Not(.A_1)) => ((A0_1 Mp T_2):that
>>>>>         Con)])
>>>>>      :that Not(Not(.A_1)))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent A0
clearcurrent A0

>>>
>>>
>>>save A0

save A0
>>> comment  A * N :=EB  ; NOT(NOT(A))
 comment  A * N :=EB  ; NOT(NOT(A))

>>>
>>>
>>>declare N that Not Not A

declare N that Not Not A

>> N: that Not(Not(A)) {move 1:A0}


>>>
>>>>> N: that Not(Not(A)) {move 1:A0}
>>>
>>>
>>> comment  N * DBLNEGLAW := PN  ; A
 comment  N * DBLNEGLAW := PN  ; A

>>>
>>>
>>>postulate Dblneglaw N : that A

postulate Dblneglaw N : that A

>> Dblneglaw: [(.A_1:prop),(N_1:that Not(Not(.A_1)))
>>      => (---:that .A_1)]
>>   {move 0}


>>>
>>>>> Dblneglaw: [(.A_1:prop),(N_1:that Not(Not(.A_1)))
>>>>>      => (---:that .A_1)]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * I  := EB ;IMP(A,B)
 comment  B * I  := EB ;IMP(A,B)

>>>
>>> comment  already declared
 comment  already declared

>>>
>>> comment  I * J := EB  ;IMP(NOT(A),B)
 comment  I * J := EB  ;IMP(NOT(A),B)

>>>
>>>
>>>declare J that (Not A) Imp B

declare J that (Not A) Imp B

>> J: that (Not(A) Imp B) {move 1:A0}


>>>
>>>>> J: that (Not(A) Imp B) {move 1:A0}
>>>
>>>
>>> comment  J * ANYCASE := DBLNEGLAW(B,[T,NOT(B)]<<CONTRAPOS(A,B,I,T)>J>T) ; B
 comment  J * ANYCASE := DBLNEGLAW(B,[T,NOT(B)]<<CONTRAPOS(A,B,I,T)>J>T) ; B

>>>
>>>
>>>open

open
>>>
>>>   declare bb that Not B

   declare bb that Not B

>>    bb: that Not(B) {move 2}


>>>
>>>>>    bb: that Not(B) {move 2}
>>>
>>>
>>>
>>>   define step1 bb : Contrapos I bb

   define step1 bb : Contrapos I bb

>>    step1: [(bb_1:that Not(B)) => (---:that
>>         Not(A))]
>>      {move 1:A0}


>>>
>>>>>    step1: [(bb_1:that Not(B)) => (---:that
>>>>>         Not(A))]
>>>>>      {move 1:A0}
>>>
>>>
>>>
>>>   define step2 bb : Contrapos (J, bb)

   define step2 bb : Contrapos (J, bb)

>>    step2: [(bb_1:that Not(B)) => (---:that
>>         Not(Not(A)))]
>>      {move 1:A0}


>>>
>>>>>    step2: [(bb_1:that Not(B)) => (---:that
>>>>>         Not(Not(A)))]
>>>>>      {move 1:A0}
>>>
>>>
>>>
>>>   define step3 bb: Mp (step1 bb,step2 bb)

   define step3 bb: Mp (step1 bb,step2 bb)


>>    step3: [(bb_1:that Not(B)) => (---:that
>>         Con)]
>>      {move 1:A0}


>>>
>>>
>>>>>    step3: [(bb_1:that Not(B)) => (---:that
>>>>>         Con)]
>>>>>      {move 1:A0}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Anycase I J : Dblneglaw (Negproof \
   (step3))

define Anycase I J : Dblneglaw (Negproof \
   (step3))

>> Anycase: [(.A_1:prop),(.B_1:prop),(I_1:that
>>      (.A_1 Imp .B_1)),(J_1:that (Not(.A_1)
>>      Imp .B_1)) => (Dblneglaw(Negproof([(bb_2:
>>         that Not(.B_1)) => (((I_1 Contrapos
>>         bb_2) Mp (J_1 Contrapos bb_2)):that
>>         Con)]))
>>      :that .B_1)]
>>   {move 0}


>>>
>>>>> Anycase: [(.A_1:prop),(.B_1:prop),(I_1:that
>>>>>      (.A_1 Imp .B_1)),(J_1:that (Not(.A_1)
>>>>>      Imp .B_1)) => (Dblneglaw(Negproof([(bb_2:
>>>>>         that Not(.B_1)) => (((I_1 Contrapos
>>>>>         bb_2) Mp (J_1 Contrapos bb_2)):that
>>>>>         Con)]))
>>>>>      :that .B_1)]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent I
clearcurrent I

>>>
>>>
>>>save I

save I
>>> comment  B * N := EB  ;NOT(A)
 comment  B * N := EB  ;NOT(A)

>>>
>>>
>>>declare N that Not A

declare N that Not A

>> N: that Not(A) {move 1:I}


>>>
>>>>> N: that Not(A) {move 1:I}
>>>
>>>
>>> comment  N  comment  TH2 := [T,A]DBLNEGLAW(B,[U,NOT(B)]<T>N ;IMP(A,B)
 comment  N  comment  TH2 := [T,A]DBLNEGLAW(B,[U,NOT(B)]<T>N ;IMP(A,B)

>>>
>>>
>>>open

open
>>>
>>>   declare T that A

   declare T that A

>>    T: that A {move 2}


>>>
>>>>>    T: that A {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare U that Not B

      declare U that Not B

>>       U: that Not(B) {move 3}


>>>
>>>>>       U: that Not(B) {move 3}
>>>
>>>
>>>
>>>      define step1 U : Mp T N

      define step1 U : Mp T N

>>       step1: [(U_1:that Not(B)) => (---:that
>>            Con)]
>>         {move 2}


>>>
>>>>>       step1: [(U_1:that Not(B)) => (---:that
>>>>>            Con)]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define step2 T : Dblneglaw (Negproof (step1))

   define step2 T : Dblneglaw (Negproof (step1))


>>    step2: [(T_1:that A) => (---:that B)]
>>      {move 1:I}


>>>
>>>
>>>>>    step2: [(T_1:that A) => (---:that B)]
>>>>>      {move 1:I}
>>>
>>>
>>>
>>>   close

   close
>>> comment  comment  Notice that Th2 has a proposition parameter,
 comment  comment  Notice that Th2 has a proposition parameter,
>>> comment  comment  because B cannot be extracted from the argument
 comment  comment  because B cannot be extracted from the argument
>>> comment  supplied (a proof of not A).
 comment  supplied (a proof of not A).

>>>
>>>
>>>define Th2 B N : Imppf step2

define Th2 B N : Imppf step2

>> Th2: [(B_1:prop),(.A_1:prop),(N_1:that Not(.A_1))
>>      => (Imppf([(T_2:that .A_1) => (Dblneglaw(Negproof([(U_3:
>>            that Not(B_1)) => ((T_2 Mp N_1):
>>            that Con)]))
>>         :that B_1)])
>>      :that (.A_1 Imp B_1))]
>>   {move 0}


>>>
>>>>> Th2: [(B_1:prop),(.A_1:prop),(N_1:that Not(.A_1))
>>>>>      => (Imppf([(T_2:that .A_1) => (Dblneglaw(Negproof([(U_3:
>>>>>            that Not(B_1)) => ((T_2 Mp N_1):
>>>>>            that Con)]))
>>>>>         :that B_1)])
>>>>>      :that (.A_1 Imp B_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * A0 := EB  ; A
 comment  B * A0 := EB  ; A

>>>
>>> comment  already declared
 comment  already declared

>>>
>>> comment  A0 * N := EB ; NOT(B)
 comment  A0 * N := EB ; NOT(B)

>>>
>>>clearcurrent A0
clearcurrent A0

>>>
>>>
>>>save A0

save A0
>>>
>>>declare N that Not B

declare N that Not B

>> N: that Not(B) {move 1:A0}


>>>
>>>>> N: that Not(B) {move 1:A0}
>>>
>>>
>>> comment   N * TH3 := [T,IMP(A,B)]<<A0>T>N ;NOT(IMP(A,B))
 comment   N * TH3 := [T,IMP(A,B)]<<A0>T>N ;NOT(IMP(A,B))

>>>
>>>
>>>open

open
>>>
>>>   declare T that Imp A B

   declare T that Imp A B

>>    T: that (A Imp B) {move 2}


>>>
>>>>>    T: that (A Imp B) {move 2}
>>>
>>>
>>>
>>>   define step1 T : Mp A0 T

   define step1 T : Mp A0 T

>>    step1: [(T_1:that (A Imp B)) => (---:that
>>         B)]
>>      {move 1:A0}


>>>
>>>>>    step1: [(T_1:that (A Imp B)) => (---:that
>>>>>         B)]
>>>>>      {move 1:A0}
>>>
>>>
>>>
>>>   define step2 T : Mp (step1 T, N)

   define step2 T : Mp (step1 T, N)

>>    step2: [(T_1:that (A Imp B)) => (---:that
>>         Con)]
>>      {move 1:A0}


>>>
>>>>>    step2: [(T_1:that (A Imp B)) => (---:that
>>>>>         Con)]
>>>>>      {move 1:A0}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Th3 A0 N : Negproof(step2)

define Th3 A0 N : Negproof(step2)

>> Th3: [(.A_1:prop),(A0_1:that .A_1),(.B_1:
>>      prop),(N_1:that Not(.B_1)) => (Negproof([(T_2:
>>         that (.A_1 Imp .B_1)) => (((A0_1 Mp
>>         T_2) Mp N_1):that Con)])
>>      :that Not((.A_1 Imp .B_1)))]
>>   {move 0}


>>>
>>>>> Th3: [(.A_1:prop),(A0_1:that .A_1),(.B_1:
>>>>>      prop),(N_1:that Not(.B_1)) => (Negproof([(T_2:
>>>>>         that (.A_1 Imp .B_1)) => (((A0_1 Mp
>>>>>         T_2) Mp N_1):that Con)])
>>>>>      :that Not((.A_1 Imp .B_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * N := EB ; NOT(IMP(A,B))
 comment  B * N := EB ; NOT(IMP(A,B))

>>>
>>>clearcurrent I
clearcurrent I

>>>
>>>
>>>save I

save I
>>>
>>>declare N that Not(A Imp B)

declare N that Not(A Imp B)

>> N: that Not((A Imp B)) {move 1:I}


>>>
>>>>> N: that Not((A Imp B)) {move 1:I}
>>>
>>>
>>>
>>>save N

save N
>>> comment  N * TH4 := DBLNEGLAW(A,[T,NOT(A)]<TH2(A,B,T)>N
 comment  N * TH4 := DBLNEGLAW(A,[T,NOT(A)]<TH2(A,B,T)>N

>>>
>>>
>>>open

open
>>>
>>>   declare T that Not A

   declare T that Not A

>>    T: that Not(A) {move 2}


>>>
>>>>>    T: that Not(A) {move 2}
>>>
>>>
>>>
>>>   define step1 T : Th2 B T

   define step1 T : Th2 B T

>>    step1: [(T_1:that Not(A)) => (---:that
>>         (A Imp B))]
>>      {move 1:N}


>>>
>>>>>    step1: [(T_1:that Not(A)) => (---:that
>>>>>         (A Imp B))]
>>>>>      {move 1:N}
>>>
>>>
>>>
>>>   define step2 T: Mp (step1 T, N)

   define step2 T: Mp (step1 T, N)

>>    step2: [(T_1:that Not(A)) => (---:that
>>         Con)]
>>      {move 1:N}


>>>
>>>>>    step2: [(T_1:that Not(A)) => (---:that
>>>>>         Con)]
>>>>>      {move 1:N}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Th4 N : Dblneglaw (Negproof (step2))

define Th4 N : Dblneglaw (Negproof (step2))


>> Th4: [(.A_1:prop),(.B_1:prop),(N_1:that Not((.A_1
>>      Imp .B_1))) => (Dblneglaw(Negproof([(T_2:
>>         that Not(.A_1)) => (((.B_1 Th2 T_2)
>>         Mp N_1):that Con)]))
>>      :that .A_1)]
>>   {move 0}


>>>
>>>
>>>>> Th4: [(.A_1:prop),(.B_1:prop),(N_1:that Not((.A_1
>>>>>      Imp .B_1))) => (Dblneglaw(Negproof([(T_2:
>>>>>         that Not(.A_1)) => (((.B_1 Th2 T_2)
>>>>>         Mp N_1):that Con)]))
>>>>>      :that .A_1)]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent N
clearcurrent N

>>>
>>> comment  N * TH5 := [T,B]<[U,A]T>N
 comment  N * TH5 := [T,B]<[U,A]T>N

>>>
>>>
>>>open

open
>>>
>>>   declare T that B

   declare T that B

>>    T: that B {move 2}


>>>
>>>>>    T: that B {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare U that A

      declare U that A

>>       U: that A {move 3}


>>>
>>>>>       U: that A {move 3}
>>>
>>>
>>>
>>>      define step1 U : T

      define step1 U : T

>>       step1: [(U_1:that A) => (---:that B)]
>>         {move 2}


>>>
>>>>>       step1: [(U_1:that A) => (---:that B)]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define step2 T : Mp ((Imppf step1), N)

   define step2 T : Mp ((Imppf step1), N)


>>    step2: [(T_1:that B) => (---:that Con)]
>>      {move 1:N}


>>>
>>>
>>>>>    step2: [(T_1:that B) => (---:that Con)]
>>>>>      {move 1:N}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Th5 N : Negproof step2

define Th5 N : Negproof step2

>> Th5: [(.A_1:prop),(.B_1:prop),(N_1:that Not((.A_1
>>      Imp .B_1))) => (Negproof([(T_2:that .B_1)
>>         => ((Imppf([(U_3:that .A_1) => (T_2:
>>            that .B_1)])
>>         Mp N_1):that Con)])
>>      :that Not(.B_1))]
>>   {move 0}


>>>
>>>>> Th5: [(.A_1:prop),(.B_1:prop),(N_1:that Not((.A_1
>>>>>      Imp .B_1))) => (Negproof([(T_2:that .B_1)
>>>>>         => ((Imppf([(U_3:that .A_1) => (T_2:
>>>>>            that .B_1)])
>>>>>         Mp N_1):that Con)])
>>>>>      :that Not(.B_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * OR := IMP(NOT(A),B) ; PROP
 comment  B * OR := IMP(NOT(A),B) ; PROP

>>>
>>>clearcurrent I
clearcurrent I

>>>
>>>
>>>save I

save I
>>>
>>>define Or A B : (Not A) Imp B

define Or A B : (Not A) Imp B

>> Or: [(A_1:prop),(B_1:prop) => ((Not(A_1)
>>      Imp B_1):prop)]
>>   {move 0}


>>>
>>>>> Or: [(A_1:prop),(B_1:prop) => ((Not(A_1)
>>>>>      Imp B_1):prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare X2 that (Not A) Imp B

   declare X2 that (Not A) Imp B

>>    X2: that (Not(A) Imp B) {move 2}


>>>
>>>>>    X2: that (Not(A) Imp B) {move 2}
>>>
>>>
>>>
>>>   define orfix X2:X2

   define orfix X2:X2

>>    orfix: [(X2_1:that (Not(A) Imp B)) =>
>>         (---:that (Not(A) Imp B))]
>>      {move 1:I}


>>>
>>>>>    orfix: [(X2_1:that (Not(A) Imp B)) =>
>>>>>         (---:that (Not(A) Imp B))]
>>>>>      {move 1:I}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Orfix A B: Imppffull((Not A) Imp B, \
   Or A B,orfix)

define Orfix A B: Imppffull((Not A) Imp B, \
   Or A B,orfix)

>> Orfix: [(A_1:prop),(B_1:prop) => (Imppffull((Not(A_1)
>>      Imp B_1),(A_1 Or B_1),[(X2_2:that (Not(A_1)
>>         Imp B_1)) => (X2_2:that (Not(A_1) Imp
>>         B_1))])
>>      :that ((Not(A_1) Imp B_1) Imp (A_1 Or
>>      B_1)))]
>>   {move 0}


>>>
>>>>> Orfix: [(A_1:prop),(B_1:prop) => (Imppffull((Not(A_1)
>>>>>      Imp B_1),(A_1 Or B_1),[(X2_2:that (Not(A_1)
>>>>>         Imp B_1)) => (X2_2:that (Not(A_1) Imp
>>>>>         B_1))])
>>>>>      :that ((Not(A_1) Imp B_1) Imp (A_1 Or
>>>>>      B_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * A0 := EB ; A
 comment  B * A0 := EB ; A

>>>
>>>
>>>declare A0 that A

declare A0 that A

>> A0: that A {move 1:I}


>>>
>>>>> A0: that A {move 1:I}
>>>
>>>
>>> comment  A0 * ORI1 := TH2(NOT(A),B,TH1(A,A0)) ; OR(A,B)
 comment  A0 * ORI1 := TH2(NOT(A),B,TH1(A,A0)) ; OR(A,B)

>>>
>>> comment  define Ori1 B A0 : Mp (Th2 (B, Th1  A0),Orfix A,B)
 comment  define Ori1 B A0 : Mp (Th2 (B, Th1  A0),Orfix A,B)

>>>
>>>
>>>define Ori1 B A0: Fixfun(A Or B,Th2(B,Th1 \
   A0))

define Ori1 B A0: Fixfun(A Or B,Th2(B,Th1 \
   A0))

>> Ori1: [(B_1:prop),(.A_1:prop),(A0_1:that
>>      .A_1) => (((.A_1 Or B_1) Fixfun (B_1 Th2
>>      Th1(A0_1))):that (.A_1 Or B_1))]
>>   {move 0}


>>>
>>>>> Ori1: [(B_1:prop),(.A_1:prop),(A0_1:that
>>>>>      .A_1) => (((.A_1 Or B_1) Fixfun (B_1 Th2
>>>>>      Th1(A0_1))):that (.A_1 Or B_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * B0 := EB ; B
 comment  B * B0 := EB ; B

>>>
>>>clearcurrent I
clearcurrent I

>>>
>>>
>>>declare A0 that A

declare A0 that A

>> A0: that A {move 1:I}


>>>
>>>>> A0: that A {move 1:I}
>>>
>>>
>>>
>>>declare B0 that B

declare B0 that B

>> B0: that B {move 1:I}


>>>
>>>>> B0: that B {move 1:I}
>>>
>>>
>>>
>>>save B0

save B0
>>> comment  B0 * ORI2 := [T,NOT(A)]B0 ; OR(A,B)
 comment  B0 * ORI2 := [T,NOT(A)]B0 ; OR(A,B)

>>>
>>>
>>>open

open
>>>
>>>   declare Nn that Not A

   declare Nn that Not A

>>    Nn: that Not(A) {move 2}


>>>
>>>>>    Nn: that Not(A) {move 2}
>>>
>>>
>>>
>>>   define oristep Nn : B0

   define oristep Nn : B0

>>    oristep: [(Nn_1:that Not(A)) => (---:that
>>         B)]
>>      {move 1:B0}


>>>
>>>>>    oristep: [(Nn_1:that Not(A)) => (---:that
>>>>>         B)]
>>>>>      {move 1:B0}
>>>
>>>
>>>
>>>   close

   close
>>> comment define Ori2 A B0 : Mp(Imppf (oristep), Orfix A B)
 comment define Ori2 A B0 : Mp(Imppf (oristep), Orfix A B)

>>>
>>>
>>>define Ori2 A B0: Fixfun(A Or B,Imppf oristep)

define Ori2 A B0: Fixfun(A Or B,Imppf oristep)


>> Ori2: [(A_1:prop),(.B_1:prop),(B0_1:that
>>      .B_1) => (((A_1 Or .B_1) Fixfun Imppf([(Nn_2:
>>         that Not(A_1)) => (B0_1:that .B_1)]))
>>      :that (A_1 Or .B_1))]
>>   {move 0}


>>>
>>>
>>>>> Ori2: [(A_1:prop),(.B_1:prop),(B0_1:that
>>>>>      .B_1) => (((A_1 Or .B_1) Fixfun Imppf([(Nn_2:
>>>>>         that Not(A_1)) => (B0_1:that .B_1)]))
>>>>>      :that (A_1 Or .B_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * O := EB ; OR(A,B)
 comment  B * O := EB ; OR(A,B)

>>>
>>>clearcurrent B0
clearcurrent B0

>>>
>>>
>>>declare O that Or A B

declare O that Or A B

>> O: that (A Or B) {move 1:B0}


>>>
>>>>> O: that (A Or B) {move 1:B0}
>>>
>>>
>>>
>>>save O

save O
>>> comment  O * N := EB ; NOT(A)
 comment  O * N := EB ; NOT(A)

>>>
>>>
>>>declare nota that Not A

declare nota that Not A

>> nota: that Not(A) {move 1:O}


>>>
>>>>> nota: that Not(A) {move 1:O}
>>>
>>>
>>>
>>>save nota

save nota
>>> comment  N * NOTCASE1 := <N>O ; B
 comment  N * NOTCASE1 := <N>O ; B

>>>
>>>
>>>define Notcase1 O nota : Mp (nota, O)

define Notcase1 O nota : Mp (nota, O)

>> Notcase1: [(.A_1:prop),(.B_1:prop),(O_1:that
>>      (.A_1 Or .B_1)),(nota_1:that Not(.A_1))
>>      => ((nota_1 Mp O_1):that .B_1)]
>>   {move 0}


>>>
>>>>> Notcase1: [(.A_1:prop),(.B_1:prop),(O_1:that
>>>>>      (.A_1 Or .B_1)),(nota_1:that Not(.A_1))
>>>>>      => ((nota_1 Mp O_1):that .B_1)]
>>>>>   {move 0}
>>>
>>>
>>> comment  O * N := EB ; NOT(B)
 comment  O * N := EB ; NOT(B)

>>>
>>>clearcurrent nota
clearcurrent nota

>>>
>>>
>>>declare notb that Not B

declare notb that Not B

>> notb: that Not(B) {move 1:nota}


>>>
>>>>> notb: that Not(B) {move 1:nota}
>>>
>>>
>>>
>>>save notb

save notb
>>> comment  N * NOTCASE2 := DBLNEGLAW(A,CONTRAPOS(NOT A,B,O,N))
 comment  N * NOTCASE2 := DBLNEGLAW(A,CONTRAPOS(NOT A,B,O,N))

>>>
>>>
>>>define Notcase2 O notb : Dblneglaw(Contrapos(O, \
   notb))

define Notcase2 O notb : Dblneglaw(Contrapos(O, \
   notb))

>> Notcase2: [(.A_1:prop),(.B_1:prop),(O_1:that
>>      (.A_1 Or .B_1)),(notb_1:that Not(.B_1))
>>      => (Dblneglaw((O_1 Contrapos notb_1)):
>>      that .A_1)]
>>   {move 0}


>>>
>>>>> Notcase2: [(.A_1:prop),(.B_1:prop),(O_1:that
>>>>>      (.A_1 Or .B_1)),(notb_1:that Not(.B_1))
>>>>>      => (Dblneglaw((O_1 Contrapos notb_1)):
>>>>>      that .A_1)]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * C := EB ; PROP
 comment  B * C := EB ; PROP

>>>
>>>clearcurrent B
clearcurrent B

>>>
>>>
>>>declare C prop

declare C prop

>> C: prop {move 1:B}


>>>
>>>>> C: prop {move 1:B}
>>>
>>>
>>> comment  C * O := EB ; OR(A,B)
 comment  C * O := EB ; OR(A,B)

>>>
>>>
>>>declare O that A Or B

declare O that A Or B

>> O: that (A Or B) {move 1:B}


>>>
>>>>> O: that (A Or B) {move 1:B}
>>>
>>>
>>> comment  O * I := EB ; IMP(A,C)
 comment  O * I := EB ; IMP(A,C)

>>>
>>>
>>>declare I that A Imp C

declare I that A Imp C

>> I: that (A Imp C) {move 1:B}


>>>
>>>>> I: that (A Imp C) {move 1:B}
>>>
>>>
>>> comment  I * J := EB ; IMP(B,C)
 comment  I * J := EB ; IMP(B,C)

>>>
>>>
>>>declare J that B Imp C

declare J that B Imp C

>> J: that (B Imp C) {move 1:B}


>>>
>>>>> J: that (B Imp C) {move 1:B}
>>>
>>>
>>> comment  J * ORE := ANYCASE(A,C,I,[T,Not A]<<T>,O>J>) ; C
 comment  J * ORE := ANYCASE(A,C,I,[T,Not A]<<T>,O>J>) ; C

>>>
>>>
>>>open

open
>>>
>>>   declare T that Not A

   declare T that Not A

>>    T: that Not(A) {move 2}


>>>
>>>>>    T: that Not(A) {move 2}
>>>
>>>
>>>
>>>   define step1 T: Mp (T, O)

   define step1 T: Mp (T, O)

>>    step1: [(T_1:that Not(A)) => (---:that
>>         B)]
>>      {move 1:B}


>>>
>>>>>    step1: [(T_1:that Not(A)) => (---:that
>>>>>         B)]
>>>>>      {move 1:B}
>>>
>>>
>>>
>>>   define step2 T: Mp (step1 T, J)

   define step2 T: Mp (step1 T, J)

>>    step2: [(T_1:that Not(A)) => (---:that
>>         C)]
>>      {move 1:B}


>>>
>>>>>    step2: [(T_1:that Not(A)) => (---:that
>>>>>         C)]
>>>>>      {move 1:B}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Ore O I J : Anycase(I,Imppf (step2))

define Ore O I J : Anycase(I,Imppf (step2))


>> Ore: [(.A_1:prop),(.B_1:prop),(O_1:that (.A_1
>>      Or .B_1)),(.C_1:prop),(I_1:that (.A_1
>>      Imp .C_1)),(J_1:that (.B_1 Imp .C_1))
>>      => ((I_1 Anycase Imppf([(T_2:that Not(.A_1))
>>         => (((T_2 Mp O_1) Mp J_1):that .C_1)]))
>>      :that .C_1)]
>>   {move 0}


>>>
>>>
>>>>> Ore: [(.A_1:prop),(.B_1:prop),(O_1:that (.A_1
>>>>>      Or .B_1)),(.C_1:prop),(I_1:that (.A_1
>>>>>      Imp .C_1)),(J_1:that (.B_1 Imp .C_1))
>>>>>      => ((I_1 Anycase Imppf([(T_2:that Not(.A_1))
>>>>>         => (((T_2 Mp O_1) Mp J_1):that .C_1)]))
>>>>>      :that .C_1)]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * AND := NOT(IMP(A,NOT(B))) ; PROP
 comment  B * AND := NOT(IMP(A,NOT(B))) ; PROP

>>>
>>>clearcurrent B0
clearcurrent B0

>>>
>>>
>>>define And A B: Not(A Imp Not B)

define And A B: Not(A Imp Not B)

>> And: [(A_1:prop),(B_1:prop) => (Not((A_1
>>      Imp Not(B_1))):prop)]
>>   {move 0}


>>>
>>>>> And: [(A_1:prop),(B_1:prop) => (Not((A_1
>>>>>      Imp Not(B_1))):prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare fixand that And A B

   declare fixand that And A B

>>    fixand: that (A And B) {move 2}


>>>
>>>>>    fixand: that (A And B) {move 2}
>>>
>>>
>>>
>>>   define andfix fixand : fixand

   define andfix fixand : fixand

>>    andfix: [(fixand_1:that (A And B)) =>
>>         (---:that (A And B))]
>>      {move 1:B0}


>>>
>>>>>    andfix: [(fixand_1:that (A And B)) =>
>>>>>         (---:that (A And B))]
>>>>>      {move 1:B0}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Andfix A B: Imppffull (Not(A Imp Not \
   B),A And B,andfix)

define Andfix A B: Imppffull (Not(A Imp Not \
   B),A And B,andfix)

>> Andfix: [(A_1:prop),(B_1:prop) => (Imppffull(Not((A_1
>>      Imp Not(B_1))),(A_1 And B_1),[(fixand_2:
>>         that (A_1 And B_1)) => (fixand_2:that
>>         (A_1 And B_1))])
>>      :that (Not((A_1 Imp Not(B_1))) Imp (A_1
>>      And B_1)))]
>>   {move 0}


>>>
>>>>> Andfix: [(A_1:prop),(B_1:prop) => (Imppffull(Not((A_1
>>>>>      Imp Not(B_1))),(A_1 And B_1),[(fixand_2:
>>>>>         that (A_1 And B_1)) => (fixand_2:that
>>>>>         (A_1 And B_1))])
>>>>>      :that (Not((A_1 Imp Not(B_1))) Imp (A_1
>>>>>      And B_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * A0 := EB ; A
 comment  B * A0 := EB ; A

>>>
>>> comment  already declared
 comment  already declared

>>>
>>> comment  A0 * B0 := EB ; B
 comment  A0 * B0 := EB ; B

>>>
>>> comment  use B0 already declared
 comment  use B0 already declared

>>>
>>> comment  B0 * ANDI := TH3(A,NOT(B),A0,TH1(B,B0)) ; AND(A,B)
 comment  B0 * ANDI := TH3(A,NOT(B),A0,TH1(B,B0)) ; AND(A,B)

>>>
>>>
>>>define Andi A0 B0 : Fixfun(A And B,(Th3(A0, \
   Th1 B0)))

define Andi A0 B0 : Fixfun(A And B,(Th3(A0, \
   Th1 B0)))

>> Andi: [(.A_1:prop),(A0_1:that .A_1),(.B_1:
>>      prop),(B0_1:that .B_1) => (((.A_1 And
>>      .B_1) Fixfun (A0_1 Th3 Th1(B0_1))):that
>>      (.A_1 And .B_1))]
>>   {move 0}


>>>
>>>>> Andi: [(.A_1:prop),(A0_1:that .A_1),(.B_1:
>>>>>      prop),(B0_1:that .B_1) => (((.A_1 And
>>>>>      .B_1) Fixfun (A0_1 Th3 Th1(B0_1))):that
>>>>>      (.A_1 And .B_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  B * A1 := EB ; AND(A,B)
 comment  B * A1 := EB ; AND(A,B)

>>>
>>>
>>>declare A1 that A And B

declare A1 that A And B

>> A1: that (A And B) {move 1:B0}


>>>
>>>>> A1: that (A And B) {move 1:B0}
>>>
>>>
>>> comment  A1 * ANDE1 := TH4(A,NOT B,A1) ; A
 comment  A1 * ANDE1 := TH4(A,NOT B,A1) ; A

>>>
>>>
>>>define Ande1 A1 : Th4(A1)

define Ande1 A1 : Th4(A1)

>> Ande1: [(.A_1:prop),(.B_1:prop),(A1_1:that
>>      (.A_1 And .B_1)) => (Th4(A1_1):that .A_1)]
>>   {move 0}


>>>
>>>>> Ande1: [(.A_1:prop),(.B_1:prop),(A1_1:that
>>>>>      (.A_1 And .B_1)) => (Th4(A1_1):that .A_1)]
>>>>>   {move 0}
>>>
>>>
>>> comment  A1 * ANDE2 := DBLNEGLAW(B,TH5(A,NOT(B),A1))
 comment  A1 * ANDE2 := DBLNEGLAW(B,TH5(A,NOT(B),A1))

>>>
>>>
>>>define Ande2 A1 : Dblneglaw(Th5(A1))

define Ande2 A1 : Dblneglaw(Th5(A1))

>> Ande2: [(.A_1:prop),(.B_1:prop),(A1_1:that
>>      (.A_1 And .B_1)) => (Dblneglaw(Th5(A1_1)):
>>      that .B_1)]
>>   {move 0}


>>>
>>>>> Ande2: [(.A_1:prop),(.B_1:prop),(A1_1:that
>>>>>      (.A_1 And .B_1)) => (Dblneglaw(Th5(A1_1)):
>>>>>      that .B_1)]
>>>>>   {move 0}
>>>
>>>
>>> comment  * NAT := PN ;TYPE
 comment  * NAT := PN ;TYPE

>>>
>>>clearcurrent
clearcurrent

>>>
>>>
>>>postulate Nat type

postulate Nat type

>> Nat: type {move 0}


>>>
>>>>> Nat: type {move 0}
>>>
>>>
>>> comment   * P := EB ; [x:NAT]PROP
 comment   * P := EB ; [x:NAT]PROP

>>>
>>> comment  comment  Notice the characteristic Lestrade maneuver
 comment  comment  Notice the characteristic Lestrade maneuver
>>> comment  to declare an abstraction variable
 comment  to declare an abstraction variable

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   postulate P x prop

   postulate P x prop

>>    P: [(x_1:in Nat) => (---:prop)]
>>      {move 1}


>>>
>>>>>    P: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>save P

save P
>>> comment  P * ALL := P ; PROP
 comment  P * ALL := P ; PROP

>>>
>>> comment  comment  Here we have to do some work;
 comment  comment  Here we have to do some work;
>>> comment  comment  we are up against the quite
 comment  comment  we are up against the quite
>>> comment  comment  different treatment of proof
 comment  comment  different treatment of proof
>>> comment  types in Lestrade.
 comment  types in Lestrade.

>>>
>>> comment  comment  It is quite hard to make sense
 comment  comment  It is quite hard to make sense
>>> comment  comment  of without carefully thinking
 comment  comment  of without carefully thinking
>>> comment  comment  about the weird subtyping in
 comment  comment  about the weird subtyping in
>>> comment  metatypes in Automath.
 comment  metatypes in Automath.

>>>
>>>
>>>postulate All P: prop

postulate All P: prop

>> All: [(P_1:[(x_2:in Nat) => (---:prop)])
>>      => (---:prop)]
>>   {move 0}


>>>
>>>>> All: [(P_1:[(x_2:in Nat) => (---:prop)])
>>>>>      => (---:prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>declare xx in Nat

declare xx in Nat

>> xx: in Nat {move 1:P}


>>>
>>>>> xx: in Nat {move 1:P}
>>>
>>>
>>>
>>>declare ev that All P

declare ev that All P

>> ev: that All(P) {move 1:P}


>>>
>>>>> ev: that All(P) {move 1:P}
>>>
>>>
>>>
>>>postulate Alle xx ev :that P xx

postulate Alle xx ev :that P xx

>> Alle: [(xx_1:in Nat),(.P_1:[(x_2:in Nat)
>>         => (---:prop)]),
>>      (ev_1:that All(.P_1)) => (---:that .P_1(xx_1))]
>>   {move 0}


>>>
>>>>> Alle: [(xx_1:in Nat),(.P_1:[(x_2:in Nat)
>>>>>         => (---:prop)]),
>>>>>      (ev_1:that All(.P_1)) => (---:that .P_1(xx_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent P
clearcurrent P

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   postulate univev x: that P x

   postulate univev x: that P x

>>    univev: [(x_1:in Nat) => (---:that P(x_1))]
>>      {move 1:P}


>>>
>>>>>    univev: [(x_1:in Nat) => (---:that P(x_1))]
>>>>>      {move 1:P}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>postulate Alli univev : that All P

postulate Alli univev : that All P

>> Alli: [(.P_1:[(x_2:in Nat) => (---:prop)]),
>>      (univev_1:[(x_3:in Nat) => (---:that .P_1(x_3))])
>>      => (---:that All(.P_1))]
>>   {move 0}


>>>
>>>>> Alli: [(.P_1:[(x_2:in Nat) => (---:prop)]),
>>>>>      (univev_1:[(x_3:in Nat) => (---:that .P_1(x_3))])
>>>>>      => (---:that All(.P_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent P
clearcurrent P

>>>
>>> comment  P * SOME := NOT(ALL([X,NAT]NOT(<X>P))) ; PROP
 comment  P * SOME := NOT(ALL([X,NAT]NOT(<X>P))) ; PROP

>>>
>>>
>>>open

open
>>>
>>>   declare xxx in Nat

   declare xxx in Nat

>>    xxx: in Nat {move 2}


>>>
>>>>>    xxx: in Nat {move 2}
>>>
>>>
>>>
>>>   define Notp xxx : Not (P xxx)

   define Notp xxx : Not (P xxx)

>>    Notp: [(xxx_1:in Nat) => (---:prop)]
>>      {move 1:P}


>>>
>>>>>    Notp: [(xxx_1:in Nat) => (---:prop)]
>>>>>      {move 1:P}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Some P : Not(All Notp)

define Some P : Not(All Notp)

>> Some: [(P_1:[(x_2:in Nat) => (---:prop)])
>>      => (Not(All([(xxx_3:in Nat) => (Not(P_1(xxx_3)):
>>         prop)]))
>>      :prop)]
>>   {move 0}


>>>
>>>>> Some: [(P_1:[(x_2:in Nat) => (---:prop)])
>>>>>      => (Not(All([(xxx_3:in Nat) => (Not(P_1(xxx_3)):
>>>>>         prop)]))
>>>>>      :prop)]
>>>>>   {move 0}
>>>
>>>
>>> comment  P * K := EB ; NAT
 comment  P * K := EB ; NAT

>>>
>>>
>>>save Notp

save Notp
>>>
>>>open

open
>>>
>>>   declare fixsome that Some P

   declare fixsome that Some P

>>    fixsome: that Some(P) {move 2}


>>>
>>>>>    fixsome: that Some(P) {move 2}
>>>
>>>
>>>
>>>   define somefix fixsome: fixsome

   define somefix fixsome: fixsome

>>    somefix: [(fixsome_1:that Some(P)) =>
>>         (---:that Some(P))]
>>      {move 1:Notp}


>>>
>>>>>    somefix: [(fixsome_1:that Some(P)) =>
>>>>>         (---:that Some(P))]
>>>>>      {move 1:Notp}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Somefix P: Imppffull (Not (All Notp), \
   Some P,somefix)

define Somefix P: Imppffull (Not (All Notp), \
   Some P,somefix)

>> Somefix: [(P_1:[(x_2:in Nat) => (---:prop)])
>>      => (Imppffull(Not(All([(xxx_3:in Nat)
>>         => (Not(P_1(xxx_3)):prop)]))
>>      ,Some(P_1),[(fixsome_4:that Some(P_1))
>>         => (fixsome_4:that Some(P_1))])
>>      :that (Not(All([(xxx_5:in Nat) => (Not(P_1(xxx_5)):
>>         prop)]))
>>      Imp Some(P_1)))]
>>   {move 0}


>>>
>>>>> Somefix: [(P_1:[(x_2:in Nat) => (---:prop)])
>>>>>      => (Imppffull(Not(All([(xxx_3:in Nat)
>>>>>         => (Not(P_1(xxx_3)):prop)]))
>>>>>      ,Some(P_1),[(fixsome_4:that Some(P_1))
>>>>>         => (fixsome_4:that Some(P_1))])
>>>>>      :that (Not(All([(xxx_5:in Nat) => (Not(P_1(xxx_5)):
>>>>>         prop)]))
>>>>>      Imp Some(P_1)))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent Notp
clearcurrent Notp

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1:Notp}


>>>
>>>>> K: in Nat {move 1:Notp}
>>>
>>>
>>> comment  K * KP := EB ; <K>P
 comment  K * KP := EB ; <K>P

>>>
>>>
>>>declare Kp that P K

declare Kp that P K

>> Kp: that P(K) {move 1:Notp}


>>>
>>>>> Kp: that P(K) {move 1:Notp}
>>>
>>>
>>> comment  Kp * SOMEI := [T,[X,NAT]NOT(<X>P)]<KP><K>T
 comment  Kp * SOMEI := [T,[X,NAT]NOT(<X>P)]<KP><K>T

>>>
>>>
>>>open

open
>>>
>>>   declare counterev that All Notp

   declare counterev that All Notp

>>    counterev: that All(Notp) {move 2}


>>>
>>>>>    counterev: that All(Notp) {move 2}
>>>
>>>
>>>
>>>   define step1 counterev: Alle K counterev

   define step1 counterev: Alle K counterev


>>    step1: [(counterev_1:that All(Notp)) =>
>>         (---:that Notp(K))]
>>      {move 1:Notp}


>>>
>>>
>>>>>    step1: [(counterev_1:that All(Notp)) =>
>>>>>         (---:that Notp(K))]
>>>>>      {move 1:Notp}
>>>
>>>
>>>
>>>   define step2 counterev: Mp (Kp, step1 \
      counterev)

   define step2 counterev: Mp (Kp, step1 \
      counterev)

>>    step2: [(counterev_1:that All(Notp)) =>
>>         (---:that Con)]
>>      {move 1:Notp}


>>>
>>>>>    step2: [(counterev_1:that All(Notp)) =>
>>>>>         (---:that Con)]
>>>>>      {move 1:Notp}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Somei P, K, Kp: Fixfun(Some P,Negproof \
   (step2))

define Somei P, K, Kp: Fixfun(Some P,Negproof \
   (step2))

>> Somei: [(P_1:[(x_2:in Nat) => (---:prop)]),
>>      (K_1:in Nat),(Kp_1:that P_1(K_1)) => ((Some(P_1)
>>      Fixfun Negproof([(counterev_4:that All([(xxx_5:
>>            in Nat) => (Not(P_1(xxx_5)):prop)]))
>>         => ((Kp_1 Mp (K_1 Alle counterev_4)):
>>         that Con)]))
>>      :that Some(P_1))]
>>   {move 0}


>>>
>>>>> Somei: [(P_1:[(x_2:in Nat) => (---:prop)]),
>>>>>      (K_1:in Nat),(Kp_1:that P_1(K_1)) => ((Some(P_1)
>>>>>      Fixfun Negproof([(counterev_4:that All([(xxx_5:
>>>>>            in Nat) => (Not(P_1(xxx_5)):prop)]))
>>>>>         => ((Kp_1 Mp (K_1 Alle counterev_4)):
>>>>>         that Con)]))
>>>>>      :that Some(P_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent Notp
clearcurrent Notp

>>>
>>> comment  P * A := EB ; PROP
 comment  P * A := EB ; PROP

>>>
>>>
>>>declare A prop

declare A prop

>> A: prop {move 1:Notp}


>>>
>>>>> A: prop {move 1:Notp}
>>>
>>>
>>> comment  A * S := EB ; SOME(P)
 comment  A * S := EB ; SOME(P)

>>>
>>>
>>>declare S that Some P

declare S that Some P

>> S: that Some(P) {move 1:Notp}


>>>
>>>>> S: that Some(P) {move 1:Notp}
>>>
>>>
>>> comment  S * A0 := EB ; [X:NAT][T,<X>P)]A
 comment  S * A0 := EB ; [X:NAT][T,<X>P)]A

>>>
>>>
>>>open

open
>>>
>>>   declare xxx in Nat

   declare xxx in Nat

>>    xxx: in Nat {move 2}


>>>
>>>>>    xxx: in Nat {move 2}
>>>
>>>
>>>
>>>   declare T that P xxx

   declare T that P xxx

>>    T: that P(xxx) {move 2}


>>>
>>>>>    T: that P(xxx) {move 2}
>>>
>>>
>>>
>>>   postulate A00 xxx T that A

   postulate A00 xxx T that A

>>    A00: [(xxx_1:in Nat),(T_1:that P(xxx_1))
>>         => (---:that A)]
>>      {move 1:Notp}


>>>
>>>>>    A00: [(xxx_1:in Nat),(T_1:that P(xxx_1))
>>>>>         => (---:that A)]
>>>>>      {move 1:Notp}
>>>
>>>
>>>
>>>   close

   close
>>> comment  comment  +1
 comment  comment  +1
>>> comment  A0 * N := EB ; NOT(A)
 comment  A0 * N := EB ; NOT(A)

>>>
>>>
>>>open

open
>>>
>>>   declare nota1 that Not A

   declare nota1 that Not A

>>    nota1: that Not(A) {move 2}


>>>
>>>>>    nota1: that Not(A) {move 2}
>>>
>>>
>>>      comment  N * K := EB ; NAT
      comment  N * K := EB ; NAT

>>>
>>>
>>>   open

   open
>>>
>>>      declare kk in Nat

      declare kk in Nat

>>       kk: in Nat {move 3}


>>>
>>>>>       kk: in Nat {move 3}
>>>
>>>
>>>           comment  K * T1 := CONTRAPOS(<K>P,A,<K>A0,N) ; NOT(<K>P)
           comment  K * T1 := CONTRAPOS(<K>P,A,<K>A0,N) ; NOT(<K>P)

>>>
>>>
>>>      open

      open
>>>
>>>         declare zorch that P kk

         declare zorch that P kk

>>          zorch: that P(kk) {move 4}


>>>
>>>>>          zorch: that P(kk) {move 4}
>>>
>>>
>>>
>>>         define counterzorch zorch : A00 \
            kk zorch

         define counterzorch zorch : A00 \
            kk zorch

>>          counterzorch: [(zorch_1:that P(kk))
>>               => (---:that A)]
>>            {move 3}


>>>
>>>>>          counterzorch: [(zorch_1:that P(kk))
>>>>>               => (---:that A)]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         close

         close
>>>
>>>      define A01 kk : Imppf (counterzorch)

      define A01 kk : Imppf (counterzorch)


>>       A01: [(kk_1:in Nat) => (---:that (P(kk_1)
>>            Imp A))]
>>         {move 2}


>>>
>>>
>>>>>       A01: [(kk_1:in Nat) => (---:that (P(kk_1)
>>>>>            Imp A))]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      define step1 kk : Contrapos(A01 kk, \
         nota1)

      define step1 kk : Contrapos(A01 kk, \
         nota1)

>>       step1: [(kk_1:in Nat) => (---:that
>>            Not(P(kk_1)))]
>>         {move 2}


>>>
>>>>>       step1: [(kk_1:in Nat) => (---:that
>>>>>            Not(P(kk_1)))]
>>>>>         {move 2}
>>>
>>>
>>>           comment  N * T2 := <[X:NAT]T1(X)>S ; CON
           comment  N * T2 := <[X:NAT]T1(X)>S ; CON

>>>
>>>
>>>      close

      close
>>>
>>>   define step2 nota1 : Alli step1

   define step2 nota1 : Alli step1

>>    step2: [(nota1_1:that Not(A)) => (---:
>>         that All([(kk_5:in Nat) => (Not(P(kk_5)):
>>            prop)]))
>>         ]
>>      {move 1:Notp}


>>>
>>>>>    step2: [(nota1_1:that Not(A)) => (---:
>>>>>         that All([(kk_5:in Nat) => (Not(P(kk_5)):
>>>>>            prop)]))
>>>>>         ]
>>>>>      {move 1:Notp}
>>>
>>>
>>>
>>>   define step3 nota1 : Mp (step2 nota1 , \
      S)

   define step3 nota1 : Mp (step2 nota1 , \
      S)

>>    step3: [(nota1_1:that Not(A)) => (---:
>>         that Con)]
>>      {move 1:Notp}


>>>
>>>>>    step3: [(nota1_1:that Not(A)) => (---:
>>>>>         that Con)]
>>>>>      {move 1:Notp}
>>>
>>>
>>>
>>>   close

   close
>>> comment  A0 SOMEE := DBLNEGLAW(A,[T,NOT(A)]T2"-1"(T)) ; A
 comment  A0 SOMEE := DBLNEGLAW(A,[T,NOT(A)]T2"-1"(T)) ; A

>>>
>>> comment  comment  Note that in the proof of Somee, though
 comment  comment  Note that in the proof of Somee, though
>>> comment  comment  in general terms it is clear that the logical
 comment  comment  in general terms it is clear that the logical
>>> comment  comment  structure is similar, the details of the 
 comment  comment  structure is similar, the details of the 
>>> comment  comment  type system are different enough that it
 comment  comment  type system are different enough that it
>>> comment  is hard to compare the terms.
 comment  is hard to compare the terms.

>>>
>>>
>>>define Somee S, A00 : Dblneglaw (Negproof \
   (step3))

define Somee S, A00 : Dblneglaw (Negproof \
   (step3))

>> Somee: [(.P_1:[(x_2:in Nat) => (---:prop)]),
>>      (S_1:that Some(.P_1)),(.A_1:prop),(A00_1:
>>      [(xxx_3:in Nat),(T_3:that .P_1(xxx_3))
>>         => (---:that .A_1)])
>>      => (Dblneglaw(Negproof([(nota1_4:that
>>         Not(.A_1)) => ((Alli([(kk_7:in Nat)
>>            => ((Imppf([(zorch_8:that .P_1(kk_7))
>>               => ((kk_7 A00_1 zorch_8):that
>>               .A_1)])
>>            Contrapos nota1_4):that Not(.P_1(kk_7)))])
>>         Mp S_1):that Con)]))
>>      :that .A_1)]
>>   {move 0}


>>>
>>>>> Somee: [(.P_1:[(x_2:in Nat) => (---:prop)]),
>>>>>      (S_1:that Some(.P_1)),(.A_1:prop),(A00_1:
>>>>>      [(xxx_3:in Nat),(T_3:that .P_1(xxx_3))
>>>>>         => (---:that .A_1)])
>>>>>      => (Dblneglaw(Negproof([(nota1_4:that
>>>>>         Not(.A_1)) => ((Alli([(kk_7:in Nat)
>>>>>            => ((Imppf([(zorch_8:that .P_1(kk_7))
>>>>>               => ((kk_7 A00_1 zorch_8):that
>>>>>               .A_1)])
>>>>>            Contrapos nota1_4):that Not(.P_1(kk_7)))])
>>>>>         Mp S_1):that Con)]))
>>>>>      :that .A_1)]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent
clearcurrent

>>>
>>> comment  * K := EB ; NAT
 comment  * K := EB ; NAT

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1}


>>>
>>>>> K: in Nat {move 1}
>>>
>>>
>>> comment  K * L := EB ; NAT
 comment  K * L := EB ; NAT

>>>
>>>
>>>declare L in Nat

declare L in Nat

>> L: in Nat {move 1}


>>>
>>>>> L: in Nat {move 1}
>>>
>>>
>>> comment  L * IS := PN ; PROP
 comment  L * IS := PN ; PROP

>>>
>>>
>>>save L

save L
>>>
>>>postulate Is K L : prop

postulate Is K L : prop

>> Is: [(K_1:in Nat),(L_1:in Nat) => (---:prop)]
>>   {move 0}


>>>
>>>>> Is: [(K_1:in Nat),(L_1:in Nat) => (---:prop)]
>>>>>   {move 0}
>>>
>>>
>>> comment  K * REFLEQ := PN ; IS(K,K)
 comment  K * REFLEQ := PN ; IS(K,K)

>>>
>>>
>>>postulate Refleq K that Is(K,K)

postulate Refleq K that Is(K,K)

>> Refleq: [(K_1:in Nat) => (---:that (K_1 Is
>>      K_1))]
>>   {move 0}


>>>
>>>>> Refleq: [(K_1:in Nat) => (---:that (K_1 Is
>>>>>      K_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  L * I := EB ; IS{K,L)
 comment  L * I := EB ; IS{K,L)

>>>
>>>
>>>declare I that Is K L

declare I that Is K L

>> I: that (K Is L) {move 1:L}


>>>
>>>>> I: that (K Is L) {move 1:L}
>>>
>>>
>>> comment  I * P := EB ; [X,NAT]PROP
 comment  I * P := EB ; [X,NAT]PROP

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   postulate P x : prop

   postulate P x : prop

>>    P: [(x_1:in Nat) => (---:prop)]
>>      {move 1:L}


>>>
>>>>>    P: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>save P

save P
>>> comment  P * KP := EB ; <K>P
 comment  P * KP := EB ; <K>P

>>>
>>>
>>>declare Kp that P K

declare Kp that P K

>> Kp: that P(K) {move 1:P}


>>>
>>>>> Kp: that P(K) {move 1:P}
>>>
>>>
>>> comment  KP * EQPRED1 := PN ; <L>P
 comment  KP * EQPRED1 := PN ; <L>P

>>>
>>> comment  comment  That we actually need the predicate argument
 comment  comment  That we actually need the predicate argument
>>> comment  comment  (though it could be inferred) comes from the
 comment  comment  (though it could be inferred) comes from the
>>> comment  comment  fact that we do not want to make all substitutions
 comment  comment  fact that we do not want to make all substitutions
>>> comment  of L for K when we use K=L.
 comment  of L for K when we use K=L.

>>>
>>> comment  an implicit argument version might have uses.
 comment  an implicit argument version might have uses.

>>>
>>>
>>>postulate Eqpred1 I P, Kp : that P L

postulate Eqpred1 I P, Kp : that P L

>> Eqpred1: [(.K_1:in Nat),(.L_1:in Nat),(I_1:
>>      that (.K_1 Is .L_1)),(P_1:[(x_2:in Nat)
>>         => (---:prop)]),
>>      (Kp_1:that P_1(.K_1)) => (---:that P_1(.L_1))]
>>   {move 0}


>>>
>>>>> Eqpred1: [(.K_1:in Nat),(.L_1:in Nat),(I_1:
>>>>>      that (.K_1 Is .L_1)),(P_1:[(x_2:in Nat)
>>>>>         => (---:prop)]),
>>>>>      (Kp_1:that P_1(.K_1)) => (---:that P_1(.L_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * SYMEQ := EQPRED1([X:NAT]IS(X,K),REFLEQ(K)) ; IS(L,K)
 comment  I * SYMEQ := EQPRED1([X:NAT]IS(X,K),REFLEQ(K)) ; IS(L,K)

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   define thepred x : Is(x,K)

   define thepred x : Is(x,K)

>>    thepred: [(x_1:in Nat) => (---:prop)]
>>      {move 1:P}


>>>
>>>>>    thepred: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1:P}
>>>
>>>
>>>
>>>   close

   close
>>> comment  right here we use a non-inferrable predicate with Eqpred1.
 comment  right here we use a non-inferrable predicate with Eqpred1.

>>>
>>>
>>>define Symeq I : Eqpred1 I thepred, Refleq \
   K

define Symeq I : Eqpred1 I thepred, Refleq \
   K

>> Symeq: [(.K_1:in Nat),(.L_1:in Nat),(I_1:
>>      that (.K_1 Is .L_1)) => (Eqpred1(I_1,[(x_2:
>>         in Nat) => ((x_2 Is .K_1):prop)]
>>      ,Refleq(.K_1)):that (.L_1 Is .K_1))]
>>   {move 0}


>>>
>>>>> Symeq: [(.K_1:in Nat),(.L_1:in Nat),(I_1:
>>>>>      that (.K_1 Is .L_1)) => (Eqpred1(I_1,[(x_2:
>>>>>         in Nat) => ((x_2 Is .K_1):prop)]
>>>>>      ,Refleq(.K_1)):that (.L_1 Is .K_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent P
clearcurrent P

>>>
>>> comment  P * LP := EB ; <L>P
 comment  P * LP := EB ; <L>P

>>>
>>>
>>>declare Lp that P L

declare Lp that P L

>> Lp: that P(L) {move 1:P}


>>>
>>>>> Lp: that P(L) {move 1:P}
>>>
>>>
>>> comment  LP * EQPRED2 := EQPRED1(L,K,SYMEQ(K,L,I),P,LP) ; <K>P
 comment  LP * EQPRED2 := EQPRED1(L,K,SYMEQ(K,L,I),P,LP) ; <K>P

>>>
>>>
>>>define Eqpred2 I P, Lp: Eqpred1(Symeq(I), \
   P,Lp)

define Eqpred2 I P, Lp: Eqpred1(Symeq(I), \
   P,Lp)

>> Eqpred2: [(.K_1:in Nat),(.L_1:in Nat),(I_1:
>>      that (.K_1 Is .L_1)),(P_1:[(x_2:in Nat)
>>         => (---:prop)]),
>>      (Lp_1:that P_1(.L_1)) => (Eqpred1(Symeq(I_1),
>>      P_1,Lp_1):that P_1(.K_1))]
>>   {move 0}


>>>
>>>>> Eqpred2: [(.K_1:in Nat),(.L_1:in Nat),(I_1:
>>>>>      that (.K_1 Is .L_1)),(P_1:[(x_2:in Nat)
>>>>>         => (---:prop)]),
>>>>>      (Lp_1:that P_1(.L_1)) => (Eqpred1(Symeq(I_1),
>>>>>      P_1,Lp_1):that P_1(.K_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  L * M := EB ; Nat
 comment  L * M := EB ; Nat

>>>
>>>clearcurrent L
clearcurrent L

>>>
>>>
>>>declare M in Nat

declare M in Nat

>> M: in Nat {move 1:L}


>>>
>>>>> M: in Nat {move 1:L}
>>>
>>>
>>> comment  M * I := EB ; IS(K,L)
 comment  M * I := EB ; IS(K,L)

>>>
>>>
>>>save M

save M
>>>
>>>declare I that K Is L

declare I that K Is L

>> I: that (K Is L) {move 1:M}


>>>
>>>>> I: that (K Is L) {move 1:M}
>>>
>>>
>>> comment  I * J := EB ; IS(L,M)
 comment  I * J := EB ; IS(L,M)

>>>
>>>
>>>declare J that L Is M

declare J that L Is M

>> J: that (L Is M) {move 1:M}


>>>
>>>>> J: that (L Is M) {move 1:M}
>>>
>>>
>>> comment  J * TREQ := EQPRED1(L,M,J,[X:NAT]IS(K,X),I)
 comment  J * TREQ := EQPRED1(L,M,J,[X:NAT]IS(K,X),I)

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   define thepred x: Is(K,x)

   define thepred x: Is(K,x)

>>    thepred: [(x_1:in Nat) => (---:prop)]
>>      {move 1:M}


>>>
>>>>>    thepred: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1:M}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Treq I J : Eqpred1(J,thepred,I)

define Treq I J : Eqpred1(J,thepred,I)

>> Treq: [(.K_1:in Nat),(.L_1:in Nat),(I_1:that
>>      (.K_1 Is .L_1)),(.M_1:in Nat),(J_1:that
>>      (.L_1 Is .M_1)) => (Eqpred1(J_1,[(x_2:
>>         in Nat) => ((.K_1 Is x_2):prop)]
>>      ,I_1):that (.K_1 Is .M_1))]
>>   {move 0}


>>>
>>>>> Treq: [(.K_1:in Nat),(.L_1:in Nat),(I_1:that
>>>>>      (.K_1 Is .L_1)),(.M_1:in Nat),(J_1:that
>>>>>      (.L_1 Is .M_1)) => (Eqpred1(J_1,[(x_2:
>>>>>         in Nat) => ((.K_1 Is x_2):prop)]
>>>>>      ,I_1):that (.K_1 Is .M_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent M
clearcurrent M

>>>
>>> comment  M * I := EB ; IS(K,M)
 comment  M * I := EB ; IS(K,M)

>>>
>>>
>>>declare I that K Is M

declare I that K Is M

>> I: that (K Is M) {move 1:M}


>>>
>>>>> I: that (K Is M) {move 1:M}
>>>
>>>
>>> comment  I * J := EB ; IS(L,M)
 comment  I * J := EB ; IS(L,M)

>>>
>>>
>>>declare J that L Is M

declare J that L Is M

>> J: that (L Is M) {move 1:M}


>>>
>>>>> J: that (L Is M) {move 1:M}
>>>
>>>
>>> comment  J * CONVEQ := TREQ(K,M,L,I,SYMEQ(L,M,J)) ; IS(K,L)
 comment  J * CONVEQ := TREQ(K,M,L,I,SYMEQ(L,M,J)) ; IS(K,L)

>>>
>>>
>>>define Conveq I J : Treq(I,Symeq(J))

define Conveq I J : Treq(I,Symeq(J))

>> Conveq: [(.K_1:in Nat),(.M_1:in Nat),(I_1:
>>      that (.K_1 Is .M_1)),(.L_1:in Nat),(J_1:
>>      that (.L_1 Is .M_1)) => ((I_1 Treq Symeq(J_1)):
>>      that (.K_1 Is .L_1))]
>>   {move 0}


>>>
>>>>> Conveq: [(.K_1:in Nat),(.M_1:in Nat),(I_1:
>>>>>      that (.K_1 Is .M_1)),(.L_1:in Nat),(J_1:
>>>>>      that (.L_1 Is .M_1)) => ((I_1 Treq Symeq(J_1)):
>>>>>      that (.K_1 Is .L_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent M
clearcurrent M

>>>
>>> comment  M * I := EB ; IS(M,K)
 comment  M * I := EB ; IS(M,K)

>>>
>>>
>>>declare I that M Is K

declare I that M Is K

>> I: that (M Is K) {move 1:M}


>>>
>>>>> I: that (M Is K) {move 1:M}
>>>
>>>
>>> comment  I * J := EB ; IS(M,L)
 comment  I * J := EB ; IS(M,L)

>>>
>>>
>>>declare J that M Is L

declare J that M Is L

>> J: that (M Is L) {move 1:M}


>>>
>>>>> J: that (M Is L) {move 1:M}
>>>
>>>
>>> comment  J * DIVEQ := TREQ(K,M,L,SYMEQ(M,K,I),J) ; IS(K,L)
 comment  J * DIVEQ := TREQ(K,M,L,SYMEQ(M,K,I),J) ; IS(K,L)

>>>
>>>
>>>define Diveq I J : Treq(Symeq(I),J)

define Diveq I J : Treq(Symeq(I),J)

>> Diveq: [(.M_1:in Nat),(.K_1:in Nat),(I_1:
>>      that (.M_1 Is .K_1)),(.L_1:in Nat),(J_1:
>>      that (.M_1 Is .L_1)) => ((Symeq(I_1) Treq
>>      J_1):that (.K_1 Is .L_1))]
>>   {move 0}


>>>
>>>>> Diveq: [(.M_1:in Nat),(.K_1:in Nat),(I_1:
>>>>>      that (.M_1 Is .K_1)),(.L_1:in Nat),(J_1:
>>>>>      that (.M_1 Is .L_1)) => ((Symeq(I_1) Treq
>>>>>      J_1):that (.K_1 Is .L_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent M
clearcurrent M

>>>
>>> comment  M * N := EB ; NAT
 comment  M * N := EB ; NAT

>>>
>>>
>>>declare N in Nat

declare N in Nat

>> N: in Nat {move 1:M}


>>>
>>>>> N: in Nat {move 1:M}
>>>
>>>
>>> comment  N * I := EB ; IS(K,L)
 comment  N * I := EB ; IS(K,L)

>>>
>>>
>>>declare I that K Is L

declare I that K Is L

>> I: that (K Is L) {move 1:M}


>>>
>>>>> I: that (K Is L) {move 1:M}
>>>
>>>
>>> comment  I * J := EB ; IS(L,M)
 comment  I * J := EB ; IS(L,M)

>>>
>>>
>>>declare J that L Is M

declare J that L Is M

>> J: that (L Is M) {move 1:M}


>>>
>>>>> J: that (L Is M) {move 1:M}
>>>
>>>
>>> comment  J * I0 := EB ; IS(M,N)
 comment  J * I0 := EB ; IS(M,N)

>>>
>>>
>>>declare I0 that M Is N

declare I0 that M Is N

>> I0: that (M Is N) {move 1:M}


>>>
>>>>> I0: that (M Is N) {move 1:M}
>>>
>>>
>>> comment  I0 * TR3EQ := TREQ(K,M,N,TREQ(K,L,M,I,J),I0)
 comment  I0 * TR3EQ := TREQ(K,M,N,TREQ(K,L,M,I,J),I0)

>>>
>>>
>>>define Treq3 I J I0 : Treq(Treq(I,J),I0)

define Treq3 I J I0 : Treq(Treq(I,J),I0)


>> Treq3: [(.K_1:in Nat),(.L_1:in Nat),(I_1:
>>      that (.K_1 Is .L_1)),(.M_1:in Nat),(J_1:
>>      that (.L_1 Is .M_1)),(.N_1:in Nat),(I0_1:
>>      that (.M_1 Is .N_1)) => (((I_1 Treq J_1)
>>      Treq I0_1):that (.K_1 Is .N_1))]
>>   {move 0}


>>>
>>>
>>>>> Treq3: [(.K_1:in Nat),(.L_1:in Nat),(I_1:
>>>>>      that (.K_1 Is .L_1)),(.M_1:in Nat),(J_1:
>>>>>      that (.L_1 Is .M_1)),(.N_1:in Nat),(I0_1:
>>>>>      that (.M_1 Is .N_1)) => (((I_1 Treq J_1)
>>>>>      Treq I0_1):that (.K_1 Is .N_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent
clearcurrent

>>>
>>> comment  * P := EB ; [X:NAT]PROP
 comment  * P := EB ; [X:NAT]PROP

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   postulate P x prop

   postulate P x prop

>>    P: [(x_1:in Nat) => (---:prop)]
>>      {move 1}


>>>
>>>>>    P: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>save P

save P
>>> comment  P * NOTTWO := [X,NAT][Y,NAT][T,<X>P][U,<Y>P]IS(X,Y) ; PROP
 comment  P * NOTTWO := [X,NAT][Y,NAT][T,<X>P][U,<Y>P]IS(X,Y) ; PROP

>>>
>>> comment  comment  I am forced to take a different tack
 comment  comment  I am forced to take a different tack
>>> comment  due to not having weird Automath subtyping
 comment  due to not having weird Automath subtyping

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare y in Nat

      declare y in Nat

>>       y: in Nat {move 3}


>>>
>>>>>       y: in Nat {move 3}
>>>
>>>
>>>
>>>      define bothptheneq y : ((P x) And (P \
         y)) Imp (x Is y)

      define bothptheneq y : ((P x) And (P \
         y)) Imp (x Is y)

>>       bothptheneq: [(y_1:in Nat) => (---:
>>            prop)]
>>         {move 2}


>>>
>>>>>       bothptheneq: [(y_1:in Nat) => (---:
>>>>>            prop)]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define bothptheneq2 x : All bothptheneq

   define bothptheneq2 x : All bothptheneq


>>    bothptheneq2: [(x_1:in Nat) => (---:prop)]
>>      {move 1:P}


>>>
>>>
>>>>>    bothptheneq2: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1:P}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Nottwo P : All bothptheneq2

define Nottwo P : All bothptheneq2

>> Nottwo: [(P_1:[(x_2:in Nat) => (---:prop)])
>>      => (All([(x_3:in Nat) => (All([(y_4:in
>>            Nat) => (((P_1(x_3) And P_1(y_4))
>>            Imp (x_3 Is y_4)):prop)])
>>         :prop)])
>>      :prop)]
>>   {move 0}


>>>
>>>>> Nottwo: [(P_1:[(x_2:in Nat) => (---:prop)])
>>>>>      => (All([(x_3:in Nat) => (All([(y_4:in
>>>>>            Nat) => (((P_1(x_3) And P_1(y_4))
>>>>>            Imp (x_3 Is y_4)):prop)])
>>>>>         :prop)])
>>>>>      :prop)]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent P
clearcurrent P

>>>
>>> comment  P * ONE := AND(SOME(P),NOTTWO(P)) ; PROP
 comment  P * ONE := AND(SOME(P),NOTTWO(P)) ; PROP

>>>
>>>
>>>define One P : (Some P) And (Nottwo P)

define One P : (Some P) And (Nottwo P)

>> One: [(P_1:[(x_2:in Nat) => (---:prop)])
>>      => ((Some(P_1) And Nottwo(P_1)):prop)]
>>   {move 0}


>>>
>>>>> One: [(P_1:[(x_2:in Nat) => (---:prop)])
>>>>>      => ((Some(P_1) And Nottwo(P_1)):prop)]
>>>>>   {move 0}
>>>
>>>
>>> comment  P * O := EB ; ONE
 comment  P * O := EB ; ONE

>>>
>>>
>>>declare O that One P

declare O that One P

>> O: that One(P) {move 1:P}


>>>
>>>>> O: that One(P) {move 1:P}
>>>
>>>
>>> comment  O * INDIVIDUAL := PN ; NAT
 comment  O * INDIVIDUAL := PN ; NAT

>>>
>>>
>>>postulate Individual O : in Nat

postulate Individual O : in Nat

>> Individual: [(.P_1:[(x_2:in Nat) => (---:
>>         prop)]),
>>      (O_1:that One(.P_1)) => (---:in Nat)]
>>   {move 0}


>>>
>>>>> Individual: [(.P_1:[(x_2:in Nat) => (---:
>>>>>         prop)]),
>>>>>      (O_1:that One(.P_1)) => (---:in Nat)]
>>>>>   {move 0}
>>>
>>>
>>> comment  O * AXINDIVIDUAL := PN ; <INDIVIDUAL>P
 comment  O * AXINDIVIDUAL := PN ; <INDIVIDUAL>P

>>>
>>>
>>>postulate Axindividual O: that P(Individual \
   O)

postulate Axindividual O: that P(Individual \
   O)

>> Axindividual: [(.P_1:[(x_2:in Nat) => (---:
>>         prop)]),
>>      (O_1:that One(.P_1)) => (---:that .P_1(Individual(O_1)))]
>>   {move 0}


>>>
>>>>> Axindividual: [(.P_1:[(x_2:in Nat) => (---:
>>>>>         prop)]),
>>>>>      (O_1:that One(.P_1)) => (---:that .P_1(Individual(O_1)))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent B
clearcurrent B

>>>
>>> comment  * A K := EB ; NAT
 comment  * A K := EB ; NAT

>>>
>>> comment  already declared
 comment  already declared

>>>
>>> comment  A * K := EB ; NAT
 comment  A * K := EB ; NAT

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1:B}


>>>
>>>>> K: in Nat {move 1:B}
>>>
>>>
>>> comment  K * L := EB ; NAT
 comment  K * L := EB ; NAT

>>>
>>>
>>>declare L in Nat

declare L in Nat

>> L: in Nat {move 1:B}


>>>
>>>>> L: in Nat {move 1:B}
>>>
>>>
>>>
>>>save L

save L
>>> comment  comment  +3
 comment  comment  +3
>>> comment  L * N := EB ; NAT
 comment  L * N := EB ; NAT

>>>
>>>
>>>declare N in Nat

declare N in Nat

>> N: in Nat {move 1:L}


>>>
>>>>> N: in Nat {move 1:L}
>>>
>>>
>>> comment  N * PROP1 := IMP(A,IS(N,K)) ; PROP
 comment  N * PROP1 := IMP(A,IS(N,K)) ; PROP

>>>
>>>
>>>define Prop1 A K L N : A Imp (N Is K)

define Prop1 A K L N : A Imp (N Is K)

>> Prop1: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>      (N_1:in Nat) => ((A_1 Imp (N_1 Is K_1)):
>>      prop)]
>>   {move 0}


>>>
>>>>> Prop1: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>>>>      (N_1:in Nat) => ((A_1 Imp (N_1 Is K_1)):
>>>>>      prop)]
>>>>>   {move 0}
>>>
>>>
>>> comment  N * PROP2 := IMP(NOT(A),IS(N,L)) ; PROP
 comment  N * PROP2 := IMP(NOT(A),IS(N,L)) ; PROP

>>>
>>>
>>>define Prop2 A K L N : (Not A) Imp (N Is \
   L)

define Prop2 A K L N : (Not A) Imp (N Is \
   L)

>> Prop2: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>      (N_1:in Nat) => ((Not(A_1) Imp (N_1 Is
>>      L_1)):prop)]
>>   {move 0}


>>>
>>>>> Prop2: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>>>>      (N_1:in Nat) => ((Not(A_1) Imp (N_1 Is
>>>>>      L_1)):prop)]
>>>>>   {move 0}
>>>
>>>
>>> comment  N * PROP3  := AND(PROP1,PROP2) ; PROP
 comment  N * PROP3  := AND(PROP1,PROP2) ; PROP

>>>
>>>
>>>define Prop3 A K L N : (Prop1 A K L N) And \
   Prop2 A K L N

define Prop3 A K L N : (Prop1 A K L N) And \
   Prop2 A K L N

>> Prop3: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>      (N_1:in Nat) => ((Prop1(A_1,K_1,L_1,N_1)
>>      And Prop2(A_1,K_1,L_1,N_1)):prop)]
>>   {move 0}


>>>
>>>>> Prop3: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>>>>      (N_1:in Nat) => ((Prop1(A_1,K_1,L_1,N_1)
>>>>>      And Prop2(A_1,K_1,L_1,N_1)):prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare xxx that Prop3 A K L N

   declare xxx that Prop3 A K L N

>>    xxx: that Prop3(A,K,L,N) {move 2}


>>>
>>>>>    xxx: that Prop3(A,K,L,N) {move 2}
>>>
>>>
>>>
>>>   define xxxid xxx:xxx

   define xxxid xxx:xxx

>>    xxxid: [(xxx_1:that Prop3(A,K,L,N)) =>
>>         (---:that Prop3(A,K,L,N))]
>>      {move 1:L}


>>>
>>>>>    xxxid: [(xxx_1:that Prop3(A,K,L,N)) =>
>>>>>         (---:that Prop3(A,K,L,N))]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Propfix3 A K L N : Imppffull ((Prop1 \
   A K L N) And Prop2 A K L N,Prop3 A K L N, \
   xxxid)

define Propfix3 A K L N : Imppffull ((Prop1 \
   A K L N) And Prop2 A K L N,Prop3 A K L N, \
   xxxid)

>> Propfix3: [(A_1:prop),(K_1:in Nat),(L_1:in
>>      Nat),(N_1:in Nat) => (Imppffull((Prop1(A_1,
>>      K_1,L_1,N_1) And Prop2(A_1,K_1,L_1,N_1)),
>>      Prop3(A_1,K_1,L_1,N_1),[(xxx_2:that Prop3(A_1,
>>         K_1,L_1,N_1)) => (xxx_2:that Prop3(A_1,
>>         K_1,L_1,N_1))])
>>      :that ((Prop1(A_1,K_1,L_1,N_1) And Prop2(A_1,
>>      K_1,L_1,N_1)) Imp Prop3(A_1,K_1,L_1,N_1)))]
>>   {move 0}


>>>
>>>>> Propfix3: [(A_1:prop),(K_1:in Nat),(L_1:in
>>>>>      Nat),(N_1:in Nat) => (Imppffull((Prop1(A_1,
>>>>>      K_1,L_1,N_1) And Prop2(A_1,K_1,L_1,N_1)),
>>>>>      Prop3(A_1,K_1,L_1,N_1),[(xxx_2:that Prop3(A_1,
>>>>>         K_1,L_1,N_1)) => (xxx_2:that Prop3(A_1,
>>>>>         K_1,L_1,N_1))])
>>>>>      :that ((Prop1(A_1,K_1,L_1,N_1) And Prop2(A_1,
>>>>>      K_1,L_1,N_1)) Imp Prop3(A_1,K_1,L_1,N_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  L * A0 := EB ; A
 comment  L * A0 := EB ; A

>>>
>>>
>>>open

open
>>>
>>>   declare A0 that A

   declare A0 that A

>>    A0: that A {move 2}


>>>
>>>>>    A0: that A {move 2}
>>>
>>>
>>>      comment  A0 * T1 := ANDI(PROP1(K),PROP2(K),[T,A]REFLEQ(K),TH2(NOT(A),IS(K,L),TH1(A,A0))) ; PROP3(K)
      comment  A0 * T1 := ANDI(PROP1(K),PROP2(K),[T,A]REFLEQ(K),TH2(NOT(A),IS(K,L),TH1(A,A0))) ; PROP3(K)

>>>
>>>
>>>   declare yyy in Nat

   declare yyy in Nat

>>    yyy: in Nat {move 2}


>>>
>>>>>    yyy: in Nat {move 2}
>>>
>>>
>>>
>>>   define Propa1 yyy: Prop1 A K L yyy

   define Propa1 yyy: Prop1 A K L yyy

>>    Propa1: [(yyy_1:in Nat) => (---:prop)]
>>      {move 1:L}


>>>
>>>>>    Propa1: [(yyy_1:in Nat) => (---:prop)]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   define Propa2 yyy: Prop2 A K L yyy

   define Propa2 yyy: Prop2 A K L yyy

>>    Propa2: [(yyy_1:in Nat) => (---:prop)]
>>      {move 1:L}


>>>
>>>>>    Propa2: [(yyy_1:in Nat) => (---:prop)]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   define Propa3 yyy: Prop3 A K L yyy

   define Propa3 yyy: Prop3 A K L yyy

>>    Propa3: [(yyy_1:in Nat) => (---:prop)]
>>      {move 1:L}


>>>
>>>>>    Propa3: [(yyy_1:in Nat) => (---:prop)]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   save yyy

   save yyy
>>>
>>>   open

   open
>>>
>>>      declare T that A

      declare T that A

>>       T: that A {move 3}


>>>
>>>>>       T: that A {move 3}
>>>
>>>
>>>
>>>      define step1 T: Refleq K

      define step1 T: Refleq K

>>       step1: [(T_1:that A) => (---:that (K
>>            Is K))]
>>         {move 2:yyy}


>>>
>>>>>       step1: [(T_1:that A) => (---:that (K
>>>>>            Is K))]
>>>>>         {move 2:yyy}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define step2 : Imppf step1

   define step2 : Imppf step1

>>    step2: [(---:that (A Imp (K Is K)))]
>>      {move 1:L}


>>>
>>>>>    step2: [(---:that (A Imp (K Is K)))]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   define T1 A0 : Mp ((Andi (step2 , Th2(K \
      Is L,Th1 A0))),Propfix3 A K L K)

   define T1 A0 : Mp ((Andi (step2 , Th2(K \
      Is L,Th1 A0))),Propfix3 A K L K)

>>    T1: [(A0_1:that A) => (---:that Prop3(A,
>>         K,L,K))]
>>      {move 1:L}


>>>
>>>>>    T1: [(A0_1:that A) => (---:that Prop3(A,
>>>>>         K,L,K))]
>>>>>      {move 1:L}
>>>
>>>
>>>      comment  A0 * T2 := SOMEI([X,NAT]PROP3(X),K,T1) ; SOME([X,NAT]PROP3(X))
      comment  A0 * T2 := SOMEI([X,NAT]PROP3(X),K,T1) ; SOME([X,NAT]PROP3(X))

>>>
>>>
>>>   define T2 A0: Somei(Propa3,K,T1 A0)

   define T2 A0: Somei(Propa3,K,T1 A0)

>>    T2: [(A0_1:that A) => (---:that Some(Propa3))]
>>      {move 1:L}


>>>
>>>>>    T2: [(A0_1:that A) => (---:that Some(Propa3))]
>>>>>      {move 1:L}
>>>
>>>
>>>      comment  L * A1 := EB ; NOT(A)
      comment  L * A1 := EB ; NOT(A)

>>>
>>>
>>>   declare A1 that Not A

   declare A1 that Not A

>>    A1: that Not(A) {move 2:yyy}


>>>
>>>>>    A1: that Not(A) {move 2:yyy}
>>>
>>>
>>>      comment  A1 * T3 := ANDI(PROP1(L),PROP2(L),TH2(A,IS(L,K),A1),[T,NOT(A)]REFLEQ(L)) ; PROP3(L)
      comment  A1 * T3 := ANDI(PROP1(L),PROP2(L),TH2(A,IS(L,K),A1),[T,NOT(A)]REFLEQ(L)) ; PROP3(L)

>>>
>>>
>>>   open

   open
>>>
>>>      declare T that Not A

      declare T that Not A

>>       T: that Not(A) {move 3}


>>>
>>>>>       T: that Not(A) {move 3}
>>>
>>>
>>>
>>>      define lprop T : Refleq L

      define lprop T : Refleq L

>>       lprop: [(T_1:that Not(A)) => (---:that
>>            (L Is L))]
>>         {move 2:yyy}


>>>
>>>>>       lprop: [(T_1:that Not(A)) => (---:that
>>>>>            (L Is L))]
>>>>>         {move 2:yyy}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define lprop2 : Imppf (lprop)

   define lprop2 : Imppf (lprop)

>>    lprop2: [(---:that (Not(A) Imp (L Is L)))]
>>      {move 1:L}


>>>
>>>>>    lprop2: [(---:that (Not(A) Imp (L Is L)))]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   define T3 A1 : Mp(Andi(Th2(L Is K,A1), \
      lprop2),Propfix3 A K L L)

   define T3 A1 : Mp(Andi(Th2(L Is K,A1), \
      lprop2),Propfix3 A K L L)

>>    T3: [(A1_1:that Not(A)) => (---:that Prop3(A,
>>         K,L,L))]
>>      {move 1:L}


>>>
>>>>>    T3: [(A1_1:that Not(A)) => (---:that Prop3(A,
>>>>>         K,L,L))]
>>>>>      {move 1:L}
>>>
>>>
>>>      comment  A1 * T4 := SOMEI([X,NAT]PROP3(X),L,T3) ; SOME([X:NAT]PROP3(X))
      comment  A1 * T4 := SOMEI([X,NAT]PROP3(X),L,T3) ; SOME([X:NAT]PROP3(X))

>>>
>>>
>>>   define T4 A1 : Somei(Propa3,L,T3 A1)

   define T4 A1 : Somei(Propa3,L,T3 A1)

>>    T4: [(A1_1:that Not(A)) => (---:that Some(Propa3))]
>>      {move 1:L}


>>>
>>>>>    T4: [(A1_1:that Not(A)) => (---:that Some(Propa3))]
>>>>>      {move 1:L}
>>>
>>>
>>>      comment  L * EXISTENCE := ANYCASE(A,SOME([X,NAT]PROP3(X),[T,A]T2(T),[T,NOT(A)]T4(T)) ; SOME([X,NAT]PROP3(X))
      comment  L * EXISTENCE := ANYCASE(A,SOME([X,NAT]PROP3(X),[T,A]T2(T),[T,NOT(A)]T4(T)) ; SOME([X,NAT]PROP3(X))

>>>
>>>
>>>   close

   close
>>>
>>>define Existence A K L : Anycase(Imppf T2, \
   Imppf (T4))

define Existence A K L : Anycase(Imppf T2, \
   Imppf (T4))

>> Existence: [(A_1:prop),(K_1:in Nat),(L_1:
>>      in Nat) => ((Imppf([(A0_4:that A_1) =>
>>         (Somei([(yyy_5:in Nat) => (Prop3(A_1,
>>            K_1,L_1,yyy_5):prop)]
>>         ,K_1,((Imppf([(T_6:that A_1) => (Refleq(K_1):
>>            that (K_1 Is K_1))])
>>         Andi ((K_1 Is L_1) Th2 Th1(A0_4)))
>>         Mp Propfix3(A_1,K_1,L_1,K_1))):that
>>         Some([(yyy_7:in Nat) => (Prop3(A_1,
>>            K_1,L_1,yyy_7):prop)]))
>>         ])
>>      Anycase Imppf([(A1_9:that Not(A_1)) =>
>>         (Somei([(yyy_10:in Nat) => (Prop3(A_1,
>>            K_1,L_1,yyy_10):prop)]
>>         ,L_1,((((L_1 Is K_1) Th2 A1_9) Andi
>>         Imppf([(T_11:that Not(A_1)) => (Refleq(L_1):
>>            that (L_1 Is L_1))]))
>>         Mp Propfix3(A_1,K_1,L_1,L_1))):that
>>         Some([(yyy_12:in Nat) => (Prop3(A_1,
>>            K_1,L_1,yyy_12):prop)]))
>>         ]))
>>      :that Some([(yyy_13:in Nat) => (Prop3(A_1,
>>         K_1,L_1,yyy_13):prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> Existence: [(A_1:prop),(K_1:in Nat),(L_1:
>>>>>      in Nat) => ((Imppf([(A0_4:that A_1) =>
>>>>>         (Somei([(yyy_5:in Nat) => (Prop3(A_1,
>>>>>            K_1,L_1,yyy_5):prop)]
>>>>>         ,K_1,((Imppf([(T_6:that A_1) => (Refleq(K_1):
>>>>>            that (K_1 Is K_1))])
>>>>>         Andi ((K_1 Is L_1) Th2 Th1(A0_4)))
>>>>>         Mp Propfix3(A_1,K_1,L_1,K_1))):that
>>>>>         Some([(yyy_7:in Nat) => (Prop3(A_1,
>>>>>            K_1,L_1,yyy_7):prop)]))
>>>>>         ])
>>>>>      Anycase Imppf([(A1_9:that Not(A_1)) =>
>>>>>         (Somei([(yyy_10:in Nat) => (Prop3(A_1,
>>>>>            K_1,L_1,yyy_10):prop)]
>>>>>         ,L_1,((((L_1 Is K_1) Th2 A1_9) Andi
>>>>>         Imppf([(T_11:that Not(A_1)) => (Refleq(L_1):
>>>>>            that (L_1 Is L_1))]))
>>>>>         Mp Propfix3(A_1,K_1,L_1,L_1))):that
>>>>>         Some([(yyy_12:in Nat) => (Prop3(A_1,
>>>>>            K_1,L_1,yyy_12):prop)]))
>>>>>         ]))
>>>>>      :that Some([(yyy_13:in Nat) => (Prop3(A_1,
>>>>>         K_1,L_1,yyy_13):prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent L
clearcurrent L

>>>
>>>
>>>open yyy

open yyy
>>>      comment  L * M := EB ; NAT
      comment  L * M := EB ; NAT

>>>
>>>
>>>   declare M in Nat

   declare M in Nat

>>    M: in Nat {move 2:yyy}


>>>
>>>>>    M: in Nat {move 2:yyy}
>>>
>>>
>>>      comment  M * P := EB ; PROP3(M)
      comment  M * P := EB ; PROP3(M)

>>>
>>>
>>>   declare M2 in Nat

   declare M2 in Nat

>>    M2: in Nat {move 2:yyy}


>>>
>>>>>    M2: in Nat {move 2:yyy}
>>>
>>>
>>>
>>>   declare P that Propa3 M

   declare P that Propa3 M

>>    P: that Propa3(M) {move 2:yyy}


>>>
>>>>>    P: that Propa3(M) {move 2:yyy}
>>>
>>>
>>>      comment  P * A0 := EB ; A
      comment  P * A0 := EB ; A

>>>
>>>
>>>   declare a0 that A

   declare a0 that A

>>    a0: that A {move 2:yyy}


>>>
>>>>>    a0: that A {move 2:yyy}
>>>
>>>
>>>      comment  A0 * T5 := <A0>ANDE1(PROP1(M),PROP2(M),P) ; IS(M,K)
      comment  A0 * T5 := <A0>ANDE1(PROP1(M),PROP2(M),P) ; IS(M,K)

>>>
>>>
>>>   define T5 P a0 : Mp a0 (Ande1(P))

   define T5 P a0 : Mp a0 (Ande1(P))

>>    T5: [(.M_1:in Nat),(P_1:that Propa3(.M_1)),
>>         (a0_1:that A) => (---:that (.M_1 Is
>>         K))]
>>      {move 1:L}


>>>
>>>>>    T5: [(.M_1:in Nat),(P_1:that Propa3(.M_1)),
>>>>>         (a0_1:that A) => (---:that (.M_1 Is
>>>>>         K))]
>>>>>      {move 1:L}
>>>
>>>
>>>      comment  P * A1 := EB ; NOT(A)
      comment  P * A1 := EB ; NOT(A)

>>>
>>>
>>>   declare a1 that Not A

   declare a1 that Not A

>>    a1: that Not(A) {move 2:yyy}


>>>
>>>>>    a1: that Not(A) {move 2:yyy}
>>>
>>>
>>>      comment  A1 * T6 := <A1>ANDE2(PROP1(M),PROP2(M),P) ; IS(M,L)
      comment  A1 * T6 := <A1>ANDE2(PROP1(M),PROP2(M),P) ; IS(M,L)

>>>
>>>
>>>   define T6 P a1 : Mp (a1, Ande2(P))

   define T6 P a1 : Mp (a1, Ande2(P))

>>    T6: [(.M_1:in Nat),(P_1:that Propa3(.M_1)),
>>         (a1_1:that Not(A)) => (---:that (.M_1
>>         Is L))]
>>      {move 1:L}


>>>
>>>>>    T6: [(.M_1:in Nat),(P_1:that Propa3(.M_1)),
>>>>>         (a1_1:that Not(A)) => (---:that (.M_1
>>>>>         Is L))]
>>>>>      {move 1:L}
>>>
>>>
>>>      comment  M * N := EB ; NAT
      comment  M * N := EB ; NAT

>>>
>>>      comment  already declared as M2 above
      comment  already declared as M2 above

>>>
>>>      comment  N * P := EB ; PROP3(M)
      comment  N * P := EB ; PROP3(M)

>>>
>>>      comment  already declared
      comment  already declared

>>>
>>>      comment  P * Q := EB ; PROP3(M2)
      comment  P * Q := EB ; PROP3(M2)

>>>
>>>
>>>   declare Q that Propa3 M2

   declare Q that Propa3 M2

>>    Q: that Propa3(M2) {move 2:yyy}


>>>
>>>>>    Q: that Propa3(M2) {move 2:yyy}
>>>
>>>
>>>      comment  Q * A0 := EB ; A
      comment  Q * A0 := EB ; A

>>>
>>>      comment  already declared
      comment  already declared

>>>
>>>
>>>   open

   open
>>>
>>>      declare aa0 that A

      declare aa0 that A

>>       aa0: that A {move 3}


>>>
>>>>>       aa0: that A {move 3}
>>>
>>>
>>>
>>>      declare aa1 that Not A

      declare aa1 that Not A

>>       aa1: that Not(A) {move 3}


>>>
>>>>>       aa1: that Not(A) {move 3}
>>>
>>>
>>>           comment  A0 * T7 := CONVEQ(M,N,K,T5(M,P,A0),T5(N,Q,A0)) ; IS(M,N)
           comment  A0 * T7 := CONVEQ(M,N,K,T5(M,P,A0),T5(N,Q,A0)) ; IS(M,N)

>>>
>>>
>>>      define T7 aa0 : Conveq(T5(P,aa0),T5(Q, \
         aa0))

      define T7 aa0 : Conveq(T5(P,aa0),T5(Q, \
         aa0))

>>       T7: [(aa0_1:that A) => (---:that (M
>>            Is M2))]
>>         {move 2:yyy}


>>>
>>>>>       T7: [(aa0_1:that A) => (---:that (M
>>>>>            Is M2))]
>>>>>         {move 2:yyy}
>>>
>>>
>>>           comment  Q * A1 := EB ; NOT(A)
           comment  Q * A1 := EB ; NOT(A)

>>>
>>>           comment  already declared
           comment  already declared

>>>
>>>           comment  A1 * T8 := CONVEQ(M,N,L,T6(M,P,A1),T6(N,Q,A1)); IS(M,N)
           comment  A1 * T8 := CONVEQ(M,N,L,T6(M,P,A1),T6(N,Q,A1)); IS(M,N)

>>>
>>>
>>>      define T8 aa1 : Conveq(T6(P,aa1),T6(Q, \
         aa1))

      define T8 aa1 : Conveq(T6(P,aa1),T6(Q, \
         aa1))

>>       T8: [(aa1_1:that Not(A)) => (---:that
>>            (M Is M2))]
>>         {move 2:yyy}


>>>
>>>>>       T8: [(aa1_1:that Not(A)) => (---:that
>>>>>            (M Is M2))]
>>>>>         {move 2:yyy}
>>>
>>>
>>>           comment  Q * UNICITY := ANYCASE(A,IS(M,N),[T,A]T7(T),[T,NOT(A)]T8(T)) ; IS(M,N)
           comment  Q * UNICITY := ANYCASE(A,IS(M,N),[T,A]T7(T),[T,NOT(A)]T8(T)) ; IS(M,N)

>>>
>>>
>>>      close

      close
>>>
>>>   define Unicity1 P Q : Anycase(Imppf T7, \
      Imppf (T8))

   define Unicity1 P Q : Anycase(Imppf T7, \
      Imppf (T8))

>>    Unicity1: [(.M_1:in Nat),(P_1:that Propa3(.M_1)),
>>         (.M2_1:in Nat),(Q_1:that Propa3(.M2_1))
>>         => (---:that (.M_1 Is .M2_1))]
>>      {move 1:L}


>>>
>>>>>    Unicity1: [(.M_1:in Nat),(P_1:that Propa3(.M_1)),
>>>>>         (.M2_1:in Nat),(Q_1:that Propa3(.M2_1))
>>>>>         => (---:that (.M_1 Is .M2_1))]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>declare m in Nat

declare m in Nat

>> m: in Nat {move 1:L}


>>>
>>>>> m: in Nat {move 1:L}
>>>
>>>
>>>
>>>declare m2 in Nat

declare m2 in Nat

>> m2: in Nat {move 1:L}


>>>
>>>>> m2: in Nat {move 1:L}
>>>
>>>
>>>
>>>declare p that Propa3 m

declare p that Propa3 m

>> p: that Propa3(m) {move 1:L}


>>>
>>>>> p: that Propa3(m) {move 1:L}
>>>
>>>
>>>
>>>declare q that Propa3 m2

declare q that Propa3 m2

>> q: that Propa3(m2) {move 1:L}


>>>
>>>>> q: that Propa3(m2) {move 1:L}
>>>
>>>
>>>
>>>define Unicity A K L p q : Unicity1 p q

define Unicity A K L p q : Unicity1 p q

>> Unicity: [(A_1:prop),(K_1:in Nat),(L_1:in
>>      Nat),(.m_1:in Nat),(p_1:that Prop3(A_1,
>>      K_1,L_1,.m_1)),(.m2_1:in Nat),(q_1:that
>>      Prop3(A_1,K_1,L_1,.m2_1)) => ((Imppf([(aa0_2:
>>         that A_1) => (((aa0_2 Mp Ande1(p_1))
>>         Conveq (aa0_2 Mp Ande1(q_1))):that
>>         (.m_1 Is .m2_1))])
>>      Anycase Imppf([(aa1_3:that Not(A_1)) =>
>>         (((aa1_3 Mp Ande2(p_1)) Conveq (aa1_3
>>         Mp Ande2(q_1))):that (.m_1 Is .m2_1))]))
>>      :that (.m_1 Is .m2_1))]
>>   {move 0}


>>>
>>>>> Unicity: [(A_1:prop),(K_1:in Nat),(L_1:in
>>>>>      Nat),(.m_1:in Nat),(p_1:that Prop3(A_1,
>>>>>      K_1,L_1,.m_1)),(.m2_1:in Nat),(q_1:that
>>>>>      Prop3(A_1,K_1,L_1,.m2_1)) => ((Imppf([(aa0_2:
>>>>>         that A_1) => (((aa0_2 Mp Ande1(p_1))
>>>>>         Conveq (aa0_2 Mp Ande1(q_1))):that
>>>>>         (.m_1 Is .m2_1))])
>>>>>      Anycase Imppf([(aa1_3:that Not(A_1)) =>
>>>>>         (((aa1_3 Mp Ande2(p_1)) Conveq (aa1_3
>>>>>         Mp Ande2(q_1))):that (.m_1 Is .m2_1))]))
>>>>>      :that (.m_1 Is .m2_1))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare x1 in Nat

   declare x1 in Nat

>>    x1: in Nat {move 2}


>>>
>>>>>    x1: in Nat {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare x2 in Nat

      declare x2 in Nat

>>       x2: in Nat {move 3}


>>>
>>>>>       x2: in Nat {move 3}
>>>
>>>
>>>
>>>      open

      open
>>>
>>>         declare pp that (Propa3 x1) And \
            Propa3 x2

         declare pp that (Propa3 x1) And \
            Propa3 x2

>>          pp: that (Propa3(x1) And Propa3(x2))
>>            {move 4}


>>>
>>>>>          pp: that (Propa3(x1) And Propa3(x2))
>>>>>            {move 4}
>>>
>>>
>>>
>>>         define qq pp: Ande1 (pp)

         define qq pp: Ande1 (pp)

>>          qq: [(pp_1:that (Propa3(x1) And
>>               Propa3(x2))) => (---:that Propa3(x1))]
>>            {move 3}


>>>
>>>>>          qq: [(pp_1:that (Propa3(x1) And
>>>>>               Propa3(x2))) => (---:that Propa3(x1))]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         define rr pp: Ande2 (pp)

         define rr pp: Ande2 (pp)

>>          rr: [(pp_1:that (Propa3(x1) And
>>               Propa3(x2))) => (---:that Propa3(x2))]
>>            {move 3}


>>>
>>>>>          rr: [(pp_1:that (Propa3(x1) And
>>>>>               Propa3(x2))) => (---:that Propa3(x2))]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         define ss pp: Unicity1 (qq pp, (rr \
            pp))

         define ss pp: Unicity1 (qq pp, (rr \
            pp))

>>          ss: [(pp_1:that (Propa3(x1) And
>>               Propa3(x2))) => (---:that (x1
>>               Is x2))]
>>            {move 3}


>>>
>>>>>          ss: [(pp_1:that (Propa3(x1) And
>>>>>               Propa3(x2))) => (---:that (x1
>>>>>               Is x2))]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         close

         close
>>>
>>>      define tt x2 : Imppf (ss)

      define tt x2 : Imppf (ss)

>>       tt: [(x2_1:in Nat) => (---:that ((Propa3(x1)
>>            And Propa3(x2_1)) Imp (x1 Is x2_1)))]
>>         {move 2}


>>>
>>>>>       tt: [(x2_1:in Nat) => (---:that ((Propa3(x1)
>>>>>            And Propa3(x2_1)) Imp (x1 Is x2_1)))]
>>>>>         {move 2}
>>>
>>>
>>>           comment           define theprop1 x2:  ((Propa3 x1) And Propa3 x2) Imp x1 Is x2
           comment           define theprop1 x2:  ((Propa3 x1) And Propa3 x2) Imp x1 Is x2

>>>
>>>
>>>      close

      close
>>>
>>>   define uu x1 : Alli tt

   define uu x1 : Alli tt

>>    uu: [(x1_1:in Nat) => (---:that All([(x2_5:
>>            in Nat) => (((Propa3(x1_1) And Propa3(x2_5))
>>            Imp (x1_1 Is x2_5)):prop)]))
>>         ]
>>      {move 1:L}


>>>
>>>>>    uu: [(x1_1:in Nat) => (---:that All([(x2_5:
>>>>>            in Nat) => (((Propa3(x1_1) And Propa3(x2_5))
>>>>>            Imp (x1_1 Is x2_5)):prop)]))
>>>>>         ]
>>>>>      {move 1:L}
>>>
>>>
>>>      comment      define theprop2 x1 : All theprop1
      comment      define theprop2 x1 : All theprop1

>>>
>>>
>>>   close

   close
>>>
>>>define Uniqueness A K L : Alli uu

define Uniqueness A K L : Alli uu

>> Uniqueness: [(A_1:prop),(K_1:in Nat),(L_1:
>>      in Nat) => (Alli([(x1_4:in Nat) => (Alli([(x2_6:
>>            in Nat) => (Imppf([(pp_7:that (Prop3(A_1,
>>               K_1,L_1,x1_4) And Prop3(A_1,K_1,
>>               L_1,x2_6))) => ((Imppf([(aa0_8:
>>                  that A_1) => (((aa0_8 Mp Ande1(Ande1(pp_7)))
>>                  Conveq (aa0_8 Mp Ande1(Ande2(pp_7)))):
>>                  that (x1_4 Is x2_6))])
>>               Anycase Imppf([(aa1_9:that Not(A_1))
>>                  => (((aa1_9 Mp Ande2(Ande1(pp_7)))
>>                  Conveq (aa1_9 Mp Ande2(Ande2(pp_7)))):
>>                  that (x1_4 Is x2_6))]))
>>               :that (x1_4 Is x2_6))])
>>            :that ((Prop3(A_1,K_1,L_1,x1_4)
>>            And Prop3(A_1,K_1,L_1,x2_6)) Imp
>>            (x1_4 Is x2_6)))])
>>         :that All([(x2_10:in Nat) => (((Prop3(A_1,
>>            K_1,L_1,x1_4) And Prop3(A_1,K_1,
>>            L_1,x2_10)) Imp (x1_4 Is x2_10)):
>>            prop)]))
>>         ])
>>      :that All([(x1_11:in Nat) => (All([(x2_12:
>>            in Nat) => (((Prop3(A_1,K_1,L_1,
>>            x1_11) And Prop3(A_1,K_1,L_1,x2_12))
>>            Imp (x1_11 Is x2_12)):prop)])
>>         :prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> Uniqueness: [(A_1:prop),(K_1:in Nat),(L_1:
>>>>>      in Nat) => (Alli([(x1_4:in Nat) => (Alli([(x2_6:
>>>>>            in Nat) => (Imppf([(pp_7:that (Prop3(A_1,
>>>>>               K_1,L_1,x1_4) And Prop3(A_1,K_1,
>>>>>               L_1,x2_6))) => ((Imppf([(aa0_8:
>>>>>                  that A_1) => (((aa0_8 Mp Ande1(Ande1(pp_7)))
>>>>>                  Conveq (aa0_8 Mp Ande1(Ande2(pp_7)))):
>>>>>                  that (x1_4 Is x2_6))])
>>>>>               Anycase Imppf([(aa1_9:that Not(A_1))
>>>>>                  => (((aa1_9 Mp Ande2(Ande1(pp_7)))
>>>>>                  Conveq (aa1_9 Mp Ande2(Ande2(pp_7)))):
>>>>>                  that (x1_4 Is x2_6))]))
>>>>>               :that (x1_4 Is x2_6))])
>>>>>            :that ((Prop3(A_1,K_1,L_1,x1_4)
>>>>>            And Prop3(A_1,K_1,L_1,x2_6)) Imp
>>>>>            (x1_4 Is x2_6)))])
>>>>>         :that All([(x2_10:in Nat) => (((Prop3(A_1,
>>>>>            K_1,L_1,x1_4) And Prop3(A_1,K_1,
>>>>>            L_1,x2_10)) Imp (x1_4 Is x2_10)):
>>>>>            prop)]))
>>>>>         ])
>>>>>      :that All([(x1_11:in Nat) => (All([(x2_12:
>>>>>            in Nat) => (((Prop3(A_1,K_1,L_1,
>>>>>            x1_11) And Prop3(A_1,K_1,L_1,x2_12))
>>>>>            Imp (x1_11 Is x2_12)):prop)])
>>>>>         :prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>> comment  comment  L * T9 := ANDI(SOME([X,NAT]PROP3(X)),NOTTWO([X,NAT]PROP3(X)),EXISTENCE,
 comment  comment  L * T9 := ANDI(SOME([X,NAT]PROP3(X)),NOTTWO([X,NAT]PROP3(X)),EXISTENCE,
>>> comment  [X,NAT][Y,NAT][T,PROP3(X)][U,PROP3(Y)]UNICITY(X,Y,T,U)) ; ONE([X,NAT]PROP3(X))
 comment  [X,NAT][Y,NAT][T,PROP3(X)][U,PROP3(Y)]UNICITY(X,Y,T,U)) ; ONE([X,NAT]PROP3(X))

>>>
>>>
>>>define T9 A K L : Andi(Existence A K L,Uniqueness \
   A K L)

define T9 A K L : Andi(Existence A K L,Uniqueness \
   A K L)

>> T9: [(A_1:prop),(K_1:in Nat),(L_1:in Nat)
>>      => ((Existence(A_1,K_1,L_1) Andi Uniqueness(A_1,
>>      K_1,L_1)):that (Some([(yyy_5:in Nat) =>
>>         (Prop3(A_1,K_1,L_1,yyy_5):prop)])
>>      And All([(x1_6:in Nat) => (All([(x2_7:
>>            in Nat) => (((Prop3(A_1,K_1,L_1,
>>            x1_6) And Prop3(A_1,K_1,L_1,x2_7))
>>            Imp (x1_6 Is x2_7)):prop)])
>>         :prop)]))
>>      )]
>>   {move 0}


>>>
>>>>> T9: [(A_1:prop),(K_1:in Nat),(L_1:in Nat)
>>>>>      => ((Existence(A_1,K_1,L_1) Andi Uniqueness(A_1,
>>>>>      K_1,L_1)):that (Some([(yyy_5:in Nat) =>
>>>>>         (Prop3(A_1,K_1,L_1,yyy_5):prop)])
>>>>>      And All([(x1_6:in Nat) => (All([(x2_7:
>>>>>            in Nat) => (((Prop3(A_1,K_1,L_1,
>>>>>            x1_6) And Prop3(A_1,K_1,L_1,x2_7))
>>>>>            Imp (x1_6 Is x2_7)):prop)])
>>>>>         :prop)]))
>>>>>      )]
>>>>>   {move 0}
>>>
>>>
>>> comment  L * N0 := INDIVIDUAL([X,NAT]PROP3(X),T9) ;NAT
 comment  L * N0 := INDIVIDUAL([X,NAT]PROP3(X),T9) ;NAT

>>>
>>>
>>>define Ifthenelse A K L : Individual (T9 \
   A K L)

define Ifthenelse A K L : Individual (T9 \
   A K L)

>> Ifthenelse: [(A_1:prop),(K_1:in Nat),(L_1:
>>      in Nat) => (Individual(T9(A_1,K_1,L_1)):
>>      in Nat)]
>>   {move 0}


>>>
>>>>> Ifthenelse: [(A_1:prop),(K_1:in Nat),(L_1:
>>>>>      in Nat) => (Individual(T9(A_1,K_1,L_1)):
>>>>>      in Nat)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define T10 A K L : Axindividual (T9 A K L)

define T10 A K L : Axindividual (T9 A K L)


>> T10: [(A_1:prop),(K_1:in Nat),(L_1:in Nat)
>>      => (Axindividual(T9(A_1,K_1,L_1)):that
>>      Prop3(A_1,K_1,L_1,Individual(T9(A_1,K_1,
>>      L_1))))]
>>   {move 0}


>>>
>>>
>>>>> T10: [(A_1:prop),(K_1:in Nat),(L_1:in Nat)
>>>>>      => (Axindividual(T9(A_1,K_1,L_1)):that
>>>>>      Prop3(A_1,K_1,L_1,Individual(T9(A_1,K_1,
>>>>>      L_1))))]
>>>>>   {move 0}
>>>
>>>
>>> comment  L *IFTHENELSE *N0"-3" ; NAT
 comment  L *IFTHENELSE *N0"-3" ; NAT

>>>
>>> comment  already declared
 comment  already declared

>>>
>>> comment  L * A0 := EB ; A
 comment  L * A0 := EB ; A

>>>
>>>
>>>declare A0 that A

declare A0 that A

>> A0: that A {move 1:L}


>>>
>>>>> A0: that A {move 1:L}
>>>
>>>
>>> comment  A0 * THEN := T5"-3"(N0"-3",T10"-3",A0) ; IS(IFTHENELSE,K)
 comment  A0 * THEN := T5"-3"(N0"-3",T10"-3",A0) ; IS(IFTHENELSE,K)

>>>
>>>
>>>define Then0 A K L A0 : T5(T10 A K L,A0)

define Then0 A K L A0 : T5(T10 A K L,A0)


>> Then0: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>      (A0_1:that A_1) => ((A0_1 Mp Ande1(T10(A_1,
>>      K_1,L_1))):that (Individual(T9(A_1,K_1,
>>      L_1)) Is K_1))]
>>   {move 0}


>>>
>>>
>>>>> Then0: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>>>>      (A0_1:that A_1) => ((A0_1 Mp Ande1(T10(A_1,
>>>>>      K_1,L_1))):that (Individual(T9(A_1,K_1,
>>>>>      L_1)) Is K_1))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define Then A K L A0 : Fixfun(Ifthenelse(A, \
   K,L) Is K,Then0(A,K,L,A0))

define Then A K L A0 : Fixfun(Ifthenelse(A, \
   K,L) Is K,Then0(A,K,L,A0))

>> Then: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>      (A0_1:that A_1) => (((Ifthenelse(A_1,K_1,
>>      L_1) Is K_1) Fixfun Then0(A_1,K_1,L_1,
>>      A0_1)):that (Ifthenelse(A_1,K_1,L_1) Is
>>      K_1))]
>>   {move 0}


>>>
>>>>> Then: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>>>>      (A0_1:that A_1) => (((Ifthenelse(A_1,K_1,
>>>>>      L_1) Is K_1) Fixfun Then0(A_1,K_1,L_1,
>>>>>      A0_1)):that (Ifthenelse(A_1,K_1,L_1) Is
>>>>>      K_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  L * A1 := EB ; NOT(A)
 comment  L * A1 := EB ; NOT(A)

>>>
>>>
>>>declare A1 that Not A

declare A1 that Not A

>> A1: that Not(A) {move 1:L}


>>>
>>>>> A1: that Not(A) {move 1:L}
>>>
>>>
>>> comment  A1 * ELSE := T6"-3"(No"-3",T10"-3",A1) ; IS(IFTHENELSE,L)
 comment  A1 * ELSE := T6"-3"(No"-3",T10"-3",A1) ; IS(IFTHENELSE,L)

>>>
>>>
>>>define Else0 A K L A1 : T6(T10 A K L,A1)

define Else0 A K L A1 : T6(T10 A K L,A1)


>> Else0: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>      (A1_1:that Not(A_1)) => ((A1_1 Mp Ande2(T10(A_1,
>>      K_1,L_1))):that (Individual(T9(A_1,K_1,
>>      L_1)) Is L_1))]
>>   {move 0}


>>>
>>>
>>>>> Else0: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>>>>      (A1_1:that Not(A_1)) => ((A1_1 Mp Ande2(T10(A_1,
>>>>>      K_1,L_1))):that (Individual(T9(A_1,K_1,
>>>>>      L_1)) Is L_1))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define Else A K L A1 : Fixfun (Ifthenelse \
   (A, K, L) Is L,Else0 A K L A1)

define Else A K L A1 : Fixfun (Ifthenelse \
   (A, K, L) Is L,Else0 A K L A1)

>> Else: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>      (A1_1:that Not(A_1)) => (((Ifthenelse(A_1,
>>      K_1,L_1) Is L_1) Fixfun Else0(A_1,K_1,
>>      L_1,A1_1)):that (Ifthenelse(A_1,K_1,L_1)
>>      Is L_1))]
>>   {move 0}


>>>
>>>>> Else: [(A_1:prop),(K_1:in Nat),(L_1:in Nat),
>>>>>      (A1_1:that Not(A_1)) => (((Ifthenelse(A_1,
>>>>>      K_1,L_1) Is L_1) Fixfun Else0(A_1,K_1,
>>>>>      L_1,A1_1)):that (Ifthenelse(A_1,K_1,L_1)
>>>>>      Is L_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent
clearcurrent

>>>
>>> comment  * SET := PN ; TYPE
 comment  * SET := PN ; TYPE

>>>
>>>
>>>postulate Set type

postulate Set type

>> Set: type {move 0}


>>>
>>>>> Set: type {move 0}
>>>
>>>
>>> comment  * K := EB ; NAT
 comment  * K := EB ; NAT

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1}


>>>
>>>>> K: in Nat {move 1}
>>>
>>>
>>> comment  K * S := EB ; SET
 comment  K * S := EB ; SET

>>>
>>>
>>>declare S in Set

declare S in Set

>> S: in Set {move 1}


>>>
>>>>> S: in Set {move 1}
>>>
>>>
>>> comment  S * IN := PN ; PROP
 comment  S * IN := PN ; PROP

>>>
>>>
>>>postulate In K S :prop

postulate In K S :prop

>> In: [(K_1:in Nat),(S_1:in Set) => (---:prop)]
>>   {move 0}


>>>
>>>>> In: [(K_1:in Nat),(S_1:in Set) => (---:prop)]
>>>>>   {move 0}
>>>
>>>
>>> comment  * P := EB ; [X,NAT]PROP
 comment  * P := EB ; [X,NAT]PROP

>>>
>>>clearcurrent
clearcurrent

>>>
>>>
>>>open

open
>>>
>>>   declare x1 in Nat

   declare x1 in Nat

>>    x1: in Nat {move 2}


>>>
>>>>>    x1: in Nat {move 2}
>>>
>>>
>>>
>>>   postulate P x1 : prop

   postulate P x1 : prop

>>    P: [(x1_1:in Nat) => (---:prop)]
>>      {move 1}


>>>
>>>>>    P: [(x1_1:in Nat) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>> comment  P * SETOF := PN ; SET
 comment  P * SETOF := PN ; SET

>>>
>>>
>>>postulate Setof P : in Set

postulate Setof P : in Set

>> Setof: [(P_1:[(x1_2:in Nat) => (---:prop)])
>>      => (---:in Set)]
>>   {move 0}


>>>
>>>>> Setof: [(P_1:[(x1_2:in Nat) => (---:prop)])
>>>>>      => (---:in Set)]
>>>>>   {move 0}
>>>
>>>
>>> comment  P * K := EB ; NAT
 comment  P * K := EB ; NAT

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1}


>>>
>>>>> K: in Nat {move 1}
>>>
>>>
>>> comment  K * KP := EB ; <K>P
 comment  K * KP := EB ; <K>P

>>>
>>>
>>>declare Kp that P K

declare Kp that P K

>> Kp: that P(K) {move 1}


>>>
>>>>> Kp: that P(K) {move 1}
>>>
>>>
>>> comment  KP * INI := PN ; IN(K,SETOF(P))
 comment  KP * INI := PN ; IN(K,SETOF(P))

>>>
>>>
>>>postulate Ini P, K Kp that K In Setof P

postulate Ini P, K Kp that K In Setof P

>> Ini: [(P_1:[(x1_2:in Nat) => (---:prop)]),
>>      (K_1:in Nat),(Kp_1:that P_1(K_1)) => (---:
>>      that (K_1 In Setof(P_1)))]
>>   {move 0}


>>>
>>>>> Ini: [(P_1:[(x1_2:in Nat) => (---:prop)]),
>>>>>      (K_1:in Nat),(Kp_1:that P_1(K_1)) => (---:
>>>>>      that (K_1 In Setof(P_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  K * I := EB ; IN(K,SETOF(P))
 comment  K * I := EB ; IN(K,SETOF(P))

>>>
>>>
>>>declare I that K In Setof P

declare I that K In Setof P

>> I: that (K In Setof(P)) {move 1}


>>>
>>>>> I: that (K In Setof(P)) {move 1}
>>>
>>>
>>> comment  I * INE := PN ; <K>P
 comment  I * INE := PN ; <K>P

>>>
>>>
>>>postulate Ine K I that P K

postulate Ine K I that P K

>> Ine: [(K_1:in Nat),(.P_1:[(x1_2:in Nat) =>
>>         (---:prop)]),
>>      (I_1:that (K_1 In Setof(.P_1))) => (---:
>>      that .P_1(K_1))]
>>   {move 0}


>>>
>>>>> Ine: [(K_1:in Nat),(.P_1:[(x1_2:in Nat) =>
>>>>>         (---:prop)]),
>>>>>      (I_1:that (K_1 In Setof(.P_1))) => (---:
>>>>>      that .P_1(K_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent
clearcurrent

>>>
>>> comment  +NATURALS
 comment  +NATURALS

>>>
>>> comment  * 1 := PN ; NAT
 comment  * 1 := PN ; NAT

>>>
>>>
>>>postulate 1 in Nat

postulate 1 in Nat

>> 1: in Nat {move 0}


>>>
>>>>> 1: in Nat {move 0}
>>>
>>>
>>> comment  * K := EB ; NAT
 comment  * K := EB ; NAT

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1}


>>>
>>>>> K: in Nat {move 1}
>>>
>>>
>>> comment  K * SUC := PN ; NAT
 comment  K * SUC := PN ; NAT

>>>
>>>
>>>postulate Suc K in Nat

postulate Suc K in Nat

>> Suc: [(K_1:in Nat) => (---:in Nat)]
>>   {move 0}


>>>
>>>>> Suc: [(K_1:in Nat) => (---:in Nat)]
>>>>>   {move 0}
>>>
>>>
>>> comment  K * L := EB ; NAT
 comment  K * L := EB ; NAT

>>>
>>>
>>>declare L in Nat

declare L in Nat

>> L: in Nat {move 1}


>>>
>>>>> L: in Nat {move 1}
>>>
>>>
>>> comment  L * I := EB ; IS(K,L)
 comment  L * I := EB ; IS(K,L)

>>>
>>>
>>>save L

save L
>>>
>>>declare I that K Is L

declare I that K Is L

>> I: that (K Is L) {move 1:L}


>>>
>>>>> I: that (K Is L) {move 1:L}
>>>
>>>
>>> comment  I * AX2 := EQPRED1(K,L,I,[X,NAT]IS(SUC(K),SUC(X)),REFLEQ(SUC(K)) ; IS(SUC(K),SUC(L))
 comment  I * AX2 := EQPRED1(K,L,I,[X,NAT]IS(SUC(K),SUC(X)),REFLEQ(SUC(K)) ; IS(SUC(K),SUC(L))

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   define keqx x : (Suc K) Is (Suc x)

   define keqx x : (Suc K) Is (Suc x)

>>    keqx: [(x_1:in Nat) => (---:prop)]
>>      {move 1:L}


>>>
>>>>>    keqx: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Ax2 K L I : Eqpred1(I,keqx,Refleq \
   Suc K)

define Ax2 K L I : Eqpred1(I,keqx,Refleq \
   Suc K)

>> Ax2: [(K_1:in Nat),(L_1:in Nat),(I_1:that
>>      (K_1 Is L_1)) => (Eqpred1(I_1,[(x_2:in
>>         Nat) => ((Suc(K_1) Is Suc(x_2)):prop)]
>>      ,Refleq(Suc(K_1))):that (Suc(K_1) Is Suc(L_1)))]
>>   {move 0}


>>>
>>>>> Ax2: [(K_1:in Nat),(L_1:in Nat),(I_1:that
>>>>>      (K_1 Is L_1)) => (Eqpred1(I_1,[(x_2:in
>>>>>         Nat) => ((Suc(K_1) Is Suc(x_2)):prop)]
>>>>>      ,Refleq(Suc(K_1))):that (Suc(K_1) Is Suc(L_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  K * AX3 := PN ; NOT(IS(SUC(K),1))
 comment  K * AX3 := PN ; NOT(IS(SUC(K),1))

>>>
>>>
>>>postulate Ax3 K : that Not (Suc K Is 1)

postulate Ax3 K : that Not (Suc K Is 1)

>> Ax3: [(K_1:in Nat) => (---:that Not((Suc(K_1)
>>      Is 1)))]
>>   {move 0}


>>>
>>>>> Ax3: [(K_1:in Nat) => (---:that Not((Suc(K_1)
>>>>>      Is 1)))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent L
clearcurrent L

>>>
>>> comment  L * I := EB ; IS(SUC(K),SUC(L))
 comment  L * I := EB ; IS(SUC(K),SUC(L))

>>>
>>>
>>>declare I that (Suc K) Is (Suc L)

declare I that (Suc K) Is (Suc L)

>> I: that (Suc(K) Is Suc(L)) {move 1:L}


>>>
>>>>> I: that (Suc(K) Is Suc(L)) {move 1:L}
>>>
>>>
>>> comment  I * AX4 := PN ; IS(K,L)
 comment  I * AX4 := PN ; IS(K,L)

>>>
>>>
>>>postulate Ax4 I : that K Is L

postulate Ax4 I : that K Is L

>> Ax4: [(.K_1:in Nat),(.L_1:in Nat),(I_1:that
>>      (Suc(.K_1) Is Suc(.L_1))) => (---:that
>>      (.K_1 Is .L_1))]
>>   {move 0}


>>>
>>>>> Ax4: [(.K_1:in Nat),(.L_1:in Nat),(I_1:that
>>>>>      (Suc(.K_1) Is Suc(.L_1))) => (---:that
>>>>>      (.K_1 Is .L_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent
clearcurrent

>>>
>>> comment  * S := EB ; SET
 comment  * S := EB ; SET

>>>
>>>
>>>declare S in Set

declare S in Set

>> S: in Set {move 1}


>>>
>>>>> S: in Set {move 1}
>>>
>>>
>>> comment  S * PROGRESSIVE := ALL([X,NAT]IMP(IN(X,S),IN(SUC(X),S))) ; PROP
 comment  S * PROGRESSIVE := ALL([X,NAT]IMP(IN(X,S),IN(SUC(X),S))) ; PROP

>>>
>>>
>>>open

open
>>>
>>>   declare s in Set

   declare s in Set

>>    s: in Set {move 2}


>>>
>>>>>    s: in Set {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare x in Nat

      declare x in Nat

>>       x: in Nat {move 3}


>>>
>>>>>       x: in Nat {move 3}
>>>
>>>
>>>
>>>      define progress x: (x In s) Imp Suc \
         x In s

      define progress x: (x In s) Imp Suc \
         x In s

>>       progress: [(x_1:in Nat) => (---:prop)]
>>         {move 2}


>>>
>>>>>       progress: [(x_1:in Nat) => (---:prop)]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define Progressive s : All progress

   define Progressive s : All progress

>>    Progressive: [(s_1:in Set) => (---:prop)]
>>      {move 1}


>>>
>>>>>    Progressive: [(s_1:in Set) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>> comment  S * P := EB ; PROGRESSIVE(S)
 comment  S * P := EB ; PROGRESSIVE(S)

>>>
>>>
>>>declare P that Progressive S

declare P that Progressive S

>> P: that Progressive(S) {move 1}


>>>
>>>>> P: that Progressive(S) {move 1}
>>>
>>>
>>>
>>>save P

save P
>>> comment  P * I := EB ; IN(1,S)
 comment  P * I := EB ; IN(1,S)

>>>
>>>
>>>declare I that 1 In S

declare I that 1 In S

>> I: that (1 In S) {move 1:P}


>>>
>>>>> I: that (1 In S) {move 1:P}
>>>
>>>
>>> comment  I * K := EB ; NAT
 comment  I * K := EB ; NAT

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1:P}


>>>
>>>>> K: in Nat {move 1:P}
>>>
>>>
>>> comment  K * AX5 := PN ; IN(K,S)
 comment  K * AX5 := PN ; IN(K,S)

>>>
>>> comment  comment  Again, the issue is definition expansion!
 comment  comment  Again, the issue is definition expansion!
>>> comment  why won't it accept S as implicit?
 comment  why won't it accept S as implicit?

>>>
>>> comment  comment  it does now.  The implicit argument inference feature
 comment  comment  it does now.  The implicit argument inference feature
>>> comment  does not always play nicely with definitions.
 comment  does not always play nicely with definitions.

>>>
>>>
>>>postulate Ax5 P I K : that K In S

postulate Ax5 P I K : that K In S

>> Ax5: [(.S_1:in Set),(P_1:that All([(x_2:in
>>         Nat) => (((x_2 In .S_1) Imp (Suc(x_2)
>>         In .S_1)):prop)]))
>>      ,(I_1:that (1 In .S_1)),(K_1:in Nat) =>
>>      (---:that (K_1 In .S_1))]
>>   {move 0}


>>>
>>>>> Ax5: [(.S_1:in Set),(P_1:that All([(x_2:in
>>>>>         Nat) => (((x_2 In .S_1) Imp (Suc(x_2)
>>>>>         In .S_1)):prop)]))
>>>>>      ,(I_1:that (1 In .S_1)),(K_1:in Nat) =>
>>>>>      (---:that (K_1 In .S_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent
clearcurrent

>>>
>>> comment  * P := EB ; [X,NAT]PROP
 comment  * P := EB ; [X,NAT]PROP

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   postulate P x prop

   postulate P x prop

>>    P: [(x_1:in Nat) => (---:prop)]
>>      {move 1}


>>>
>>>>>    P: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>> comment  P * 1P := EB ; <1>P
 comment  P * 1P := EB ; <1>P

>>>
>>>
>>>declare Onep that P 1

declare Onep that P 1

>> Onep: that P(1) {move 1}


>>>
>>>>> Onep: that P(1) {move 1}
>>>
>>>
>>> comment  1P * A := EB ; ALL)[X,NAT]IMP(<X>P,<SUC(X)>P))
 comment  1P * A := EB ; ALL)[X,NAT]IMP(<X>P,<SUC(X)>P))

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   define progress x : P x Imp P Suc x

   define progress x : P x Imp P Suc x

>>    progress: [(x_1:in Nat) => (---:prop)]
>>      {move 1}


>>>
>>>>>    progress: [(x_1:in Nat) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>declare A that All progress

declare A that All progress

>> A: that All(progress) {move 1}


>>>
>>>>> A: that All(progress) {move 1}
>>>
>>>
>>> comment  A * K := EB ; NAT
 comment  A * K := EB ; NAT

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1}


>>>
>>>>> K: in Nat {move 1}
>>>
>>>
>>> comment  +0
 comment  +0

>>>
>>> comment  A * S0 := SETOF(P) ; SET
 comment  A * S0 := SETOF(P) ; SET

>>>
>>>
>>>define S0 P : Setof P

define S0 P : Setof P

>> S0: [(P_1:[(x_2:in Nat) => (---:prop)])
>>      => (Setof(P_1):in Set)]
>>   {move 0}


>>>
>>>>> S0: [(P_1:[(x_2:in Nat) => (---:prop)])
>>>>>      => (Setof(P_1):in Set)]
>>>>>   {move 0}
>>>
>>>
>>> comment  A * T1 := INI(P,1,1P) ; IN(1,S0)
 comment  A * T1 := INI(P,1,1P) ; IN(1,S0)

>>>
>>>
>>>define T1 P, Onep : Ini P, 1 Onep

define T1 P, Onep : Ini P, 1 Onep

>> T1: [(P_1:[(x_2:in Nat) => (---:prop)]),
>>      (Onep_1:that P_1(1)) => (Ini(P_1,1,Onep_1):
>>      that (1 In Setof(P_1)))]
>>   {move 0}


>>>
>>>>> T1: [(P_1:[(x_2:in Nat) => (---:prop)]),
>>>>>      (Onep_1:that P_1(1)) => (Ini(P_1,1,Onep_1):
>>>>>      that (1 In Setof(P_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  K * I := EB ; IN(K,S0)
 comment  K * I := EB ; IN(K,S0)

>>>
>>>
>>>declare I that K In S0 P

declare I that K In S0 P

>> I: that (K In S0(P)) {move 1}


>>>
>>>>> I: that (K In S0(P)) {move 1}
>>>
>>>
>>> comment  I * T2 := INI(P,SUC(K),<INE(P,K,I)><K>A) ; IN(SUC(K),S0)
 comment  I * T2 := INI(P,SUC(K),<INE(P,K,I)><K>A) ; IN(SUC(K),S0)

>>>
>>> comment  -0
 comment  -0

>>>
>>> comment  K * INDUCTION := Ine(P,K,AX5(S0"-0",[X,NAT][T.IN(X,S0"-0")]T2"-0"(X,T),T1"-0",K)) ; <K>P
 comment  K * INDUCTION := Ine(P,K,AX5(S0"-0",[X,NAT][T.IN(X,S0"-0")]T2"-0"(X,T),T1"-0",K)) ; <K>P

>>>
>>>
>>>open

open
>>>
>>>   declare x in Nat

   declare x in Nat

>>    x: in Nat {move 2}


>>>
>>>>>    x: in Nat {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare ev that x In S0 P

      declare ev that x In S0 P

>>       ev: that (x In S0(P)) {move 3}


>>>
>>>>>       ev: that (x In S0(P)) {move 3}
>>>
>>>
>>>
>>>      define step1 ev : Ine x ev

      define step1 ev : Ine x ev

>>       step1: [(ev_1:that (x In S0(P))) =>
>>            (---:that P(x))]
>>         {move 2}


>>>
>>>>>       step1: [(ev_1:that (x In S0(P))) =>
>>>>>            (---:that P(x))]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      define step2 ev : Alle x A

      define step2 ev : Alle x A

>>       step2: [(ev_1:that (x In S0(P))) =>
>>            (---:that progress(x))]
>>         {move 2}


>>>
>>>>>       step2: [(ev_1:that (x In S0(P))) =>
>>>>>            (---:that progress(x))]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      define step3 ev: Mp (step1 ev, step2 \
         ev)

      define step3 ev: Mp (step1 ev, step2 \
         ev)

>>       step3: [(ev_1:that (x In S0(P))) =>
>>            (---:that P(Suc(x)))]
>>         {move 2}


>>>
>>>>>       step3: [(ev_1:that (x In S0(P))) =>
>>>>>            (---:that P(Suc(x)))]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      define step4 ev: Ini P, Suc x step3 \
         ev

      define step4 ev: Ini P, Suc x step3 \
         ev

>>       step4: [(ev_1:that (x In S0(P))) =>
>>            (---:that (Suc(x) In Setof(P)))]
>>         {move 2}


>>>
>>>>>       step4: [(ev_1:that (x In S0(P))) =>
>>>>>            (---:that (Suc(x) In Setof(P)))]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define progress2 x: Imppf (step4)

   define progress2 x: Imppf (step4)

>>    progress2: [(x_1:in Nat) => (---:that
>>         ((x_1 In S0(P)) Imp (Suc(x_1) In Setof(P))))]
>>      {move 1}


>>>
>>>>>    progress2: [(x_1:in Nat) => (---:that
>>>>>         ((x_1 In S0(P)) Imp (Suc(x_1) In Setof(P))))]
>>>>>      {move 1}
>>>
>>>
>>>      comment      define progressive2 x: Imp (x In S0 P,(Suc x) In S0 P)
      comment      define progressive2 x: Imp (x In S0 P,(Suc x) In S0 P)

>>>
>>>
>>>   close

   close
>>> comment  comment  why could I not make P implicit?
 comment  comment  why could I not make P implicit?
>>> comment  solved:  it is hidden in a defined concept progress that isn't expanded.
 comment  solved:  it is hidden in a defined concept progress that isn't expanded.

>>>
>>> comment  fixing it also required eta reduction to be added!
 comment  fixing it also required eta reduction to be added!

>>>
>>>
>>>define step5 A: Alli progress2

define step5 A: Alli progress2

>> step5: [(.P_1:[(x_2:in Nat) => (---:prop)]),
>>      (A_1:that All([(x_3:in Nat) => ((.P_1(x_3)
>>         Imp .P_1(Suc(x_3))):prop)]))
>>      => (Alli([(x_5:in Nat) => (Imppf([(ev_6:
>>            that (x_5 In S0(.P_1))) => (Ini(.P_1,
>>            Suc(x_5),((x_5 Ine ev_6) Mp (x_5
>>            Alle A_1))):that (Suc(x_5) In Setof(.P_1)))])
>>         :that ((x_5 In S0(.P_1)) Imp (Suc(x_5)
>>         In Setof(.P_1))))])
>>      :that All([(x_8:in Nat) => (((x_8 In S0(.P_1))
>>         Imp (Suc(x_8) In Setof(.P_1))):prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> step5: [(.P_1:[(x_2:in Nat) => (---:prop)]),
>>>>>      (A_1:that All([(x_3:in Nat) => ((.P_1(x_3)
>>>>>         Imp .P_1(Suc(x_3))):prop)]))
>>>>>      => (Alli([(x_5:in Nat) => (Imppf([(ev_6:
>>>>>            that (x_5 In S0(.P_1))) => (Ini(.P_1,
>>>>>            Suc(x_5),((x_5 Ine ev_6) Mp (x_5
>>>>>            Alle A_1))):that (Suc(x_5) In Setof(.P_1)))])
>>>>>         :that ((x_5 In S0(.P_1)) Imp (Suc(x_5)
>>>>>         In Setof(.P_1))))])
>>>>>      :that All([(x_8:in Nat) => (((x_8 In S0(.P_1))
>>>>>         Imp (Suc(x_8) In Setof(.P_1))):prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define Induction Onep A, K : Ax5 (step5 A, \
   T1 P, Onep, K)

define Induction Onep A, K : Ax5 (step5 A, \
   T1 P, Onep, K)

>> Induction: [(.P_1:[(x_2:in Nat) => (---:prop)]),
>>      (Onep_1:that .P_1(1)),(A_1:that All([(x_3:
>>         in Nat) => ((.P_1(x_3) Imp .P_1(Suc(x_3))):
>>         prop)]))
>>      ,(K_1:in Nat) => (Ax5(step5(A_1),T1(.P_1,
>>      Onep_1),K_1):that (K_1 In S0(.P_1)))]
>>   {move 0}


>>>
>>>>> Induction: [(.P_1:[(x_2:in Nat) => (---:prop)]),
>>>>>      (Onep_1:that .P_1(1)),(A_1:that All([(x_3:
>>>>>         in Nat) => ((.P_1(x_3) Imp .P_1(Suc(x_3))):
>>>>>         prop)]))
>>>>>      ,(K_1:in Nat) => (Ax5(step5(A_1),T1(.P_1,
>>>>>      Onep_1),K_1):that (K_1 In S0(.P_1)))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent
clearcurrent

>>>
>>> comment  * K := EB ; NAT
 comment  * K := EB ; NAT

>>>
>>>
>>>declare K in Nat

declare K in Nat

>> K: in Nat {move 1}


>>>
>>>>> K: in Nat {move 1}
>>>
>>>
>>> comment  K * L := EB ; NAT
 comment  K * L := EB ; NAT

>>>
>>>
>>>declare L in Nat

declare L in Nat

>> L: in Nat {move 1}


>>>
>>>>> L: in Nat {move 1}
>>>
>>>
>>> comment  L * LE := [S,SET][T,PROGRESSIVE(S)]IMP(IN(K,S),IN(L,S)) ; PROP
 comment  L * LE := [S,SET][T,PROGRESSIVE(S)]IMP(IN(K,S),IN(L,S)) ; PROP

>>>
>>> comment  comment  This definition has significant preliminaries:
 comment  comment  This definition has significant preliminaries:
>>> comment  comment  we introduce Progressive defined in world 0,
 comment  comment  we introduce Progressive defined in world 0,
>>> comment  comment  which we avoided in formulating the axioms.
 comment  comment  which we avoided in formulating the axioms.
>>> comment  I suspect we will need it.
 comment  I suspect we will need it.

>>>
>>>
>>>declare S in Set

declare S in Set

>> S: in Set {move 1}


>>>
>>>>> S: in Set {move 1}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare K1 in Nat

   declare K1 in Nat

>>    K1: in Nat {move 2}


>>>
>>>>>    K1: in Nat {move 2}
>>>
>>>
>>>
>>>   define progressive1 K1 : (K1 In S) Imp \
      Suc K1 In S

   define progressive1 K1 : (K1 In S) Imp \
      Suc K1 In S

>>    progressive1: [(K1_1:in Nat) => (---:prop)]
>>      {move 1}


>>>
>>>>>    progressive1: [(K1_1:in Nat) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Progressive S : All progressive1

define Progressive S : All progressive1

>> Progressive: [(S_1:in Set) => (All([(K1_2:
>>         in Nat) => (((K1_2 In S_1) Imp (Suc(K1_2)
>>         In S_1)):prop)])
>>      :prop)]
>>   {move 0}


>>>
>>>>> Progressive: [(S_1:in Set) => (All([(K1_2:
>>>>>         in Nat) => (((K1_2 In S_1) Imp (Suc(K1_2)
>>>>>         In S_1)):prop)])
>>>>>      :prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare S1 in Set

   declare S1 in Set

>>    S1: in Set {move 2}


>>>
>>>>>    S1: in Set {move 2}
>>>
>>>
>>>
>>>   define leprop S1 : (Progressive S1) Imp \
      (K In S1) Imp L In S1

   define leprop S1 : (Progressive S1) Imp \
      (K In S1) Imp L In S1

>>    leprop: [(S1_1:in Set) => (---:prop)]
>>      {move 1}


>>>
>>>>>    leprop: [(S1_1:in Set) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>> comment  comment  I have to define the universal quantifier for sets.
 comment  comment  I have to define the universal quantifier for sets.
>>> comment  Automath gets it for free from the evil subtyping.
 comment  Automath gets it for free from the evil subtyping.

>>>
>>>
>>>open

open
>>>
>>>   declare S1 in Set

   declare S1 in Set

>>    S1: in Set {move 2}


>>>
>>>>>    S1: in Set {move 2}
>>>
>>>
>>>
>>>   postulate P S1 prop

   postulate P S1 prop

>>    P: [(S1_1:in Set) => (---:prop)]
>>      {move 1}


>>>
>>>>>    P: [(S1_1:in Set) => (---:prop)]
>>>>>      {move 1}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>save P

save P
>>>
>>>postulate Alls P: prop

postulate Alls P: prop

>> Alls: [(P_1:[(S1_2:in Set) => (---:prop)])
>>      => (---:prop)]
>>   {move 0}


>>>
>>>>> Alls: [(P_1:[(S1_2:in Set) => (---:prop)])
>>>>>      => (---:prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>declare xx in Set

declare xx in Set

>> xx: in Set {move 1:P}


>>>
>>>>> xx: in Set {move 1:P}
>>>
>>>
>>>
>>>declare ev that Alls P

declare ev that Alls P

>> ev: that Alls(P) {move 1:P}


>>>
>>>>> ev: that Alls(P) {move 1:P}
>>>
>>>
>>>
>>>postulate Allse xx ev :that P xx

postulate Allse xx ev :that P xx

>> Allse: [(xx_1:in Set),(.P_1:[(S1_2:in Set)
>>         => (---:prop)]),
>>      (ev_1:that Alls(.P_1)) => (---:that .P_1(xx_1))]
>>   {move 0}


>>>
>>>>> Allse: [(xx_1:in Set),(.P_1:[(S1_2:in Set)
>>>>>         => (---:prop)]),
>>>>>      (ev_1:that Alls(.P_1)) => (---:that .P_1(xx_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent P
clearcurrent P

>>>
>>>
>>>open

open
>>>
>>>   declare x in Set

   declare x in Set

>>    x: in Set {move 2}


>>>
>>>>>    x: in Set {move 2}
>>>
>>>
>>>
>>>   postulate univev x: that P x

   postulate univev x: that P x

>>    univev: [(x_1:in Set) => (---:that P(x_1))]
>>      {move 1:P}


>>>
>>>>>    univev: [(x_1:in Set) => (---:that P(x_1))]
>>>>>      {move 1:P}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>postulate Allsi univev : that Alls P

postulate Allsi univev : that Alls P

>> Allsi: [(.P_1:[(S1_2:in Set) => (---:prop)]),
>>      (univev_1:[(x_3:in Set) => (---:that .P_1(x_3))])
>>      => (---:that Alls(.P_1))]
>>   {move 0}


>>>
>>>>> Allsi: [(.P_1:[(S1_2:in Set) => (---:prop)]),
>>>>>      (univev_1:[(x_3:in Set) => (---:that .P_1(x_3))])
>>>>>      => (---:that Alls(.P_1))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define Le K L : Alls leprop

define Le K L : Alls leprop

>> Le: [(K_1:in Nat),(L_1:in Nat) => (Alls([(S1_2:
>>         in Set) => ((Progressive(S1_2) Imp
>>         ((K_1 In S1_2) Imp (L_1 In S1_2))):
>>         prop)])
>>      :prop)]
>>   {move 0}


>>>
>>>>> Le: [(K_1:in Nat),(L_1:in Nat) => (Alls([(S1_2:
>>>>>         in Set) => ((Progressive(S1_2) Imp
>>>>>         ((K_1 In S1_2) Imp (L_1 In S1_2))):
>>>>>         prop)])
>>>>>      :prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>open

open
>>>
>>>   declare T that Le K L

   declare T that Le K L

>>    T: that (K Le L) {move 2}


>>>
>>>>>    T: that (K Le L) {move 2}
>>>
>>>
>>>
>>>   define Tid T:T

   define Tid T:T

>>    Tid: [(T_1:that (K Le L)) => (---:that
>>         (K Le L))]
>>      {move 1:P}


>>>
>>>>>    Tid: [(T_1:that (K Le L)) => (---:that
>>>>>         (K Le L))]
>>>>>      {move 1:P}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Lefix K L : Imppffull(Alls leprop, \
   Le K L, Tid)

define Lefix K L : Imppffull(Alls leprop, \
   Le K L, Tid)

>> Lefix: [(K_1:in Nat),(L_1:in Nat) => (Imppffull(Alls([(S1_2:
>>         in Set) => ((Progressive(S1_2) Imp
>>         ((K_1 In S1_2) Imp (L_1 In S1_2))):
>>         prop)]),
>>      (K_1 Le L_1),[(T_3:that (K_1 Le L_1))
>>         => (T_3:that (K_1 Le L_1))])
>>      :that (Alls([(S1_4:in Set) => ((Progressive(S1_4)
>>         Imp ((K_1 In S1_4) Imp (L_1 In S1_4))):
>>         prop)])
>>      Imp (K_1 Le L_1)))]
>>   {move 0}


>>>
>>>>> Lefix: [(K_1:in Nat),(L_1:in Nat) => (Imppffull(Alls([(S1_2:
>>>>>         in Set) => ((Progressive(S1_2) Imp
>>>>>         ((K_1 In S1_2) Imp (L_1 In S1_2))):
>>>>>         prop)]),
>>>>>      (K_1 Le L_1),[(T_3:that (K_1 Le L_1))
>>>>>         => (T_3:that (K_1 Le L_1))])
>>>>>      :that (Alls([(S1_4:in Set) => ((Progressive(S1_4)
>>>>>         Imp ((K_1 In S1_4) Imp (L_1 In S1_4))):
>>>>>         prop)])
>>>>>      Imp (K_1 Le L_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  K * REFLLE := [S,SET]{T,PROGRESSIVE(S)][U,IN(K,S)]U ; LE(K,K)
 comment  K * REFLLE := [S,SET]{T,PROGRESSIVE(S)][U,IN(K,S)]U ; LE(K,K)

>>>
>>>
>>>open

open
>>>
>>>   declare S1 in Set

   declare S1 in Set

>>    S1: in Set {move 2}


>>>
>>>>>    S1: in Set {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare T that Progressive S1

      declare T that Progressive S1

>>       T: that Progressive(S1) {move 3}


>>>
>>>>>       T: that Progressive(S1) {move 3}
>>>
>>>
>>>
>>>      open

      open
>>>
>>>         declare U that K In S1

         declare U that K In S1

>>          U: that (K In S1) {move 4}


>>>
>>>>>          U: that (K In S1) {move 4}
>>>
>>>
>>>
>>>         define uid U: U

         define uid U: U

>>          uid: [(U_1:that (K In S1)) => (---:
>>               that (K In S1))]
>>            {move 3}


>>>
>>>>>          uid: [(U_1:that (K In S1)) => (---:
>>>>>               that (K In S1))]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         close

         close
>>>
>>>      define step1 T : Imppf (uid)

      define step1 T : Imppf (uid)

>>       step1: [(T_1:that Progressive(S1))
>>            => (---:that ((K In S1) Imp (K In
>>            S1)))]
>>         {move 2}


>>>
>>>>>       step1: [(T_1:that Progressive(S1))
>>>>>            => (---:that ((K In S1) Imp (K In
>>>>>            S1)))]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define step2 S1 : Imppf (step1)

   define step2 S1 : Imppf (step1)

>>    step2: [(S1_1:in Set) => (---:that (Progressive(S1_1)
>>         Imp ((K In S1_1) Imp (K In S1_1))))]
>>      {move 1:P}


>>>
>>>>>    step2: [(S1_1:in Set) => (---:that (Progressive(S1_1)
>>>>>         Imp ((K In S1_1) Imp (K In S1_1))))]
>>>>>      {move 1:P}
>>>
>>>
>>>      comment      define prop1 S1 :  (Progressive S1) Imp (K In S1) Imp K In S1
      comment      define prop1 S1 :  (Progressive S1) Imp (K In S1) Imp K In S1

>>>
>>>
>>>   close

   close
>>>
>>>define step3 K : Allsi step2

define step3 K : Allsi step2

>> step3: [(K_1:in Nat) => (Allsi([(S1_3:in
>>         Set) => (Imppf([(T_4:that Progressive(S1_3))
>>            => (Imppf([(U_5:that (K_1 In S1_3))
>>               => (U_5:that (K_1 In S1_3))])
>>            :that ((K_1 In S1_3) Imp (K_1 In
>>            S1_3)))])
>>         :that (Progressive(S1_3) Imp ((K_1
>>         In S1_3) Imp (K_1 In S1_3))))])
>>      :that Alls([(S1_6:in Set) => ((Progressive(S1_6)
>>         Imp ((K_1 In S1_6) Imp (K_1 In S1_6))):
>>         prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> step3: [(K_1:in Nat) => (Allsi([(S1_3:in
>>>>>         Set) => (Imppf([(T_4:that Progressive(S1_3))
>>>>>            => (Imppf([(U_5:that (K_1 In S1_3))
>>>>>               => (U_5:that (K_1 In S1_3))])
>>>>>            :that ((K_1 In S1_3) Imp (K_1 In
>>>>>            S1_3)))])
>>>>>         :that (Progressive(S1_3) Imp ((K_1
>>>>>         In S1_3) Imp (K_1 In S1_3))))])
>>>>>      :that Alls([(S1_6:in Set) => ((Progressive(S1_6)
>>>>>         Imp ((K_1 In S1_6) Imp (K_1 In S1_6))):
>>>>>         prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define Reflle K : Mp (step3 K, Lefix K K)

define Reflle K : Mp (step3 K, Lefix K K)


>> Reflle: [(K_1:in Nat) => ((step3(K_1) Mp
>>      (K_1 Lefix K_1)):that (K_1 Le K_1))]
>>   {move 0}


>>>
>>>
>>>>> Reflle: [(K_1:in Nat) => ((step3(K_1) Mp
>>>>>      (K_1 Lefix K_1)):that (K_1 Le K_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent L
clearcurrent L

>>>
>>> comment  L * M := EB ; NAT
 comment  L * M := EB ; NAT

>>>
>>>
>>>declare M in Nat

declare M in Nat

>> M: in Nat {move 1:L}


>>>
>>>>> M: in Nat {move 1:L}
>>>
>>>
>>> comment  M * L1 := EB ; LE(K,L)
 comment  M * L1 := EB ; LE(K,L)

>>>
>>>
>>>declare L1 that K Le L

declare L1 that K Le L

>> L1: that (K Le L) {move 1:L}


>>>
>>>>> L1: that (K Le L) {move 1:L}
>>>
>>>
>>> comment  L1 * L2 := EB ; LE(L,M)
 comment  L1 * L2 := EB ; LE(L,M)

>>>
>>>
>>>declare L2 that L Le M

declare L2 that L Le M

>> L2: that (L Le M) {move 1:L}


>>>
>>>>> L2: that (L Le M) {move 1:L}
>>>
>>>
>>> comment  +*0
 comment  +*0

>>>
>>> comment  L2 * S := EB ; SET
 comment  L2 * S := EB ; SET

>>>
>>>
>>>open

open
>>>
>>>   declare S in Set

   declare S in Set

>>    S: in Set {move 2}


>>>
>>>>>    S: in Set {move 2}
>>>
>>>
>>>      comment  S * P := EB ;PROGRESSIVE(S)
      comment  S * P := EB ;PROGRESSIVE(S)

>>>
>>>
>>>   open

   open
>>>
>>>      declare P that Progressive S

      declare P that Progressive S

>>       P: that Progressive(S) {move 3}


>>>
>>>>>       P: that Progressive(S) {move 3}
>>>
>>>
>>>           comment  P * I := EB ; IN(K,S)
           comment  P * I := EB ; IN(K,S)

>>>
>>>
>>>      open

      open
>>>
>>>         declare I that K In S

         declare I that K In S

>>          I: that (K In S) {move 4}


>>>
>>>>>          I: that (K In S) {move 4}
>>>
>>>
>>>                comment  I * T3 := <I><P><S>L1 ; IN(L,S)
                comment  I * T3 := <I><P><S>L1 ; IN(L,S)

>>>
>>>
>>>         open

         open
>>>
>>>            declare S1 in Set

            declare S1 in Set

>>             S1: in Set {move 5}


>>>
>>>>>             S1: in Set {move 5}
>>>
>>>
>>>                     comment                     define steptarget1 S1: Progressive S1 Imp (K In S1) Imp L In S1
                     comment                     define steptarget1 S1: Progressive S1 Imp (K In S1) Imp L In S1

>>>
>>>
>>>            close

            close
>>>
>>>         define step1 : Allse S L1

         define step1 : Allse S L1

>>          step1: [(---:that (Progressive(S)
>>               Imp ((K In S) Imp (L In S))))]
>>            {move 3}


>>>
>>>>>          step1: [(---:that (Progressive(S)
>>>>>               Imp ((K In S) Imp (L In S))))]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         define step2 : Mp (P,step1)

         define step2 : Mp (P,step1)

>>          step2: [(---:that ((K In S) Imp
>>               (L In S)))]
>>            {move 3}


>>>
>>>>>          step2: [(---:that ((K In S) Imp
>>>>>               (L In S)))]
>>>>>            {move 3}
>>>
>>>
>>>                comment  it is a bad thing that there is something called step3; cleanup needed
                comment  it is a bad thing that there is something called step3; cleanup needed

>>>
>>>
>>>         define stepa3 I: Mp (I,step2)

         define stepa3 I: Mp (I,step2)

>>          stepa3: [(I_1:that (K In S)) =>
>>               (---:that (L In S))]
>>            {move 3}


>>>
>>>>>          stepa3: [(I_1:that (K In S)) =>
>>>>>               (---:that (L In S))]
>>>>>            {move 3}
>>>
>>>
>>>                comment  I * T4 := <T3><P><S>L2 ; IN(M,S)
                comment  I * T4 := <T3><P><S>L2 ; IN(M,S)

>>>
>>>
>>>         open

         open
>>>
>>>            declare S1 in Set

            declare S1 in Set

>>             S1: in Set {move 5}


>>>
>>>>>             S1: in Set {move 5}
>>>
>>>
>>>                     comment                    define steptarget2 S1: Progressive S1 Imp (L In S1) Imp M In S1
                     comment                    define steptarget2 S1: Progressive S1 Imp (L In S1) Imp M In S1

>>>
>>>
>>>            close

            close
>>>
>>>         define stepa4: Allse S L2

         define stepa4: Allse S L2

>>          stepa4: [(---:that (Progressive(S)
>>               Imp ((L In S) Imp (M In S))))]
>>            {move 3}


>>>
>>>>>          stepa4: [(---:that (Progressive(S)
>>>>>               Imp ((L In S) Imp (M In S))))]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         define stepa5: Mp (P,stepa4)

         define stepa5: Mp (P,stepa4)

>>          stepa5: [(---:that ((L In S) Imp
>>               (M In S)))]
>>            {move 3}


>>>
>>>>>          stepa5: [(---:that ((L In S) Imp
>>>>>               (M In S)))]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         define stepa6 I: Mp (stepa3 I,stepa5)

         define stepa6 I: Mp (stepa3 I,stepa5)


>>          stepa6: [(I_1:that (K In S)) =>
>>               (---:that (M In S))]
>>            {move 3}


>>>
>>>
>>>>>          stepa6: [(I_1:that (K In S)) =>
>>>>>               (---:that (M In S))]
>>>>>            {move 3}
>>>
>>>
>>>
>>>         close

         close
>>>
>>>      define stepa7 P: Imppf (stepa6)

      define stepa7 P: Imppf (stepa6)

>>       stepa7: [(P_1:that Progressive(S))
>>            => (---:that ((K In S) Imp (M In
>>            S)))]
>>         {move 2}


>>>
>>>>>       stepa7: [(P_1:that Progressive(S))
>>>>>            => (---:that ((K In S) Imp (M In
>>>>>            S)))]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define stepa8 S: Imppf (stepa7)

   define stepa8 S: Imppf (stepa7)

>>    stepa8: [(S_1:in Set) => (---:that (Progressive(S_1)
>>         Imp ((K In S_1) Imp (M In S_1))))]
>>      {move 1:L}


>>>
>>>>>    stepa8: [(S_1:in Set) => (---:that (Progressive(S_1)
>>>>>         Imp ((K In S_1) Imp (M In S_1))))]
>>>>>      {move 1:L}
>>>
>>>
>>>      comment      define stepatarget9 S: (Progressive S) Imp (K In S) Imp M In S
      comment      define stepatarget9 S: (Progressive S) Imp (K In S) Imp M In S

>>>
>>>
>>>   close

   close
>>>
>>>define stepa9 L1 L2 : Allsi stepa8

define stepa9 L1 L2 : Allsi stepa8

>> stepa9: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:
>>      that (.K_1 Le .L_1)),(.M_1:in Nat),(L2_1:
>>      that (.L_1 Le .M_1)) => (Allsi([(S_3:in
>>         Set) => (Imppf([(P_4:that Progressive(S_3))
>>            => (Imppf([(I_5:that (.K_1 In S_3))
>>               => (((I_5 Mp (P_4 Mp (S_3 Allse
>>               L1_1))) Mp (P_4 Mp (S_3 Allse
>>               L2_1))):that (.M_1 In S_3))])
>>            :that ((.K_1 In S_3) Imp (.M_1 In
>>            S_3)))])
>>         :that (Progressive(S_3) Imp ((.K_1
>>         In S_3) Imp (.M_1 In S_3))))])
>>      :that Alls([(S_8:in Set) => ((Progressive(S_8)
>>         Imp ((.K_1 In S_8) Imp (.M_1 In S_8))):
>>         prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> stepa9: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:
>>>>>      that (.K_1 Le .L_1)),(.M_1:in Nat),(L2_1:
>>>>>      that (.L_1 Le .M_1)) => (Allsi([(S_3:in
>>>>>         Set) => (Imppf([(P_4:that Progressive(S_3))
>>>>>            => (Imppf([(I_5:that (.K_1 In S_3))
>>>>>               => (((I_5 Mp (P_4 Mp (S_3 Allse
>>>>>               L1_1))) Mp (P_4 Mp (S_3 Allse
>>>>>               L2_1))):that (.M_1 In S_3))])
>>>>>            :that ((.K_1 In S_3) Imp (.M_1 In
>>>>>            S_3)))])
>>>>>         :that (Progressive(S_3) Imp ((.K_1
>>>>>         In S_3) Imp (.M_1 In S_3))))])
>>>>>      :that Alls([(S_8:in Set) => ((Progressive(S_8)
>>>>>         Imp ((.K_1 In S_8) Imp (.M_1 In S_8))):
>>>>>         prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>> comment  -0
 comment  -0

>>>
>>> comment  L2 * TRLE := [S,SET][T,PROGRESSIVE(S)][U,IN(K,S)]T4"-0"(S,T,U) ; LE(K,M)
 comment  L2 * TRLE := [S,SET][T,PROGRESSIVE(S)][U,IN(K,S)]T4"-0"(S,T,U) ; LE(K,M)

>>>
>>>
>>>define Trle L1 L2: Mp (stepa9 L1 L2,Lefix \
   K M)

define Trle L1 L2: Mp (stepa9 L1 L2,Lefix \
   K M)

>> Trle: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:
>>      that (.K_1 Le .L_1)),(.M_1:in Nat),(L2_1:
>>      that (.L_1 Le .M_1)) => (((L1_1 stepa9
>>      L2_1) Mp (.K_1 Lefix .M_1)):that (.K_1
>>      Le .M_1))]
>>   {move 0}


>>>
>>>>> Trle: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:
>>>>>      that (.K_1 Le .L_1)),(.M_1:in Nat),(L2_1:
>>>>>      that (.L_1 Le .M_1)) => (((L1_1 stepa9
>>>>>      L2_1) Mp (.K_1 Lefix .M_1)):that (.K_1
>>>>>      Le .M_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  K * TH1 := [S,SET][T,PROGRESSIVE(S)]<K>T ; LE(K,SUC(K))
 comment  K * TH1 := [S,SET][T,PROGRESSIVE(S)]<K>T ; LE(K,SUC(K))

>>>
>>>
>>>open

open
>>>
>>>   declare S1 in Set

   declare S1 in Set

>>    S1: in Set {move 2}


>>>
>>>>>    S1: in Set {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare P1 that Progressive(S1)

      declare P1 that Progressive(S1)

>>       P1: that Progressive(S1) {move 3}


>>>
>>>>>       P1: that Progressive(S1) {move 3}
>>>
>>>
>>>
>>>      define pageline181 P1 : Alle(K,P1)

      define pageline181 P1 : Alle(K,P1)


>>       pageline181: [(P1_1:that Progressive(S1))
>>            => (---:that ((K In S1) Imp (Suc(K)
>>            In S1)))]
>>         {move 2}


>>>
>>>
>>>>>       pageline181: [(P1_1:that Progressive(S1))
>>>>>            => (---:that ((K In S1) Imp (Suc(K)
>>>>>            In S1)))]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define pageline182 S1 : Imppf pageline181

   define pageline182 S1 : Imppf pageline181


>>    pageline182: [(S1_1:in Set) => (---:that
>>         (Progressive(S1_1) Imp ((K In S1_1)
>>         Imp (Suc(K) In S1_1))))]
>>      {move 1:L}


>>>
>>>
>>>>>    pageline182: [(S1_1:in Set) => (---:that
>>>>>         (Progressive(S1_1) Imp ((K In S1_1)
>>>>>         Imp (Suc(K) In S1_1))))]
>>>>>      {move 1:L}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Lethm1 K : Fixfun (K Le Suc K,Allsi \
   pageline182)

define Lethm1 K : Fixfun (K Le Suc K,Allsi \
   pageline182)

>> Lethm1: [(K_1:in Nat) => (((K_1 Le Suc(K_1))
>>      Fixfun Allsi([(S1_3:in Set) => (Imppf([(P1_4:
>>            that Progressive(S1_3)) => ((K_1
>>            Alle P1_4):that ((K_1 In S1_3) Imp
>>            (Suc(K_1) In S1_3)))])
>>         :that (Progressive(S1_3) Imp ((K_1
>>         In S1_3) Imp (Suc(K_1) In S1_3))))]))
>>      :that (K_1 Le Suc(K_1)))]
>>   {move 0}


>>>
>>>>> Lethm1: [(K_1:in Nat) => (((K_1 Le Suc(K_1))
>>>>>      Fixfun Allsi([(S1_3:in Set) => (Imppf([(P1_4:
>>>>>            that Progressive(S1_3)) => ((K_1
>>>>>            Alle P1_4):that ((K_1 In S1_3) Imp
>>>>>            (Suc(K_1) In S1_3)))])
>>>>>         :that (Progressive(S1_3) Imp ((K_1
>>>>>         In S1_3) Imp (Suc(K_1) In S1_3))))]))
>>>>>      :that (K_1 Le Suc(K_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  L * L1 := EB ; LE(K,L)
 comment  L * L1 := EB ; LE(K,L)

>>>
>>> comment  L1 * COR1 := TRLE(K,L,SUC(L),TH1(L))
 comment  L1 * COR1 := TRLE(K,L,SUC(L),TH1(L))

>>>
>>>
>>>define Lecor1 L1 : Trle L1 Lethm1 L

define Lecor1 L1 : Trle L1 Lethm1 L

>> Lecor1: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:
>>      that (.K_1 Le .L_1)) => ((L1_1 Trle Lethm1(.L_1)):
>>      that (.K_1 Le Suc(.L_1)))]
>>   {move 0}


>>>
>>>>> Lecor1: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:
>>>>>      that (.K_1 Le .L_1)) => ((L1_1 Trle Lethm1(.L_1)):
>>>>>      that (.K_1 Le Suc(.L_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  starting p. 19
 comment  starting p. 19

>>>
>>>clearcurrent L
clearcurrent L

>>>
>>> comment  L * L1 := EB ;  LE(SUC(K),SUC(L))
 comment  L * L1 := EB ;  LE(SUC(K),SUC(L))

>>>
>>>
>>>declare L1 that (Suc K) Le Suc L

declare L1 that (Suc K) Le Suc L

>> L1: that (Suc(K) Le Suc(L)) {move 1:L}


>>>
>>>>> L1: that (Suc(K) Le Suc(L)) {move 1:L}
>>>
>>>
>>> comment  +2
 comment  +2

>>>
>>> comment  L1 * S := EB ; SET
 comment  L1 * S := EB ; SET

>>>
>>>
>>>declare S in Set

declare S in Set

>> S: in Set {move 1:L}


>>>
>>>>> S: in Set {move 1:L}
>>>
>>>
>>> comment  S * P := EB ; PROGRESSIVE(S)
 comment  S * P := EB ; PROGRESSIVE(S)

>>>
>>>
>>>declare P that Progressive S

declare P that Progressive S

>> P: that Progressive(S) {move 1:L}


>>>
>>>>> P: that Progressive(S) {move 1:L}
>>>
>>>
>>>
>>>save P

save P
>>> comment  P * M := EB ; NAT
 comment  P * M := EB ; NAT

>>>
>>>
>>>declare M in Nat

declare M in Nat

>> M: in Nat {move 1:P}


>>>
>>>>> M: in Nat {move 1:P}
>>>
>>>
>>> comment  M * N := EB ; NAT
 comment  M * N := EB ; NAT

>>>
>>>
>>>declare N in Nat

declare N in Nat

>> N: in Nat {move 1:P}


>>>
>>>>> N: in Nat {move 1:P}
>>>
>>>
>>> comment  comment  There are clear signs here that I need to encapsulate
 comment  comment  There are clear signs here that I need to encapsulate
>>> comment  some earlier material for namespace control.
 comment  some earlier material for namespace control.

>>>
>>> comment  N * PROP1 := AND(IN(N,S),IS(SUC(N),M)) ; PROP
 comment  N * PROP1 := AND(IN(N,S),IS(SUC(N),M)) ; PROP

>>>
>>>
>>>define Propa1 S M N : (N In S) And ((Suc \
   N) Is M)

define Propa1 S M N : (N In S) And ((Suc \
   N) Is M)

>> Propa1: [(S_1:in Set),(M_1:in Nat),(N_1:in
>>      Nat) => (((N_1 In S_1) And (Suc(N_1) Is
>>      M_1)):prop)]
>>   {move 0}


>>>
>>>>> Propa1: [(S_1:in Set),(M_1:in Nat),(N_1:in
>>>>>      Nat) => (((N_1 In S_1) And (Suc(N_1) Is
>>>>>      M_1)):prop)]
>>>>>   {move 0}
>>>
>>>
>>> comment  P * S0 := SETOF([X,NAT]SOME([Y,NAT]PROP1(X,Y))) ; SET
 comment  P * S0 := SETOF([X,NAT]SOME([Y,NAT]PROP1(X,Y))) ; SET

>>>
>>>
>>>open

open
>>>
>>>   declare x0 in Nat

   declare x0 in Nat

>>    x0: in Nat {move 2}


>>>
>>>>>    x0: in Nat {move 2}
>>>
>>>
>>>
>>>   open

   open
>>>
>>>      declare y0 in Nat

      declare y0 in Nat

>>       y0: in Nat {move 3}


>>>
>>>>>       y0: in Nat {move 3}
>>>
>>>
>>>
>>>      define propa1 y0 : Propa1 S x0 y0

      define propa1 y0 : Propa1 S x0 y0

>>       propa1: [(y0_1:in Nat) => (---:prop)]
>>         {move 2}


>>>
>>>>>       propa1: [(y0_1:in Nat) => (---:prop)]
>>>>>         {move 2}
>>>
>>>
>>>
>>>      close

      close
>>>
>>>   define sa0 x0: Some propa1

   define sa0 x0: Some propa1

>>    sa0: [(x0_1:in Nat) => (---:prop)]
>>      {move 1:P}


>>>
>>>>>    sa0: [(x0_1:in Nat) => (---:prop)]
>>>>>      {move 1:P}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Sa0 S :Setof sa0

define Sa0 S :Setof sa0

>> Sa0: [(S_1:in Set) => (Setof([(x0_2:in Nat)
>>         => (Some([(y0_3:in Nat) => (Propa1(S_1,
>>            x0_2,y0_3):prop)])
>>         :prop)])
>>      :in Set)]
>>   {move 0}


>>>
>>>>> Sa0: [(S_1:in Set) => (Setof([(x0_2:in Nat)
>>>>>         => (Some([(y0_3:in Nat) => (Propa1(S_1,
>>>>>            x0_2,y0_3):prop)])
>>>>>         :prop)])
>>>>>      :in Set)]
>>>>>   {move 0}
>>>
>>>
>>> comment  P * M := EB ; NAT
 comment  P * M := EB ; NAT

>>>
>>> comment declare M in Nat
 comment declare M in Nat

>>>
>>> comment  M * I := EB ; IN(M,S0)
 comment  M * I := EB ; IN(M,S0)

>>>
>>>
>>>declare I that M In Sa0 S

declare I that M In Sa0 S

>> I: that (M In Sa0(S)) {move 1:P}


>>>
>>>>> I: that (M In Sa0(S)) {move 1:P}
>>>
>>>
>>>
>>>save I

save I
>>> comment  I * T1 :=  INE([X,NAT]SOME([Y,NAT]PROP1(X,Y)),M,I) ;  SOME([X,NAT]PROP1(M,X))
 comment  I * T1 :=  INE([X,NAT]SOME([Y,NAT]PROP1(X,Y)),M,I) ;  SOME([X,NAT]PROP1(M,X))

>>>
>>>
>>>define Ta1 S M I : Ine M I

define Ta1 S M I : Ine M I

>> Ta1: [(S_1:in Set),(M_1:in Nat),(I_1:that
>>      (M_1 In Sa0(S_1))) => ((M_1 Ine I_1):that
>>      Some([(y0_4:in Nat) => (Propa1(S_1,M_1,
>>         y0_4):prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> Ta1: [(S_1:in Set),(M_1:in Nat),(I_1:that
>>>>>      (M_1 In Sa0(S_1))) => ((M_1 Ine I_1):that
>>>>>      Some([(y0_4:in Nat) => (Propa1(S_1,M_1,
>>>>>         y0_4):prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * N := EB ; NAT
 comment  I * N := EB ; NAT

>>>
>>> comment declare N in Nat
 comment declare N in Nat

>>>
>>> comment  N * Q := EB ; PROP1(M,N)
 comment  N * Q := EB ; PROP1(M,N)

>>>
>>>
>>>declare Q that Propa1(S,M,N)

declare Q that Propa1(S,M,N)

>> Q: that Propa1(S,M,N) {move 1:I}


>>>
>>>>> Q: that Propa1(S,M,N) {move 1:I}
>>>
>>>
>>> comment  Q * T2 := <Ande1(IN(N,S),IS(SUC(N),M),Q)><N>P ; IN(SUC(N),S)
 comment  Q * T2 := <Ande1(IN(N,S),IS(SUC(N),M),Q)><N>P ; IN(SUC(N),S)

>>>
>>>
>>>define T2 S P M N Q : Mp(Ande1 Q, Alle N \
   P)

define T2 S P M N Q : Mp(Ande1 Q, Alle N \
   P)

>> T2: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>      (M_1:in Nat),(N_1:in Nat),(Q_1:that Propa1(S_1,
>>      M_1,N_1)) => ((Ande1(Q_1) Mp (N_1 Alle
>>      P_1)):that (Suc(N_1) In S_1))]
>>   {move 0}


>>>
>>>>> T2: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>>>>      (M_1:in Nat),(N_1:in Nat),(Q_1:that Propa1(S_1,
>>>>>      M_1,N_1)) => ((Ande1(Q_1) Mp (N_1 Alle
>>>>>      P_1)):that (Suc(N_1) In S_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  Q * T3 := AX2(SUC(N),M,ANDE2(IN(N,S),IS(SUC(N),M),Q) ; IS(SUS(SUC(N)),SUC(M))
 comment  Q * T3 := AX2(SUC(N),M,ANDE2(IN(N,S),IS(SUC(N),M),Q) ; IS(SUS(SUC(N)),SUC(M))

>>>
>>>
>>>define T3 S P M N Q : Ax2(Suc N,M,Ande2 Q)

define T3 S P M N Q : Ax2(Suc N,M,Ande2 Q)


>> T3: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>      (M_1:in Nat),(N_1:in Nat),(Q_1:that Propa1(S_1,
>>      M_1,N_1)) => (Ax2(Suc(N_1),M_1,Ande2(Q_1)):
>>      that (Suc(Suc(N_1)) Is Suc(M_1)))]
>>   {move 0}


>>>
>>>
>>>>> T3: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>>>>      (M_1:in Nat),(N_1:in Nat),(Q_1:that Propa1(S_1,
>>>>>      M_1,N_1)) => (Ax2(Suc(N_1),M_1,Ande2(Q_1)):
>>>>>      that (Suc(Suc(N_1)) Is Suc(M_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  Q * T4 := ANDI(IN(SUC(N),S),IS(SUS(SUC(N)),SUC(M)),T2,T3) ; PROP1(SUC(M),SUC(N))
 comment  Q * T4 := ANDI(IN(SUC(N),S),IS(SUS(SUC(N)),SUC(M)),T2,T3) ; PROP1(SUC(M),SUC(N))

>>>
>>>
>>>define T4 S P M N Q : Fixfun (Propa1(S,Suc \
   M, Suc N),Andi(T2 S P M N Q,T3 S P M N Q))

define T4 S P M N Q : Fixfun (Propa1(S,Suc \
   M, Suc N),Andi(T2 S P M N Q,T3 S P M N Q))


>> T4: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>      (M_1:in Nat),(N_1:in Nat),(Q_1:that Propa1(S_1,
>>      M_1,N_1)) => ((Propa1(S_1,Suc(M_1),Suc(N_1))
>>      Fixfun (T2(S_1,P_1,M_1,N_1,Q_1) Andi T3(S_1,
>>      P_1,M_1,N_1,Q_1))):that Propa1(S_1,Suc(M_1),
>>      Suc(N_1)))]
>>   {move 0}


>>>
>>>
>>>>> T4: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>>>>      (M_1:in Nat),(N_1:in Nat),(Q_1:that Propa1(S_1,
>>>>>      M_1,N_1)) => ((Propa1(S_1,Suc(M_1),Suc(N_1))
>>>>>      Fixfun (T2(S_1,P_1,M_1,N_1,Q_1) Andi T3(S_1,
>>>>>      P_1,M_1,N_1,Q_1))):that Propa1(S_1,Suc(M_1),
>>>>>      Suc(N_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  Q * T5 := SOMEI([X,NAT]PROP1(SUC(M),X),SUC(N),T4) ; SOME([X,NAT]PROP1(SUC(M),X))
 comment  Q * T5 := SOMEI([X,NAT]PROP1(SUC(M),X),SUC(N),T4) ; SOME([X,NAT]PROP1(SUC(M),X))

>>>
>>> comment  note use of truncated applicative term here to represent a function.
 comment  note use of truncated applicative term here to represent a function.

>>>
>>>
>>>define T5 S P M N Q : Fixfun (Some (Propa1(S, \
   Suc M)),Somei (Propa1(S,Suc(M)), Suc(N), \
   T4 S P M N Q))

define T5 S P M N Q : Fixfun (Some (Propa1(S, \
   Suc M)),Somei (Propa1(S,Suc(M)), Suc(N), \
   T4 S P M N Q))

>> T5: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>      (M_1:in Nat),(N_1:in Nat),(Q_1:that Propa1(S_1,
>>      M_1,N_1)) => ((Some([(N_2:in Nat) => (Propa1(S_1,
>>         Suc(M_1),N_2):prop)])
>>      Fixfun Somei([(N_3:in Nat) => (Propa1(S_1,
>>         Suc(M_1),N_3):prop)]
>>      ,Suc(N_1),T4(S_1,P_1,M_1,N_1,Q_1))):that
>>      Some([(N_4:in Nat) => (Propa1(S_1,Suc(M_1),
>>         N_4):prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> T5: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>>>>      (M_1:in Nat),(N_1:in Nat),(Q_1:that Propa1(S_1,
>>>>>      M_1,N_1)) => ((Some([(N_2:in Nat) => (Propa1(S_1,
>>>>>         Suc(M_1),N_2):prop)])
>>>>>      Fixfun Somei([(N_3:in Nat) => (Propa1(S_1,
>>>>>         Suc(M_1),N_3):prop)]
>>>>>      ,Suc(N_1),T4(S_1,P_1,M_1,N_1,Q_1))):that
>>>>>      Some([(N_4:in Nat) => (Propa1(S_1,Suc(M_1),
>>>>>         N_4):prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * T6 := SOMEE([X,NAT]PROP1(M,X),SOME([X,NAT]PROP1(SUC(M),X),T1,[X,NAT][T,PROP1(M,X)]T5(X,T));  SOME([X,NAT]PROP1(SUC(M),X))
 comment  I * T6 := SOMEE([X,NAT]PROP1(M,X),SOME([X,NAT]PROP1(SUC(M),X),T1,[X,NAT][T,PROP1(M,X)]T5(X,T));  SOME([X,NAT]PROP1(SUC(M),X))

>>>
>>>
>>>define T6 S P, M I : Somee (Ta1 S M I,T5(S, \
   P, M))

define T6 S P, M I : Somee (Ta1 S M I,T5(S, \
   P, M))

>> T6: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>      (M_1:in Nat),(I_1:that (M_1 In Sa0(S_1)))
>>      => ((Ta1(S_1,M_1,I_1) Somee [(N_4:in Nat),
>>         (Q_4:that Propa1(S_1,M_1,N_4)) => (T5(S_1,
>>         P_1,M_1,N_4,Q_4):that Some([(N_5:in
>>            Nat) => (Propa1(S_1,Suc(M_1),N_5):
>>            prop)]))
>>         ])
>>      :that Some([(N_6:in Nat) => (Propa1(S_1,
>>         Suc(M_1),N_6):prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> T6: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>>>>      (M_1:in Nat),(I_1:that (M_1 In Sa0(S_1)))
>>>>>      => ((Ta1(S_1,M_1,I_1) Somee [(N_4:in Nat),
>>>>>         (Q_4:that Propa1(S_1,M_1,N_4)) => (T5(S_1,
>>>>>         P_1,M_1,N_4,Q_4):that Some([(N_5:in
>>>>>            Nat) => (Propa1(S_1,Suc(M_1),N_5):
>>>>>            prop)]))
>>>>>         ])
>>>>>      :that Some([(N_6:in Nat) => (Propa1(S_1,
>>>>>         Suc(M_1),N_6):prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * T7 := INI([X,NAT]SOME[Y,NAT]PROP1(X,Y),SUC(M),T6) ; IN(SUC(M),S0)
 comment  I * T7 := INI([X,NAT]SOME[Y,NAT]PROP1(X,Y),SUC(M),T6) ; IN(SUC(M),S0)

>>>
>>>
>>>open

open
>>>
>>>   declare M1 in Nat

   declare M1 in Nat

>>    M1: in Nat {move 2}


>>>
>>>>>    M1: in Nat {move 2}
>>>
>>>
>>>
>>>   define t7 M1 : Some (Propa1 (S,M1))

   define t7 M1 : Some (Propa1 (S,M1))

>>    t7: [(M1_1:in Nat) => (---:prop)]
>>      {move 1:I}


>>>
>>>>>    t7: [(M1_1:in Nat) => (---:prop)]
>>>>>      {move 1:I}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define T7 S P, M I : Fixfun(Suc M In Sa0(S), \
   Ini(t7,Suc M,T6 S P, M I))

define T7 S P, M I : Fixfun(Suc M In Sa0(S), \
   Ini(t7,Suc M,T6 S P, M I))

>> T7: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>      (M_1:in Nat),(I_1:that (M_1 In Sa0(S_1)))
>>      => (((Suc(M_1) In Sa0(S_1)) Fixfun Ini([(M1_2:
>>         in Nat) => (Some([(N_3:in Nat) => (Propa1(S_1,
>>            M1_2,N_3):prop)])
>>         :prop)]
>>      ,Suc(M_1),T6(S_1,P_1,M_1,I_1))):that (Suc(M_1)
>>      In Sa0(S_1)))]
>>   {move 0}


>>>
>>>>> T7: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>>>>      (M_1:in Nat),(I_1:that (M_1 In Sa0(S_1)))
>>>>>      => (((Suc(M_1) In Sa0(S_1)) Fixfun Ini([(M1_2:
>>>>>         in Nat) => (Some([(N_3:in Nat) => (Propa1(S_1,
>>>>>            M1_2,N_3):prop)])
>>>>>         :prop)]
>>>>>      ,Suc(M_1),T6(S_1,P_1,M_1,I_1))):that (Suc(M_1)
>>>>>      In Sa0(S_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  starting page 20
 comment  starting page 20

>>>
>>>clearcurrent P
clearcurrent P

>>>
>>> comment  P * I := EB ; IN(K,S)
 comment  P * I := EB ; IN(K,S)

>>>
>>>
>>>declare I that K In S

declare I that K In S

>> I: that (K In S) {move 1:P}


>>>
>>>>> I: that (K In S) {move 1:P}
>>>
>>>
>>>
>>>save I

save I
>>>
>>>declare M in Nat

declare M in Nat

>> M: in Nat {move 1:I}


>>>
>>>>> M: in Nat {move 1:I}
>>>
>>>
>>> comment  I * T8 := ANDI(IN(K,S),IS(SUC(K),SUC,K),I,REFLEQ(SUC(K))) ; PROP!(SUC(K),K)
 comment  I * T8 := ANDI(IN(K,S),IS(SUC(K),SUC,K),I,REFLEQ(SUC(K))) ; PROP!(SUC(K),K)

>>>
>>>
>>>define T8 K S P, I : Fixfun(S Propa1 Suc \
   K, K ,Andi I Refleq Suc K)

define T8 K S P, I : Fixfun(S Propa1 Suc \
   K, K ,Andi I Refleq Suc K)

>> T8: [(K_1:in Nat),(S_1:in Set),(P_1:that
>>      Progressive(S_1)),(I_1:that (K_1 In S_1))
>>      => ((Propa1(S_1,Suc(K_1),K_1) Fixfun (I_1
>>      Andi Refleq(Suc(K_1)))):that Propa1(S_1,
>>      Suc(K_1),K_1))]
>>   {move 0}


>>>
>>>>> T8: [(K_1:in Nat),(S_1:in Set),(P_1:that
>>>>>      Progressive(S_1)),(I_1:that (K_1 In S_1))
>>>>>      => ((Propa1(S_1,Suc(K_1),K_1) Fixfun (I_1
>>>>>      Andi Refleq(Suc(K_1)))):that Propa1(S_1,
>>>>>      Suc(K_1),K_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * T9 := SOMEI([X,NAT]PROP1(SUC(K),X),K,T8) ; SOME([X,NAT]PROP1(SUC(K),X))
 comment  I * T9 := SOMEI([X,NAT]PROP1(SUC(K),X),K,T8) ; SOME([X,NAT]PROP1(SUC(K),X))

>>>
>>>
>>>define Ta9 K S P, I : Somei (Propa1(S,Suc \
   K),K,T8 K S P, I)

define Ta9 K S P, I : Somei (Propa1(S,Suc \
   K),K,T8 K S P, I)

>> Ta9: [(K_1:in Nat),(S_1:in Set),(P_1:that
>>      Progressive(S_1)),(I_1:that (K_1 In S_1))
>>      => (Somei([(N_2:in Nat) => (Propa1(S_1,
>>         Suc(K_1),N_2):prop)]
>>      ,K_1,T8(K_1,S_1,P_1,I_1)):that Some([(N_3:
>>         in Nat) => (Propa1(S_1,Suc(K_1),N_3):
>>         prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> Ta9: [(K_1:in Nat),(S_1:in Set),(P_1:that
>>>>>      Progressive(S_1)),(I_1:that (K_1 In S_1))
>>>>>      => (Somei([(N_2:in Nat) => (Propa1(S_1,
>>>>>         Suc(K_1),N_2):prop)]
>>>>>      ,K_1,T8(K_1,S_1,P_1,I_1)):that Some([(N_3:
>>>>>         in Nat) => (Propa1(S_1,Suc(K_1),N_3):
>>>>>         prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * T10 :=  INI([X,NAT]SOME([Y,NAT]PROP1(X,Y)),SUC(K),T9) ; IN(SUC(K),S0)
 comment  I * T10 :=  INI([X,NAT]SOME([Y,NAT]PROP1(X,Y)),SUC(K),T9) ; IN(SUC(K),S0)

>>>
>>>
>>>open

open
>>>
>>>   declare M1 in Nat

   declare M1 in Nat

>>    M1: in Nat {move 2}


>>>
>>>>>    M1: in Nat {move 2}
>>>
>>>
>>>
>>>   define t7 M1 : Some (Propa1 (S,M1))

   define t7 M1 : Some (Propa1 (S,M1))

>>    t7: [(M1_1:in Nat) => (---:prop)]
>>      {move 1:I}


>>>
>>>>>    t7: [(M1_1:in Nat) => (---:prop)]
>>>>>      {move 1:I}
>>>
>>>
>>>
>>>   close

   close
>>>
>>>define Ta10 K S P, I : Fixfun((Suc K) In \
   Sa0 S, Ini(t7, Suc K, Ta9 K S P, I))

define Ta10 K S P, I : Fixfun((Suc K) In \
   Sa0 S, Ini(t7, Suc K, Ta9 K S P, I))

>> Ta10: [(K_1:in Nat),(S_1:in Set),(P_1:that
>>      Progressive(S_1)),(I_1:that (K_1 In S_1))
>>      => (((Suc(K_1) In Sa0(S_1)) Fixfun Ini([(M1_2:
>>         in Nat) => (Some([(N_3:in Nat) => (Propa1(S_1,
>>            M1_2,N_3):prop)])
>>         :prop)]
>>      ,Suc(K_1),Ta9(K_1,S_1,P_1,I_1))):that
>>      (Suc(K_1) In Sa0(S_1)))]
>>   {move 0}


>>>
>>>>> Ta10: [(K_1:in Nat),(S_1:in Set),(P_1:that
>>>>>      Progressive(S_1)),(I_1:that (K_1 In S_1))
>>>>>      => (((Suc(K_1) In Sa0(S_1)) Fixfun Ini([(M1_2:
>>>>>         in Nat) => (Some([(N_3:in Nat) => (Propa1(S_1,
>>>>>            M1_2,N_3):prop)])
>>>>>         :prop)]
>>>>>      ,Suc(K_1),Ta9(K_1,S_1,P_1,I_1))):that
>>>>>      (Suc(K_1) In Sa0(S_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * T11 := <T10>[X,NAT][T,IN(X,S0)]T7(X,T)><S0>L1
 comment  I * T11 := <T10>[X,NAT][T,IN(X,S0)]T7(X,T)><S0>L1

>>>
>>>
>>>define pageline201 L1 S : Allse (Sa0 S,L1)

define pageline201 L1 S : Allse (Sa0 S,L1)


>> pageline201: [(.K_1:in Nat),(.L_1:in Nat),
>>      (L1_1:that (Suc(.K_1) Le Suc(.L_1))),(S_1:
>>      in Set) => ((Sa0(S_1) Allse L1_1):that
>>      (Progressive(Sa0(S_1)) Imp ((Suc(.K_1)
>>      In Sa0(S_1)) Imp (Suc(.L_1) In Sa0(S_1)))))]
>>   {move 0}


>>>
>>>
>>>>> pageline201: [(.K_1:in Nat),(.L_1:in Nat),
>>>>>      (L1_1:that (Suc(.K_1) Le Suc(.L_1))),(S_1:
>>>>>      in Set) => ((Sa0(S_1) Allse L1_1):that
>>>>>      (Progressive(Sa0(S_1)) Imp ((Suc(.K_1)
>>>>>      In Sa0(S_1)) Imp (Suc(.L_1) In Sa0(S_1)))))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define pageline202 S P M: Imppf (T7 (S, P, \
   M))

define pageline202 S P M: Imppf (T7 (S, P, \
   M))

>> pageline202: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>      (M_1:in Nat) => (Imppf([(I_2:that (M_1
>>         In Sa0(S_1))) => (T7(S_1,P_1,M_1,I_2):
>>         that (Suc(M_1) In Sa0(S_1)))])
>>      :that ((M_1 In Sa0(S_1)) Imp (Suc(M_1)
>>      In Sa0(S_1))))]
>>   {move 0}


>>>
>>>>> pageline202: [(S_1:in Set),(P_1:that Progressive(S_1)),
>>>>>      (M_1:in Nat) => (Imppf([(I_2:that (M_1
>>>>>         In Sa0(S_1))) => (T7(S_1,P_1,M_1,I_2):
>>>>>         that (Suc(M_1) In Sa0(S_1)))])
>>>>>      :that ((M_1 In Sa0(S_1)) Imp (Suc(M_1)
>>>>>      In Sa0(S_1))))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define pageline203 S P : Fixfun(Progressive(Sa0 \
   S),Alli(pageline202(S,P)))

define pageline203 S P : Fixfun(Progressive(Sa0 \
   S),Alli(pageline202(S,P)))

>> pageline203: [(S_1:in Set),(P_1:that Progressive(S_1))
>>      => ((Progressive(Sa0(S_1)) Fixfun Alli([(M_3:
>>         in Nat) => (pageline202(S_1,P_1,M_3):
>>         that ((M_3 In Sa0(S_1)) Imp (Suc(M_3)
>>         In Sa0(S_1))))]))
>>      :that Progressive(Sa0(S_1)))]
>>   {move 0}


>>>
>>>>> pageline203: [(S_1:in Set),(P_1:that Progressive(S_1))
>>>>>      => ((Progressive(Sa0(S_1)) Fixfun Alli([(M_3:
>>>>>         in Nat) => (pageline202(S_1,P_1,M_3):
>>>>>         that ((M_3 In Sa0(S_1)) Imp (Suc(M_3)
>>>>>         In Sa0(S_1))))]))
>>>>>      :that Progressive(Sa0(S_1)))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define pageline204 L1 S P : Mp(pageline203 \
   S P, pageline201 L1 S)

define pageline204 L1 S P : Mp(pageline203 \
   S P, pageline201 L1 S)

>> pageline204: [(.K_1:in Nat),(.L_1:in Nat),
>>      (L1_1:that (Suc(.K_1) Le Suc(.L_1))),(S_1:
>>      in Set),(P_1:that Progressive(S_1)) =>
>>      (((S_1 pageline203 P_1) Mp (L1_1 pageline201
>>      S_1)):that ((Suc(.K_1) In Sa0(S_1)) Imp
>>      (Suc(.L_1) In Sa0(S_1))))]
>>   {move 0}


>>>
>>>>> pageline204: [(.K_1:in Nat),(.L_1:in Nat),
>>>>>      (L1_1:that (Suc(.K_1) Le Suc(.L_1))),(S_1:
>>>>>      in Set),(P_1:that Progressive(S_1)) =>
>>>>>      (((S_1 pageline203 P_1) Mp (L1_1 pageline201
>>>>>      S_1)):that ((Suc(.K_1) In Sa0(S_1)) Imp
>>>>>      (Suc(.L_1) In Sa0(S_1))))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define T11 L1 S P I : Mp(Ta10 K S P I,pageline204 \
   L1 S P)

define T11 L1 S P I : Mp(Ta10 K S P I,pageline204 \
   L1 S P)

>> T11: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:that
>>      (Suc(.K_1) Le Suc(.L_1))),(S_1:in Set),
>>      (P_1:that Progressive(S_1)),(I_1:that
>>      (.K_1 In S_1)) => ((Ta10(.K_1,S_1,P_1,
>>      I_1) Mp pageline204(L1_1,S_1,P_1)):that
>>      (Suc(.L_1) In Sa0(S_1)))]
>>   {move 0}


>>>
>>>>> T11: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:that
>>>>>      (Suc(.K_1) Le Suc(.L_1))),(S_1:in Set),
>>>>>      (P_1:that Progressive(S_1)),(I_1:that
>>>>>      (.K_1 In S_1)) => ((Ta10(.K_1,S_1,P_1,
>>>>>      I_1) Mp pageline204(L1_1,S_1,P_1)):that
>>>>>      (Suc(.L_1) In Sa0(S_1)))]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * T12 := T1(SUC(L),T11) ; SOME([X,NAT]PROP1(SUC(L),X))
 comment  I * T12 := T1(SUC(L),T11) ; SOME([X,NAT]PROP1(SUC(L),X))

>>>
>>>
>>>define T12 L1 S P I : Ta1 (S, Suc L, T11 \
   L1 S P I)

define T12 L1 S P I : Ta1 (S, Suc L, T11 \
   L1 S P I)

>> T12: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:that
>>      (Suc(.K_1) Le Suc(.L_1))),(S_1:in Set),
>>      (P_1:that Progressive(S_1)),(I_1:that
>>      (.K_1 In S_1)) => (Ta1(S_1,Suc(.L_1),T11(L1_1,
>>      S_1,P_1,I_1)):that Some([(y0_2:in Nat)
>>         => (Propa1(S_1,Suc(.L_1),y0_2):prop)]))
>>      ]
>>   {move 0}


>>>
>>>>> T12: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:that
>>>>>      (Suc(.K_1) Le Suc(.L_1))),(S_1:in Set),
>>>>>      (P_1:that Progressive(S_1)),(I_1:that
>>>>>      (.K_1 In S_1)) => (Ta1(S_1,Suc(.L_1),T11(L1_1,
>>>>>      S_1,P_1,I_1)):that Some([(y0_2:in Nat)
>>>>>         => (Propa1(S_1,Suc(.L_1),y0_2):prop)]))
>>>>>      ]
>>>>>   {move 0}
>>>
>>>
>>> comment  I * M := EB ; NAT
 comment  I * M := EB ; NAT

>>>
>>> comment  already declared
 comment  already declared

>>>
>>> comment  M * Q := EB ; PROP1(SUC(L),M)
 comment  M * Q := EB ; PROP1(SUC(L),M)

>>>
>>>
>>>declare Q that Propa1 S (Suc L) M

declare Q that Propa1 S (Suc L) M

>> Q: that Propa1(S,Suc(L),M) {move 1:I}


>>>
>>>>> Q: that Propa1(S,Suc(L),M) {move 1:I}
>>>
>>>
>>> comment  Q * T13 := Ax4(M,L,ANDE2(IN(M,S),IS(SUC(M),SUC(L)),Q); IS(M,L)
 comment  Q * T13 := Ax4(M,L,ANDE2(IN(M,S),IS(SUC(M),SUC(L)),Q); IS(M,L)

>>>
>>>
>>>define T13 Q : Ax4(Ande2 Q)

define T13 Q : Ax4(Ande2 Q)

>> T13: [(.S_1:in Set),(.L_1:in Nat),(.M_1:in
>>      Nat),(Q_1:that Propa1(.S_1,Suc(.L_1),.M_1))
>>      => (Ax4(Ande2(Q_1)):that (.M_1 Is .L_1))]
>>   {move 0}


>>>
>>>>> T13: [(.S_1:in Set),(.L_1:in Nat),(.M_1:in
>>>>>      Nat),(Q_1:that Propa1(.S_1,Suc(.L_1),.M_1))
>>>>>      => (Ax4(Ande2(Q_1)):that (.M_1 Is .L_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  comment  Q * T14 := EQPRED1(M,L,T13,[X,NAT]In(X,S),ANDE1(IN(M,S),IS(SUC(M),SUC(L)),Q);
 comment  comment  Q * T14 := EQPRED1(M,L,T13,[X,NAT]In(X,S),ANDE1(IN(M,S),IS(SUC(M),SUC(L)),Q);
>>> comment        IN(L,S)
 comment        IN(L,S)

>>>
>>>
>>>define Inconv S M : M In S

define Inconv S M : M In S

>> Inconv: [(S_1:in Set),(M_1:in Nat) => ((M_1
>>      In S_1):prop)]
>>   {move 0}


>>>
>>>>> Inconv: [(S_1:in Set),(M_1:in Nat) => ((M_1
>>>>>      In S_1):prop)]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define T14 L1 S M Q : Fixfun(L In S,Eqpred1(T13 \
   Q,Inconv(S),Ande1 Q))

define T14 L1 S M Q : Fixfun(L In S,Eqpred1(T13 \
   Q,Inconv(S),Ande1 Q))

>> T14: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:that
>>      (Suc(.K_1) Le Suc(.L_1))),(S_1:in Set),
>>      (M_1:in Nat),(Q_1:that Propa1(S_1,Suc(.L_1),
>>      M_1)) => (((.L_1 In S_1) Fixfun Eqpred1(T13(Q_1),
>>      [(M_2:in Nat) => ((S_1 Inconv M_2):prop)]
>>      ,Ande1(Q_1))):that (.L_1 In S_1))]
>>   {move 0}


>>>
>>>>> T14: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:that
>>>>>      (Suc(.K_1) Le Suc(.L_1))),(S_1:in Set),
>>>>>      (M_1:in Nat),(Q_1:that Propa1(S_1,Suc(.L_1),
>>>>>      M_1)) => (((.L_1 In S_1) Fixfun Eqpred1(T13(Q_1),
>>>>>      [(M_2:in Nat) => ((S_1 Inconv M_2):prop)]
>>>>>      ,Ande1(Q_1))):that (.L_1 In S_1))]
>>>>>   {move 0}
>>>
>>>
>>>clearcurrent I
clearcurrent I

>>>
>>> comment  I * T15 := SOMEE([X,NAT]PROP1(SUC(L),X),IN(L,S),T12,[X,NAT][T,PROP1(SUC(L),X)]T14(X,T) ; IN(L,S)
 comment  I * T15 := SOMEE([X,NAT]PROP1(SUC(L),X),IN(L,S),T12,[X,NAT][T,PROP1(SUC(L),X)]T14(X,T) ; IN(L,S)

>>>
>>>
>>>define T15 L1 S P I : Somee(T12 L1 S P I, \
   T14(L1,S))

define T15 L1 S P I : Somee(T12 L1 S P I, \
   T14(L1,S))

>> T15: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:that
>>      (Suc(.K_1) Le Suc(.L_1))),(S_1:in Set),
>>      (P_1:that Progressive(S_1)),(I_1:that
>>      (.K_1 In S_1)) => ((T12(L1_1,S_1,P_1,I_1)
>>      Somee [(M_3:in Nat),(Q_3:that Propa1(S_1,
>>         Suc(.L_1),M_3)) => (T14(L1_1,S_1,M_3,
>>         Q_3):that (.L_1 In S_1))])
>>      :that (.L_1 In S_1))]
>>   {move 0}


>>>
>>>>> T15: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:that
>>>>>      (Suc(.K_1) Le Suc(.L_1))),(S_1:in Set),
>>>>>      (P_1:that Progressive(S_1)),(I_1:that
>>>>>      (.K_1 In S_1)) => ((T12(L1_1,S_1,P_1,I_1)
>>>>>      Somee [(M_3:in Nat),(Q_3:that Propa1(S_1,
>>>>>         Suc(.L_1),M_3)) => (T14(L1_1,S_1,M_3,
>>>>>         Q_3):that (.L_1 In S_1))])
>>>>>      :that (.L_1 In S_1))]
>>>>>   {move 0}
>>>
>>>
>>> comment  -2
 comment  -2

>>>
>>> comment  L1 * TH2 := [S,SET][T,PROGRESSIVE(S)[U,IN(K,S)]T15"-2"(S,T,U) ; LE(K,L)
 comment  L1 * TH2 := [S,SET][T,PROGRESSIVE(S)[U,IN(K,S)]T15"-2"(S,T,U) ; LE(K,L)

>>>
>>>
>>>define pageline206 L1 S P : Imppf (T15(L1, \
   S,P))

define pageline206 L1 S P : Imppf (T15(L1, \
   S,P))

>> pageline206: [(.K_1:in Nat),(.L_1:in Nat),
>>      (L1_1:that (Suc(.K_1) Le Suc(.L_1))),(S_1:
>>      in Set),(P_1:that Progressive(S_1)) =>
>>      (Imppf([(I_2:that (.K_1 In S_1)) => (T15(L1_1,
>>         S_1,P_1,I_2):that (.L_1 In S_1))])
>>      :that ((.K_1 In S_1) Imp (.L_1 In S_1)))]
>>   {move 0}


>>>
>>>>> pageline206: [(.K_1:in Nat),(.L_1:in Nat),
>>>>>      (L1_1:that (Suc(.K_1) Le Suc(.L_1))),(S_1:
>>>>>      in Set),(P_1:that Progressive(S_1)) =>
>>>>>      (Imppf([(I_2:that (.K_1 In S_1)) => (T15(L1_1,
>>>>>         S_1,P_1,I_2):that (.L_1 In S_1))])
>>>>>      :that ((.K_1 In S_1) Imp (.L_1 In S_1)))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define pageline207 L1 S : Imppf (pageline206(L1, \
   S))

define pageline207 L1 S : Imppf (pageline206(L1, \
   S))

>> pageline207: [(.K_1:in Nat),(.L_1:in Nat),
>>      (L1_1:that (Suc(.K_1) Le Suc(.L_1))),(S_1:
>>      in Set) => (Imppf([(P_2:that Progressive(S_1))
>>         => (pageline206(L1_1,S_1,P_2):that
>>         ((.K_1 In S_1) Imp (.L_1 In S_1)))])
>>      :that (Progressive(S_1) Imp ((.K_1 In
>>      S_1) Imp (.L_1 In S_1))))]
>>   {move 0}


>>>
>>>>> pageline207: [(.K_1:in Nat),(.L_1:in Nat),
>>>>>      (L1_1:that (Suc(.K_1) Le Suc(.L_1))),(S_1:
>>>>>      in Set) => (Imppf([(P_2:that Progressive(S_1))
>>>>>         => (pageline206(L1_1,S_1,P_2):that
>>>>>         ((.K_1 In S_1) Imp (.L_1 In S_1)))])
>>>>>      :that (Progressive(S_1) Imp ((.K_1 In
>>>>>      S_1) Imp (.L_1 In S_1))))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>define Tha2 L1 : Fixfun(K Le L,Allsi(pageline207(L1)))

define Tha2 L1 : Fixfun(K Le L,Allsi(pageline207(L1)))


>> Tha2: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:
>>      that (Suc(.K_1) Le Suc(.L_1))) => (((.K_1
>>      Le .L_1) Fixfun Allsi([(S_3:in Set) =>
>>         ((L1_1 pageline207 S_3):that (Progressive(S_3)
>>         Imp ((.K_1 In S_3) Imp (.L_1 In S_3))))]))
>>      :that (.K_1 Le .L_1))]
>>   {move 0}


>>>
>>>
>>>>> Tha2: [(.K_1:in Nat),(.L_1:in Nat),(L1_1:
>>>>>      that (Suc(.K_1) Le Suc(.L_1))) => (((.K_1
>>>>>      Le .L_1) Fixfun Allsi([(S_3:in Set) =>
>>>>>         ((L1_1 pageline207 S_3):that (Progressive(S_3)
>>>>>         Imp ((.K_1 In S_3) Imp (.L_1 In S_3))))]))
>>>>>      :that (.K_1 Le .L_1))]
>>>>>   {move 0}
>>>
>>>
>>>
>>>>> Inspector Lestrade says:  Done reading scratch to autoi37:
>>>>>  type lines or type quit to exit interface
>>>
end Lestrade execution
\end{verbatim}

\end{document}

(* quit *)
quit