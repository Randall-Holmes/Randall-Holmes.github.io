


This is the historical preamble of the original
file of which this is a translation.

>> Inspector Lestrade says:  
>> Welcome to the Lestrade Type Inspector,
>>  
>> User entered lambda terms (arguments)
>> and function sorts (in >>>  declare)!
>> literate programming with LaTeX comments in ML source
>> version of  7/24/2019
>>  12:30 pm Boise time

begin Lestrade execution

   >>> versiondate

Welcome to the Lestrade Type Inspector
version 2.0, release of 4/5/2020
1:30  pm Boise time.


   {move 1}

   >>> comment Lestrade book under development \
       in summer 216 .


   {move 1}

   >>> declare p prop


   p : prop


   {move 1}

   >>> declare q prop


   q : prop


   {move 1}

   >>> declare pp that p


   pp : that p


   {move 1}

   >>> declare qq that q


   qq : that q


   {move 1}

   >>> comment >>> declare the conjunction \
       operator


   {move 1}

   >>> postulate & p q : prop


   &: [(p_1 : prop), (q_1 : prop) => 
       (--- : prop)]


   {move 0}

   >>> comment The rule of conjunction


   {move 1}

   >>> postulate Andproof p q pp qq : that \
       p & q


   Andproof : [(p_1 : prop), (q_1 : prop), (pp_1 
       : that p_1), (qq_1 : that q_1) => 
       (--- : that p_1 & q_1)]


   {move 0}

   >>> declare rr that p & q


   rr : that p & q


   {move 1}

   >>> comment The rules of simplification


   {move 1}

   >>> postulate And1 p q rr : that p


   And1 : [(p_1 : prop), (q_1 : prop), (rr_1 
       : that p_1 & q_1) => (--- : that 
       p_1)]


   {move 0}

   >>> postulate And2 p q rr : that q


   And2 : [(p_1 : prop), (q_1 : prop), (rr_1 
       : that p_1 & q_1) => (--- : that 
       q_1)]


   {move 0}

   >>> comment The implication operator


   {move 1}

   >>> postulate -> p q : prop


   ->: [(p_1 : prop), (q_1 : prop) => 
       (--- : prop)]


   {move 0}

   >>> comment Development of conditional \
       proof


   {move 1}

   >>> open


      {move 2}

      >>> declare pp2 that p


      pp2 : that p


      {move 2}

      >>> comment >>> comment Ded below does \
          not need p or q in its argument list


      {move 2}

      >>> comment >>> comment because they \
          are not locally variables .


      {move 2}

      >>> postulate Ded pp2 : that q


      Ded : [(pp2_1 : that p) => (--- 
          : that q)]


      {move 1}

      >>> close


   {move 1}

   >>> comment >>> comment Note that once \
       the world in which Ded was >>> postulateed \
       >>> closes,


   {move 1}

   >>> comment it is a variable of desirable \
       function type


   {move 1}

   >>> postulate Ifproof p q Ded : that p -> \
       q


   Ifproof : [(p_1 : prop), (q_1 : prop), (Ded_1 
       : [(pp2_2 : that p_1) => (--- : that 
          q_1)]) => (--- : that p_1 -> 
       q_1)]


   {move 0}

   >>> comment Now, for fun, we will >>> \
       construct an actual proof


   {move 1}

   >>> open


      {move 2}

      >>> declare pp2 that p


      pp2 : that p


      {move 2}

      >>> define Ppid pp2 : pp2


      Ppid : [(pp2_1 : that p) => (--- 
          : that p)]


      {move 1}

      >>> close


   {move 1}

   >>> define Selfimp p : Ifproof p p Ppid


   Selfimp : [(p_1 : prop) => 
       ({def} Ifproof (p_1, p_1, [(pp2_2 
          : that p_1) => 
          ({def} pp2_2 : that p_1)]) : that 
       p_1 -> p_1)]


   Selfimp : [(p_1 : prop) => (--- : that 
       p_1 -> p_1)]


   {move 0}

   >>> comment >>> comment Notice in the \
       sort of Selfimp that Ppid has


   {move 1}

   >>> comment been expanded as a lambda \
       - term .


   {move 1}

   >>> comment Develop the rule of modus \
       ponens


   {move 1}

   >>> declare ss that p -> q


   ss : that p -> q


   {move 1}

   >>> postulate Mp p q pp ss : that q


   Mp : [(p_1 : prop), (q_1 : prop), (pp_1 
       : that p_1), (ss_1 : that p_1 -> 
       q_1) => (--- : that q_1)]


   {move 0}

   >>> comment >>> opening an environment \
       to set up definition of a predicate variable \
       P


   {move 1}

   >>> open


      {move 2}

      >>> declare xx obj


      xx : obj


      {move 2}

      >>> postulate P xx : prop


      P : [(xx_1 : obj) => (--- : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> comment Declaring the universal quantifier


   {move 1}

   >>> postulate Forall P : prop


   Forall : [(P_1 : [(xx_2 : obj) => 
          (--- : prop)]) => (--- : prop)]


   {move 0}

   >>> comment Declaring the rule U I of \
       universal instantiation


   {move 1}

   >>> declare P2 that Forall P


   P2 : that Forall (P)


   {move 1}

   >>> declare x obj


   x : obj


   {move 1}

   >>> postulate Ui P, P2 x : that P x


   Ui : [(P_1 : [(xx_2 : obj) => (--- 
          : prop)]), (P2_1 : that Forall 
       (P_1)), (x_1 : obj) => (--- 
       : that P_1 (x_1))]


   {move 0}

   >>> comment >>> comment Note in the previous \
       line that we follow P


   {move 1}

   >>> comment >>> comment with a comma : an \
       abstraction argument may need to be


   {move 1}

   >>> comment guarded with commas so it \
       will not be read as applied .


   {move 1}

   >>> comment >>> comment >>> opening an \
       environment to >>> declare a function


   {move 1}

   >>> comment that witnesses provability \
       of a universal statement


   {move 1}

   >>> open


      {move 2}

      >>> declare u obj


      u : obj


      {move 2}

      >>> postulate Q2 u : that P u


      Q2 : [(u_1 : obj) => (--- : that 
          P (u_1))]


      {move 1}

      >>> close


   {move 1}

   >>> comment The rule of universal generalization


   {move 1}

   >>> postulate Ug P, Q2 : that Forall \
       P


   Ug : [(P_1 : [(xx_2 : obj) => (--- 
          : prop)]), (Q2_1 : [(u_2 
          : obj) => (--- : that P_1 (u_2))]) => 
       (--- : that Forall (P_1))]


   {move 0}

   >>> comment Develop rules for negation \
       (which will be classical !) and prove \
       the contrapositive theorem .


   {move 1}

   >>> comment The absurd proposition .


   {move 1}

   >>> postulate ?? prop


   ??: prop


   {move 0}

   >>> comment The negation operation .


   {move 1}

   >>> define ~ p : p -> ??


   ~: [(p_1 : prop) => 
       ({def} p_1 -> ?? : prop)]


   ~: [(p_1 : prop) => (--- : prop)]


   {move 0}

   >>> comment We make our logic classical \
       : the rule of double negation


   {move 1}

   >>> declare maybe that ~ ~ p


   maybe : that ~ (~ (p))


   {move 1}

   >>> postulate Dneg p maybe : that p


   Dneg : [(p_1 : prop), (maybe_1 : that 
       ~ (~ (p_1))) => (--- : that p_1)]


   {move 0}

   >>> comment Contradictions are absurd \
       .


   {move 1}

   >>> declare nn that ~ p


   nn : that ~ (p)


   {move 1}

   >>> define Contra p pp nn : Mp p ?? pp \
       nn


   Contra : [(p_1 : prop), (pp_1 : that 
       p_1), (nn_1 : that ~ (p_1)) => 
       ({def} Mp (p_1, ??, pp_1, nn_1) : that 
       ??)]


   Contra : [(p_1 : prop), (pp_1 : that 
       p_1), (nn_1 : that ~ (p_1)) => 
       (--- : that ??)]


   {move 0}

   >>> comment >>> comment Notice that Lestrade \
       does expand the definition


   {move 1}

   >>> comment of the negation operation \
       as we expect .


   {move 1}

   >>> open


      {move 2}

      >>> declare pp2 that p


      pp2 : that p


      {move 2}

      >>> postulate Negded pp2 : that ??


      Negded : [(pp2_1 : that p) => (--- 
          : that ??)]


      {move 1}

      >>> close


   {move 1}

   >>> define Negintro1 p Negded : Ifproof \
       p ?? Negded


   Negintro1 : [(p_1 : prop), (Negded_1 
       : [(pp2_2 : that p_1) => (--- : that 
          ??)]) => 
       ({def} Ifproof (p_1, ??, Negded_1) : that 
       p_1 -> ??)]


   Negintro1 : [(p_1 : prop), (Negded_1 
       : [(pp2_2 : that p_1) => (--- : that 
          ??)]) => (--- : that p_1 -> 
       ??)]


   {move 0}

   >>> comment >>> comment Negation introduction \
       .But it is defective in actually


   {move 1}

   >>> comment reporting an implication type \
       .Let' s see if we can fix this .


   {move 1}

   >>> open


      {move 2}

      >>> declare proof1 that p -> ??


      proof1 : that p -> ??


      {move 2}

      >>> define Negproofid proof1 : proof1


      Negproofid : [(proof1_1 : that p -> 
          ??) => (--- : that p -> ??)]


      {move 1}

      >>> close


   {move 1}

   >>> define Negfix p : Ifproof ((p -> \
       ??), ~ p, Negproofid)


   Negfix : [(p_1 : prop) => 
       ({def} Ifproof (p_1 -> ??, ~ (p_1), [(proof1_2 
          : that p_1 -> ??) => 
          ({def} proof1_2 : that p_1 -> ??)]) : that 
       (p_1 -> ??) -> ~ (p_1))]


   Negfix : [(p_1 : prop) => (--- : that 
       (p_1 -> ??) -> ~ (p_1))]


   {move 0}

   >>> define Negintro p Negded : Mp ((p -> \
       ??), ~ p, Negintro1 p Negded, Negfix \
       p)


   Negintro : [(p_1 : prop), (Negded_1 
       : [(pp2_2 : that p_1) => (--- : that 
          ??)]) => 
       ({def} Mp (p_1 -> ??, ~ (p_1), p_1 
       Negintro1 Negded_1, Negfix (p_1)) : that 
       ~ (p_1))]


   Negintro : [(p_1 : prop), (Negded_1 
       : [(pp2_2 : that p_1) => (--- : that 
          ??)]) => (--- : that ~ (p_1))]


   {move 0}

   >>> comment >>> comment I succeed in defining \
       a proper negation introduction rule


   {move 1}

   >>> comment >>> comment using the >>> \
       defined symbol .This is important because \
       of limitations


   {move 1}

   >>> comment of circumstances under which \
       Lestrade expands definitions .


   {move 1}

   >>> comment We >>> define the biconditional \
       .


   {move 1}

   >>> define <-> p q : (p -> q) & (q -> \
       p)


   <->: [(p_1 : prop), (q_1 : prop) => 
       ({def} (p_1 -> q_1) & q_1 -> p_1 
       : prop)]


   <->: [(p_1 : prop), (q_1 : prop) => 
       (--- : prop)]


   {move 0}

   >>> comment Biconditional elimination \
       rules


   {move 1}

   >>> declare tt that p <-> q


   tt : that p <-> q


   {move 1}

   >>> define Mpb1 p q pp tt : Mp p q pp, And1 \
       ((p -> q), (q -> p), tt)


   Mpb1 : [(p_1 : prop), (q_1 : prop), (pp_1 
       : that p_1), (tt_1 : that p_1 <-> 
       q_1) => 
       ({def} Mp (p_1, q_1, pp_1, And1 
       (p_1 -> q_1, q_1 -> p_1, tt_1)) : that 
       q_1)]


   Mpb1 : [(p_1 : prop), (q_1 : prop), (pp_1 
       : that p_1), (tt_1 : that p_1 <-> 
       q_1) => (--- : that q_1)]


   {move 0}

   >>> define Mpb2 p q qq tt : Mp q p qq, And2 \
       ((p -> q), (q -> p), tt)


   Mpb2 : [(p_1 : prop), (q_1 : prop), (qq_1 
       : that q_1), (tt_1 : that p_1 <-> 
       q_1) => 
       ({def} Mp (q_1, p_1, qq_1, And2 
       (p_1 -> q_1, q_1 -> p_1, tt_1)) : that 
       p_1)]


   Mpb2 : [(p_1 : prop), (q_1 : prop), (qq_1 
       : that q_1), (tt_1 : that p_1 <-> 
       q_1) => (--- : that p_1)]


   {move 0}

   >>> comment In both of the last two commands, there \
       are subtle parser issues .


   {move 1}

   >>> comment >>> comment Before And1, And2, the \
       comma is needed to prevent Andi


   {move 1}

   >>> comment from being read as an infix \
       .


   {move 1}

   >>> comment >>> comment Because we en \
       >>> close the argument (p -> q) in parentheses


   {move 1}

   >>> comment >>> comment we need to en \
       >>> close the entire argument list in \
       parentheses


   {move 1}

   >>> comment >>> comment because a parenthesis \
       after a prefixed abstraction is


   {move 1}

   >>> comment >>> comment always interpreted \
       as enclosing an argument list,


   {move 1}

   >>> comment not a term .


   {move 1}

   >>> comment the classic Reductio ad Absurdum \
       (which is not the same as neg intro !)


   {move 1}

   >>> open


      {move 2}

      >>> declare aa that ~ p


      aa : that ~ (p)


      {move 2}

      >>> postulate reductioarg aa : that \
          ??


      reductioarg : [(aa_1 : that ~ (p)) => 
          (--- : that ??)]


      {move 1}

      >>> close


   {move 1}

   >>> define Reductio p reductioarg : Dneg \
       p (Negintro ~ p reductioarg)


   Reductio : [(p_1 : prop), (reductioarg_1 
       : [(aa_2 : that ~ (p_1)) => (--- 
          : that ??)]) => 
       ({def} p_1 Dneg ~ (p_1) Negintro 
       reductioarg_1 : that p_1)]


   Reductio : [(p_1 : prop), (reductioarg_1 
       : [(aa_2 : that ~ (p_1)) => (--- 
          : that ??)]) => (--- : that 
       p_1)]


   {move 0}

   >>> comment Everything follows from the \
       False !


   {move 1}

   >>> declare huh that ??


   huh : that ??


   {move 1}

   >>> open


      {move 2}

      >>> declare negp that ~ p


      negp : that ~ (p)


      {move 2}

      >>> define panick negp : huh


      panick : [(negp_1 : that ~ (p)) => 
          (--- : that ??)]


      {move 1}

      >>> close


   {move 1}

   >>> define Panic p huh : Reductio p panick


   Panic : [(p_1 : prop), (huh_1 : that 
       ??) => 
       ({def} p_1 Reductio [(negp_2 : that 
          ~ (p_1)) => 
          ({def} huh_1 : that ??)] : that 
       p_1)]


   Panic : [(p_1 : prop), (huh_1 : that 
       ??) => (--- : that p_1)]


   {move 0}

   >>> comment We develop the biconditional \
       introduction rule .


   {move 1}

   >>> comment >>> comment In this environment \
       we >>> postulate reasoning


   {move 1}

   >>> comment leading from p to q and q to \
       p


   {move 1}

   >>> open


      {move 2}

      >>> declare pp2 that p


      pp2 : that p


      {move 2}

      >>> postulate Ded1 pp2 : that q


      Ded1 : [(pp2_1 : that p) => (--- 
          : that q)]


      {move 1}

      >>> declare qq2 that q


      qq2 : that q


      {move 2}

      >>> postulate Ded2 qq2 : that p


      Ded2 : [(qq2_1 : that q) => (--- 
          : that p)]


      {move 1}

      >>> close


   {move 1}

   >>> comment >>> comment Here we prove \
       an initial version,


   {move 1}

   >>> comment defective in having expanded \
       output


   {move 1}

   >>> define Biintro1 p q, Ded1, Ded2 \
       : Andproof ((p -> q), (q -> p), Ifproof \
       p q Ded1, Ifproof q p Ded2)


   Biintro1 : [(p_1 : prop), (q_1 : prop), (Ded1_1 
       : [(pp2_2 : that p_1) => (--- : that 
          q_1)]), (Ded2_1 : [(qq2_2 
          : that q_1) => (--- : that p_1)]) => 
       ({def} Andproof (p_1 -> q_1, q_1 
       -> p_1, Ifproof (p_1, q_1, Ded1_1), Ifproof 
       (q_1, p_1, Ded2_1)) : that (p_1 
       -> q_1) & q_1 -> p_1)]


   Biintro1 : [(p_1 : prop), (q_1 : prop), (Ded1_1 
       : [(pp2_2 : that p_1) => (--- : that 
          q_1)]), (Ded2_1 : [(qq2_2 
          : that q_1) => (--- : that p_1)]) => 
       (--- : that (p_1 -> q_1) & q_1 -> 
       p_1)]


   {move 0}

   >>> open


      {move 2}

      >>> declare bb that p <-> q


      bb : that p <-> q


      {move 2}

      >>> define biid bb : bb


      biid : [(bb_1 : that p <-> q) => 
          (--- : that p <-> q)]


      {move 1}

      >>> close


   {move 1}

   >>> comment We fix the defective version \
       much as we fixed Negintro above


   {move 1}

   >>> define Bifix p q : Ifproof (((p -> \
       q) & (q -> p)), p <-> q, biid)


   Bifix : [(p_1 : prop), (q_1 : prop) => 
       ({def} Ifproof ((p_1 -> q_1) & q_1 
       -> p_1, p_1 <-> q_1, [(bb_2 : that 
          p_1 <-> q_1) => 
          ({def} bb_2 : that p_1 <-> q_1)]) : that 
       ((p_1 -> q_1) & q_1 -> p_1) -> 
       p_1 <-> q_1)]


   Bifix : [(p_1 : prop), (q_1 : prop) => 
       (--- : that ((p_1 -> q_1) & q_1 
       -> p_1) -> p_1 <-> q_1)]


   {move 0}

   >>> define Biintro p q, Ded1, Ded2 : Mp \
       (((p -> q) & (q -> p)), p <-> \
       q, Biintro1 (p, q, Ded1, Ded2), Bifix \
       p q)


   Biintro : [(p_1 : prop), (q_1 : prop), (Ded1_1 
       : [(pp2_2 : that p_1) => (--- : that 
          q_1)]), (Ded2_1 : [(qq2_2 
          : that q_1) => (--- : that p_1)]) => 
       ({def} Mp ((p_1 -> q_1) & q_1 -> 
       p_1, p_1 <-> q_1, Biintro1 (p_1, q_1, Ded1_1, Ded2_1), p_1 
       Bifix q_1) : that p_1 <-> q_1)]


   Biintro : [(p_1 : prop), (q_1 : prop), (Ded1_1 
       : [(pp2_2 : that p_1) => (--- : that 
          q_1)]), (Ded2_1 : [(qq2_2 
          : that q_1) => (--- : that p_1)]) => 
       (--- : that p_1 <-> q_1)]


   {move 0}

   >>> comment >>> comment We prove the contrapositive \
       theorem,


   {move 1}

   >>> comment (p -> q) <-> (~ q <-> ~ p)


   {move 1}

   >>> open


      {move 2}

      >>> declare aa that p -> q


      aa : that p -> q


      {move 2}

      >>> comment >>> comment Our goal is \
          to >>> postulate a proof of ~ q -> \
          ~ p


      {move 2}

      >>> comment >>> comment To do this, we \
          need a function from


      {move 2}

      >>> comment proofs of ~ q to proofs \
          of ~ p


      {move 2}

      >>> open


         {move 3}

         >>> declare bb that ~ q


         bb : that ~ (q)


         {move 3}

         >>> comment >>> comment Now our \
             goal is to prove ~ p .


         {move 3}

         >>> comment >>> comment For this \
             we need a function from


         {move 3}

         >>> comment proofs of p to proofs \
             of ??


         {move 3}

         >>> open


            {move 4}

            >>> declare cc that p


            cc : that p


            {move 4}

            >>> comment prove q by m .p .


            {move 4}

            >>> define dd cc : Mp p q cc \
                aa


            dd : [(cc_1 : that p) => (--- 
                : that q)]


            {move 3}

            >>> comment and we have a contradiction


            {move 4}

            >>> define ee cc : Contra q (dd \
                cc) bb


            ee : [(cc_1 : that p) => (--- 
                : that ??)]


            {move 3}

            >>> close


         {move 3}

         >>> define ff bb : Negintro p ee


         ff : [(bb_1 : that ~ (q)) => 
             (--- : that ~ (p))]


         {move 2}

         >>> close


      {move 2}

      >>> define gg aa : Ifproof ((~ q), (~ p), ff)


      gg : [(aa_1 : that p -> q) => (--- 
          : that ~ (q) -> ~ (p))]


      {move 1}

      >>> comment >>> comment Now we need \
          the function acting in


      {move 2}

      >>> comment the other direction


      {move 2}

      >>> declare hh that ~ q -> ~ p


      hh : that ~ (q) -> ~ (p)


      {move 2}

      >>> comment Our goal is p -> q so we \
          want to assume p


      {move 2}

      >>> open


         {move 3}

         >>> declare ii that p


         ii : that p


         {move 3}

         >>> comment >>> comment Now our \
             goal is q, but we will


         {move 3}

         >>> comment >>> comment actually \
             aim for ~~ q and so


         {move 3}

         >>> comment assume ~ q


         {move 3}

         >>> open


            {move 4}

            >>> declare jj that ~ q


            jj : that ~ (q)


            {move 4}

            >>> comment Now use modus ponens \
                to prove ~ p


            {move 4}

            >>> define kk jj : Mp (~ q, ~ p, jj, hh)


            kk : [(jj_1 : that ~ (q)) => 
                (--- : that ~ (p))]


            {move 3}

            >>> comment Now we have a contradiction


            {move 4}

            >>> define ll jj : Contra p ii \
                kk jj


            ll : [(jj_1 : that ~ (q)) => 
                (--- : that ??)]


            {move 3}

            >>> close


         {move 3}

         >>> define mm ii : Negintro (~ q, ll)


         mm : [(ii_1 : that p) => (--- 
             : that ~ (~ (q)))]


         {move 2}

         >>> define nn2 ii : Dneg q mm ii


         nn2 : [(ii_1 : that p) => (--- 
             : that q)]


         {move 2}

         >>> close


      {move 2}

      >>> define oo hh : Ifproof p q nn2


      oo : [(hh_1 : that ~ (q) -> ~ (p)) => 
          (--- : that p -> q)]


      {move 1}

      >>> close


   {move 1}

   >>> define Contrapositive p q : Biintro \
       ((p -> q), (~ q -> ~ p), gg, oo)


   Contrapositive : [(p_1 : prop), (q_1 
       : prop) => 
       ({def} Biintro (p_1 -> q_1, ~ (q_1) -> 
       ~ (p_1), [(aa_2 : that p_1 -> 
          q_1) => 
          ({def} Ifproof (~ (q_1), ~ (p_1), [(bb_3 
             : that ~ (q_1)) => 
             ({def} p_1 Negintro [(cc_4 
                : that p_1) => 
                ({def} Contra (q_1, Mp 
                (p_1, q_1, cc_4, aa_2), bb_3) : that 
                ??)] : that ~ (p_1))]) : that 
          ~ (q_1) -> ~ (p_1))], [(hh_2 
          : that ~ (q_1) -> ~ (p_1)) => 
          ({def} Ifproof (p_1, q_1, [(ii_3 
             : that p_1) => 
             ({def} q_1 Dneg ~ (q_1) Negintro 
             [(jj_5 : that ~ (q_1)) => 
                ({def} Contra (p_1, ii_3, Mp 
                (~ (q_1), ~ (p_1), jj_5, hh_2)) : that 
                ??)] : that q_1)]) : that 
          p_1 -> q_1)]) : that (p_1 -> 
       q_1) <-> ~ (q_1) -> ~ (p_1))]


   Contrapositive : [(p_1 : prop), (q_1 
       : prop) => (--- : that (p_1 -> q_1) <-> 
       ~ (q_1) -> ~ (p_1))]


   {move 0}

   >>> comment >>> comment Now is a good \
       point to notice that


   {move 1}

   >>> comment Lestrade definitely saves \
       proof objects in detail .


   {move 1}

   >>> comment Develop indirect proof strategies \
       for implication .


   {move 1}

   >>> comment Modus Tollens


   {move 1}

   >>> declare negc that ~ q


   negc : that ~ (q)


   {move 1}

   >>> define Mt p q ss negc : Mp (~ q, ~ p, negc, Mpb1 \
       ((p -> q), (~ q -> ~ p), ss, Contrapositive \
       p q))


   Mt : [(p_1 : prop), (q_1 : prop), (ss_1 
       : that p_1 -> q_1), (negc_1 : that 
       ~ (q_1)) => 
       ({def} Mp (~ (q_1), ~ (p_1), negc_1, Mpb1 
       (p_1 -> q_1, ~ (q_1) -> ~ (p_1), ss_1, p_1 
       Contrapositive q_1)) : that ~ (p_1))]


   Mt : [(p_1 : prop), (q_1 : prop), (ss_1 
       : that p_1 -> q_1), (negc_1 : that 
       ~ (q_1)) => (--- : that ~ (p_1))]


   {move 0}

   >>> comment Rule of contrapositive or \
       indirect proof


   {move 1}

   >>> open


      {move 2}

      >>> declare negq that ~ q


      negq : that ~ (q)


      {move 2}

      >>> postulate indarg negq : that ~ p


      indarg : [(negq_1 : that ~ (q)) => 
          (--- : that ~ (p))]


      {move 1}

      >>> close


   {move 1}

   >>> define Indirect p q indarg : Mpb2 \
       ((p -> q), (~ q -> ~ p), Ifproof \
       (~ q, ~ p, indarg), Contrapositive \
       p q)


   Indirect : [(p_1 : prop), (q_1 : prop), (indarg_1 
       : [(negq_2 : that ~ (q_1)) => 
          (--- : that ~ (p_1))]) => 
       ({def} Mpb2 (p_1 -> q_1, ~ (q_1) -> 
       ~ (p_1), Ifproof (~ (q_1), ~ (p_1), indarg_1), p_1 
       Contrapositive q_1) : that p_1 -> 
       q_1)]


   Indirect : [(p_1 : prop), (q_1 : prop), (indarg_1 
       : [(negq_2 : that ~ (q_1)) => 
          (--- : that ~ (p_1))]) => 
       (--- : that p_1 -> q_1)]


   {move 0}

   >>> comment Now start the development \
       of disjunction .


   {move 1}

   >>> comment disjunction >>> declared


   {move 1}

   >>> postulate v p q : prop


   v : [(p_1 : prop), (q_1 : prop) => 
       (--- : prop)]


   {move 0}

   >>> comment >>> comment basic disjunction \
       introduction rules (addition)


   {move 1}

   >>> postulate Addition1 p q pp : that \
       p v q


   Addition1 : [(p_1 : prop), (q_1 : prop), (pp_1 
       : that p_1) => (--- : that p_1 v q_1)]


   {move 0}

   >>> postulate Addition2 p q qq : that \
       p v q


   Addition2 : [(p_1 : prop), (q_1 : prop), (qq_1 
       : that q_1) => (--- : that p_1 v q_1)]


   {move 0}

   >>> comment >>> comment the basic disjunction \
       elimination rule (proof by cases)


   {move 1}

   >>> declare r prop


   r : prop


   {move 1}

   >>> declare disj that p v q


   disj : that p v q


   {move 1}

   >>> open


      {move 2}

      >>> declare pp2 that p


      pp2 : that p


      {move 2}

      >>> postulate case1 pp2 : that r


      case1 : [(pp2_1 : that p) => (--- 
          : that r)]


      {move 1}

      >>> declare qq2 that q


      qq2 : that q


      {move 2}

      >>> postulate case2 qq2 : that r


      case2 : [(qq2_1 : that q) => (--- 
          : that r)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Cases p q r disj, case1, case2 \
       : that r


   Cases : [(p_1 : prop), (q_1 : prop), (r_1 
       : prop), (disj_1 : that p_1 v q_1), (case1_1 
       : [(pp2_2 : that p_1) => (--- : that 
          r_1)]), (case2_1 : [(qq2_2 
          : that q_1) => (--- : that r_1)]) => 
       (--- : that r_1)]


   {move 0}

   >>> comment >>> comment The rule of proof \
       by cases really is quite complicated !


   {move 1}

   >>> comment >>> comment Prove the basic \
       equivalence theorem which supports mixed \
       rules for disjunction


   {move 1}

   >>> comment The theorem is (p v q) <-> \
       (~ p -> q)


   {move 1}

   >>> open


      {move 2}

      >>> declare aa that p v q


      aa : that p v q


      {move 2}

      >>> comment our goal is to prove ~ p -> \
          q


      {move 2}

      >>> open


         {move 3}

         >>> declare bb that ~ p


         bb : that ~ (p)


         {move 3}

         >>> comment prove this by cases


         {move 3}

         >>> open


            {move 4}

            >>> declare hyp1 that p


            hyp1 : that p


            {move 4}

            >>> declare hyp2 that q


            hyp2 : that q


            {move 4}

            >>> define casea2 hyp2 : hyp2


            casea2 : [(hyp2_1 : that q) => 
                (--- : that q)]


            {move 3}

            >>> open


               {move 5}

               >>> declare cc that ~ q


               cc : that ~ (q)


               {move 5}

               >>> define panic cc : Contra \
                   p hyp1 bb


               panic : [(cc_1 : that ~ (q)) => 
                   (--- : that ??)]


               {move 4}

               >>> close


            {move 4}

            >>> define casea1 hyp1 : Dneg \
                q (Negintro ~ q panic)


            casea1 : [(hyp1_1 : that p) => 
                (--- : that q)]


            {move 3}

            >>> close


         {move 3}

         >>> define gotq bb : Cases p q q aa, casea1, casea2


         gotq : [(bb_1 : that ~ (p)) => 
             (--- : that q)]


         {move 2}

         >>> close


      {move 2}

      >>> define notpimpq aa : Ifproof ~ p q gotq


      notpimpq : [(aa_1 : that p v q) => 
          (--- : that ~ (p) -> q)]


      {move 1}

      >>> declare bb that ~ p -> q


      bb : that ~ (p) -> q


      {move 2}

      >>> open


         {move 3}

         >>> declare cc that ~ (p v q)


         cc : that ~ (p v q)


         {move 3}

         >>> comment >>> comment this is \
             a hypothesis for reduction ad absurdum


         {move 3}

         >>> comment our aim is prove ~ p so \
             we can use the hypothesis bb


         {move 3}

         >>> open


            {move 4}

            >>> declare pp2 that p


            pp2 : that p


            {move 4}

            >>> define dd pp2 : Addition1 \
                p q pp2


            dd : [(pp2_1 : that p) => 
                (--- : that p v q)]


            {move 3}

            >>> define ee pp2 : Contra (p v q, dd \
                pp2, cc)


            ee : [(pp2_1 : that p) => 
                (--- : that ??)]


            {move 3}

            >>> close


         {move 3}

         >>> define ff cc : Negintro p ee


         ff : [(cc_1 : that ~ (p v q)) => 
             (--- : that ~ (p))]


         {move 2}

         >>> define gg2 cc : Mp (~ p, q, ff \
             cc, bb)


         gg2 : [(cc_1 : that ~ (p v q)) => 
             (--- : that q)]


         {move 2}

         >>> define hh cc : Addition2 p q gg2 \
             cc


         hh : [(cc_1 : that ~ (p v q)) => 
             (--- : that p v q)]


         {move 2}

         >>> define ii cc : Contra (p v q, hh \
             cc, cc)


         ii : [(cc_1 : that ~ (p v q)) => 
             (--- : that ??)]


         {move 2}

         >>> close


      {move 2}

      >>> define jj bb : Reductio (p v q, ii)


      jj : [(bb_1 : that ~ (p) -> q) => 
          (--- : that p v q)]


      {move 1}

      >>> close


   {move 1}

   >>> define Orthm p q : Biintro (p v q, ~ p -> \
       q, notpimpq, jj)


   Orthm : [(p_1 : prop), (q_1 : prop) => 
       ({def} Biintro (p_1 v q_1, ~ (p_1) -> 
       q_1, [(aa_2 : that p_1 v q_1) => 
          ({def} Ifproof (~ (p_1), q_1, [(bb_3 
             : that ~ (p_1)) => 
             ({def} Cases (p_1, q_1, q_1, aa_2, [(hyp1_4 
                : that p_1) => 
                ({def} q_1 Dneg ~ (q_1) Negintro 
                [(cc_6 : that ~ (q_1)) => 
                   ({def} Contra (p_1, hyp1_4, bb_3) : that 
                   ??)] : that q_1)], [(hyp2_4 
                : that q_1) => 
                ({def} hyp2_4 : that q_1)]) : that 
             q_1)]) : that ~ (p_1) -> 
          q_1)], [(bb_2 : that ~ (p_1) -> 
          q_1) => 
          ({def} (p_1 v q_1) Reductio [(cc_3 
             : that ~ (p_1 v q_1)) => 
             ({def} Contra (p_1 v q_1, Addition2 
             (p_1, q_1, Mp (~ (p_1), q_1, p_1 
             Negintro [(pp2_7 : that p_1) => 
                ({def} Contra (p_1 v q_1, Addition1 
                (p_1, q_1, pp2_7), cc_3) : that 
                ??)], bb_2)), cc_3) : that 
             ??)] : that p_1 v q_1)]) : that 
       (p_1 v q_1) <-> ~ (p_1) -> q_1)]


   Orthm : [(p_1 : prop), (q_1 : prop) => 
       (--- : that (p_1 v q_1) <-> ~ (p_1) -> 
       q_1)]


   {move 0}

   >>> comment Prove the symmetric version \
       p v q <-> ~ q -> p


   {move 1}

   >>> open


      {move 2}

      >>> declare aa that p v q


      aa : that p v q


      {move 2}

      >>> define bb aa : Mpb1 (p v q, ~ p -> \
          q, aa, Orthm p q)


      bb : [(aa_1 : that p v q) => (--- 
          : that ~ (p) -> q)]


      {move 1}

      >>> define cc aa : Mpb1 (~ p -> q, ~ q -> \
          ~ ~ p, bb aa, Contrapositive ~ p q)


      cc : [(aa_1 : that p v q) => (--- 
          : that ~ (q) -> ~ (~ (p)))]


      {move 1}

      >>> open


         {move 3}

         >>> declare negq that ~ q


         negq : that ~ (q)


         {move 3}

         >>> define dd negq : Mp ~ q ~ ~ p negq \
             cc aa


         dd : [(negq_1 : that ~ (q)) => 
             (--- : that ~ (~ (p)))]


         {move 2}

         >>> define yesp negq : Dneg p dd \
             negq


         yesp : [(negq_1 : that ~ (q)) => 
             (--- : that p)]


         {move 2}

         >>> close


      {move 2}

      >>> define ee aa : Ifproof ~ q p yesp


      ee : [(aa_1 : that p v q) => (--- 
          : that ~ (q) -> p)]


      {move 1}

      >>> declare ff that ~ q -> p


      ff : that ~ (q) -> p


      {move 2}

      >>> comment Prove that ~ p implies \
          q then use Orthm


      {move 2}

      >>> open


         {move 3}

         >>> declare negp that ~ p


         negp : that ~ (p)


         {move 3}

         >>> comment >>> comment prove q by \
             reductio


         {move 3}

         >>> open


            {move 4}

            >>> declare negq that ~ q


            negq : that ~ (q)


            {move 4}

            >>> define pfollows negq : Mp \
                ~ q p negq ff


            pfollows : [(negq_1 : that 
                ~ (q)) => (--- : that 
                p)]


            {move 3}

            >>> define disaster negq : Contra \
                p, pfollows negq negp


            disaster : [(negq_1 : that 
                ~ (q)) => (--- : that 
                ??)]


            {move 3}

            >>> close


         {move 3}

         >>> define kk negp : Reductio q disaster


         kk : [(negp_1 : that ~ (p)) => 
             (--- : that q)]


         {move 2}

         >>> close


      {move 2}

      >>> define ll ff : Ifproof ~ p q kk


      ll : [(ff_1 : that ~ (q) -> p) => 
          (--- : that ~ (p) -> q)]


      {move 1}

      >>> define mm ff : Mpb2 (p v q, ~ p -> \
          q, ll ff, Orthm p q)


      mm : [(ff_1 : that ~ (q) -> p) => 
          (--- : that p v q)]


      {move 1}

      >>> close


   {move 1}

   >>> define Orthm2 p q : Biintro (p v q, ~ q -> \
       p, ee, mm)


   Orthm2 : [(p_1 : prop), (q_1 : prop) => 
       ({def} Biintro (p_1 v q_1, ~ (q_1) -> 
       p_1, [(aa_2 : that p_1 v q_1) => 
          ({def} Ifproof (~ (q_1), p_1, [(negq_3 
             : that ~ (q_1)) => 
             ({def} p_1 Dneg Mp (~ (q_1), ~ (~ (p_1)), negq_3, Mpb1 
             (~ (p_1) -> q_1, ~ (q_1) -> 
             ~ (~ (p_1)), Mpb1 (p_1 
             v q_1, ~ (p_1) -> q_1, aa_2, p_1 
             Orthm q_1), ~ (p_1) Contrapositive 
             q_1)) : that p_1)]) : that 
          ~ (q_1) -> p_1)], [(ff_2 
          : that ~ (q_1) -> p_1) => 
          ({def} Mpb2 (p_1 v q_1, ~ (p_1) -> 
          q_1, Ifproof (~ (p_1), q_1, [(negp_4 
             : that ~ (p_1)) => 
             ({def} q_1 Reductio [(negq_5 
                : that ~ (q_1)) => 
                ({def} Contra (p_1, Mp 
                (~ (q_1), p_1, negq_5, ff_2), negp_4) : that 
                ??)] : that q_1)]), p_1 
          Orthm q_1) : that p_1 v q_1)]) : that 
       (p_1 v q_1) <-> ~ (q_1) -> p_1)]


   Orthm2 : [(p_1 : prop), (q_1 : prop) => 
       (--- : that (p_1 v q_1) <-> ~ (q_1) -> 
       p_1)]


   {move 0}

   >>> comment >>> comment Develop the full \
       dress disjunction introduction rule


   {move 1}

   >>> comment >>> comment reversal of numbering \
       is due to my proving the less favored


   {move 1}

   >>> comment version of Orthm first .


   {move 1}

   >>> open


      {move 2}

      >>> declare negq that ~ q


      negq : that ~ (q)


      {move 2}

      >>> postulate thusp negq : that p


      thusp : [(negq_1 : that ~ (q)) => 
          (--- : that p)]


      {move 1}

      >>> close


   {move 1}

   >>> define Disjintro p q thusp : Mpb2 \
       (p v q, ~ q -> p, Ifproof ~ q p thusp, Orthm2 \
       p q)


   Disjintro : [(p_1 : prop), (q_1 : prop), (thusp_1 
       : [(negq_2 : that ~ (q_1)) => 
          (--- : that p_1)]) => 
       ({def} Mpb2 (p_1 v q_1, ~ (q_1) -> 
       p_1, Ifproof (~ (q_1), p_1, thusp_1), p_1 
       Orthm2 q_1) : that p_1 v q_1)]


   Disjintro : [(p_1 : prop), (q_1 : prop), (thusp_1 
       : [(negq_2 : that ~ (q_1)) => 
          (--- : that p_1)]) => (--- 
       : that p_1 v q_1)]


   {move 0}

   >>> open


      {move 2}

      >>> declare negp that ~ p


      negp : that ~ (p)


      {move 2}

      >>> postulate thusq negp : that q


      thusq : [(negp_1 : that ~ (p)) => 
          (--- : that q)]


      {move 1}

      >>> close


   {move 1}

   >>> define Disjintro2 p q thusq : Mpb2 \
       (p v q, ~ p -> q, Ifproof ~ p q thusq, Orthm \
       p q)


   Disjintro2 : [(p_1 : prop), (q_1 
       : prop), (thusq_1 : [(negp_2 : that 
          ~ (p_1)) => (--- : that q_1)]) => 
       ({def} Mpb2 (p_1 v q_1, ~ (p_1) -> 
       q_1, Ifproof (~ (p_1), q_1, thusq_1), p_1 
       Orthm q_1) : that p_1 v q_1)]


   Disjintro2 : [(p_1 : prop), (q_1 
       : prop), (thusq_1 : [(negp_2 : that 
          ~ (p_1)) => (--- : that q_1)]) => 
       (--- : that p_1 v q_1)]


   {move 0}

   >>> comment Rules of disjunctive syllogism


   {move 1}

   >>> declare line1 that p v q


   line1 : that p v q


   {move 1}

   >>> declare line2 that ~ q


   line2 : that ~ (q)


   {move 1}

   >>> define Ds1 p q line1 line2 : Mp (~ q, p, line2, Mpb1 \
       (p v q, ~ q -> p, line1, Orthm2 p q))


   Ds1 : [(p_1 : prop), (q_1 : prop), (line1_1 
       : that p_1 v q_1), (line2_1 : that 
       ~ (q_1)) => 
       ({def} Mp (~ (q_1), p_1, line2_1, Mpb1 
       (p_1 v q_1, ~ (q_1) -> p_1, line1_1, p_1 
       Orthm2 q_1)) : that p_1)]


   Ds1 : [(p_1 : prop), (q_1 : prop), (line1_1 
       : that p_1 v q_1), (line2_1 : that 
       ~ (q_1)) => (--- : that p_1)]


   {move 0}

   >>> declare line3 that p v q


   line3 : that p v q


   {move 1}

   >>> declare line4 that ~ p


   line4 : that ~ (p)


   {move 1}

   >>> define Ds2 p q line3 line4 : Mp (~ p, q, line4, Mpb1 \
       (p v q, ~ p -> q, line3, Orthm p q))


   Ds2 : [(p_1 : prop), (q_1 : prop), (line3_1 
       : that p_1 v q_1), (line4_1 : that 
       ~ (p_1)) => 
       ({def} Mp (~ (p_1), q_1, line4_1, Mpb1 
       (p_1 v q_1, ~ (p_1) -> q_1, line3_1, p_1 
       Orthm q_1)) : that q_1)]


   Ds2 : [(p_1 : prop), (q_1 : prop), (line3_1 
       : that p_1 v q_1), (line4_1 : that 
       ~ (p_1)) => (--- : that q_1)]


   {move 0}

   >>> comment >>> comment The existential \
       quantifier


   {move 1}

   >>> postulate Exists P : prop


   Exists : [(P_1 : [(xx_2 : obj) => 
          (--- : prop)]) => (--- : prop)]


   {move 0}

   >>> comment the rule E G (existential \
       introduction)


   {move 1}

   >>> declare ev that P x


   ev : that P (x)


   {move 1}

   >>> postulate Eg P, x ev : that Exists \
       P


   Eg : [(P_1 : [(xx_2 : obj) => (--- 
          : prop)]), (x_1 : obj), (ev_1 
       : that P_1 (x_1)) => (--- : that 
       Exists (P_1))]


   {move 0}

   >>> comment >>> comment the rule E I (existential \
       elimination)


   {move 1}

   >>> declare g prop


   g : prop


   {move 1}

   >>> declare ex that Exists P


   ex : that Exists (P)


   {move 1}

   >>> open


      {move 2}

      >>> declare w obj


      w : obj


      {move 2}

      >>> declare ev2 that P w


      ev2 : that P (w)


      {move 2}

      >>> postulate wi w ev2 : that g


      wi : [(w_1 : obj), (ev2_1 : that 
          P (w_1)) => (--- : that g)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Ei P, g, ex, wi : that \
       g


   Ei : [(P_1 : [(xx_2 : obj) => (--- 
          : prop)]), (g_1 : prop), (ex_1 
       : that Exists (P_1)), (wi_1 : [(w_2 
          : obj), (ev2_2 : that P_1 (w_2)) => 
          (--- : that g_1)]) => (--- 
       : that g_1)]


   {move 0}

   >>> comment A quantifier proof


   {move 1}

   >>> open


      {move 2}

      >>> declare xx obj


      xx : obj


      {move 2}

      >>> postulate Pp xx : prop


      Pp : [(xx_1 : obj) => (--- : prop)]


      {move 1}

      >>> postulate Qq xx : prop


      Qq : [(xx_1 : obj) => (--- : prop)]


      {move 1}

      >>> postulate Rr xx : prop


      Rr : [(xx_1 : obj) => (--- : prop)]


      {move 1}

      >>> define Ss xx : (Pp xx) -> (Qq \
          xx)


      Ss : [(xx_1 : obj) => (--- : prop)]


      {move 1}

      >>> define Tt xx : (Qq xx) -> (Rr \
          xx)


      Tt : [(xx_1 : obj) => (--- : prop)]


      {move 1}

      >>> define Uu xx : (Pp xx) -> (Rr \
          xx)


      Uu : [(xx_1 : obj) => (--- : prop)]


      {move 1}

      >>> declare ss2 that Forall Ss


      ss2 : that Forall (Ss)


      {move 2}

      >>> declare tt2 that Forall Tt


      tt2 : that Forall (Tt)


      {move 2}

      >>> comment Our goal is to prove Forall \
          Uu


      {move 2}

      >>> open


         {move 3}

         >>> declare yy obj


         yy : obj


         {move 3}

         >>> comment >>> comment Our goal \
             is to show (Pp yy) -> (Rr yy)


         {move 3}

         >>> open


            {move 4}

            >>> declare ppyy that Pp yy


            ppyy : that Pp (yy)


            {move 4}

            >>> define imp1 : Ui Ss, ss2 \
                yy


            imp1 : that Ss (yy)


            {move 3}

            >>> define line5 ppyy : Mp (Pp \
                yy, Qq yy, ppyy, imp1)


            line5 : [(ppyy_1 : that Pp 
                (yy)) => (--- : that Qq 
                (yy))]


            {move 3}

            >>> define imp2 : Ui Tt, tt2 \
                yy


            imp2 : that Tt (yy)


            {move 3}

            >>> define line6 ppyy : Mp (Qq \
                yy, Rr yy, line5 ppyy, imp2)


            line6 : [(ppyy_1 : that Pp 
                (yy)) => (--- : that Rr 
                (yy))]


            {move 3}

            >>> close


         {move 3}

         >>> define line7 yy : Ifproof (Pp \
             yy, Rr yy, line6)


         line7 : [(yy_1 : obj) => (--- 
             : that Pp (yy_1) -> Rr (yy_1))]


         {move 2}

         >>> close


      {move 2}

      >>> define Univimp1 ss2 tt2 : Ug Uu, line7


      Univimp1 : [(ss2_1 : that Forall 
          (Ss)), (tt2_1 : that Forall 
          (Tt)) => (--- : that Forall 
          (Uu))]


      {move 1}

      >>> declare conj1 that (Forall Ss) & (Forall \
          Tt)


      conj1 : that Forall (Ss) & Forall 
       (Tt)


      {move 2}

      >>> define Univimp2 conj1 : Univimp1 \
          (And1 (Forall Ss, Forall Tt, conj1), And2 \
          (Forall Ss, Forall Tt, conj1))


      Univimp2 : [(conj1_1 : that Forall 
          (Ss) & Forall (Tt)) => (--- 
          : that Forall (Uu))]


      {move 1}

      >>> close


   {move 1}

   >>> define Univimp Pp, Qq, Rr : Ifproof \
       ((Forall Ss) & (Forall Tt), Forall \
       Uu, Univimp2)


   Univimp : [(Pp_1 : [(xx_2 : obj) => 
          (--- : prop)]), (Qq_1 : [(xx_2 
          : obj) => (--- : prop)]), (Rr_1 
       : [(xx_2 : obj) => (--- : prop)]) => 
       ({def} Ifproof (Forall ([(xx_4 
          : obj) => 
          ({def} Pp_1 (xx_4) -> Qq_1 (xx_4) : prop)]) & Forall 
       ([(xx_4 : obj) => 
          ({def} Qq_1 (xx_4) -> Rr_1 (xx_4) : prop)]), Forall 
       ([(xx_3 : obj) => 
          ({def} Pp_1 (xx_3) -> Rr_1 (xx_3) : prop)]), [(conj1_2 
          : that Forall ([(xx_5 : obj) => 
             ({def} Pp_1 (xx_5) -> Qq_1 
             (xx_5) : prop)]) & Forall 
          ([(xx_5 : obj) => 
             ({def} Qq_1 (xx_5) -> Rr_1 
             (xx_5) : prop)])) => 
          ({def} Ug ([(xx_3 : obj) => 
             ({def} Pp_1 (xx_3) -> Rr_1 
             (xx_3) : prop)], [(yy_3 
             : obj) => 
             ({def} Ifproof (Pp_1 (yy_3), Rr_1 
             (yy_3), [(ppyy_4 : that 
                Pp_1 (yy_3)) => 
                ({def} Mp (Qq_1 (yy_3), Rr_1 
                (yy_3), Mp (Pp_1 (yy_3), Qq_1 
                (yy_3), ppyy_4, Ui ([(xx_7 
                   : obj) => 
                   ({def} Pp_1 (xx_7) -> 
                   Qq_1 (xx_7) : prop)], And1 
                (Forall ([(xx_9 : obj) => 
                   ({def} Pp_1 (xx_9) -> 
                   Qq_1 (xx_9) : prop)]), Forall 
                ([(xx_9 : obj) => 
                   ({def} Qq_1 (xx_9) -> 
                   Rr_1 (xx_9) : prop)]), conj1_2), yy_3)), Ui 
                ([(xx_6 : obj) => 
                   ({def} Qq_1 (xx_6) -> 
                   Rr_1 (xx_6) : prop)], And2 
                (Forall ([(xx_8 : obj) => 
                   ({def} Pp_1 (xx_8) -> 
                   Qq_1 (xx_8) : prop)]), Forall 
                ([(xx_8 : obj) => 
                   ({def} Qq_1 (xx_8) -> 
                   Rr_1 (xx_8) : prop)]), conj1_2), yy_3)) : that 
                Rr_1 (yy_3))]) : that 
             Pp_1 (yy_3) -> Rr_1 (yy_3))]) : that 
          Forall ([(xx_3 : obj) => 
             ({def} Pp_1 (xx_3) -> Rr_1 
             (xx_3) : prop)]))]) : that 
       (Forall ([(xx_4 : obj) => 
          ({def} Pp_1 (xx_4) -> Qq_1 (xx_4) : prop)]) & Forall 
       ([(xx_4 : obj) => 
          ({def} Qq_1 (xx_4) -> Rr_1 (xx_4) : prop)])) -> 
       Forall ([(xx_3 : obj) => 
          ({def} Pp_1 (xx_3) -> Rr_1 (xx_3) : prop)]))]


   Univimp : [(Pp_1 : [(xx_2 : obj) => 
          (--- : prop)]), (Qq_1 : [(xx_2 
          : obj) => (--- : prop)]), (Rr_1 
       : [(xx_2 : obj) => (--- : prop)]) => 
       (--- : that (Forall ([(xx_4 : obj) => 
          ({def} Pp_1 (xx_4) -> Qq_1 (xx_4) : prop)]) & Forall 
       ([(xx_4 : obj) => 
          ({def} Qq_1 (xx_4) -> Rr_1 (xx_4) : prop)])) -> 
       Forall ([(xx_3 : obj) => 
          ({def} Pp_1 (xx_3) -> Rr_1 (xx_3) : prop)]))]


   {move 0}

   >>> comment Declarations of typed objects


   {move 1}

   >>> comment >>> comment The type of (true) natural \
       numbers .The theory of these


   {move 1}

   >>> comment >>> comment objects will be \
       second order arithmetic .Peano arithmetic


   {move 1}

   >>> comment will be >>> defined : it will \
       be instructive how hard it is to do this \
       .


   {move 1}

   >>> postulate Nat : type


   Nat : type


   {move 0}

   >>> postulate 1 : in Nat


   1 : in Nat


   {move 0}

   >>> declare n in Nat


   n : in Nat


   {move 1}

   >>> postulate Succ n : in Nat


   Succ : [(n_1 : in Nat) => (--- : in 
       Nat)]


   {move 0}

   >>> open


      {move 2}

      >>> declare n2 in Nat


      n2 : in Nat


      {move 2}

      >>> postulate Pn n2 : prop


      Pn : [(n2_1 : in Nat) => (--- : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> declare basis that Pn 1


   basis : that Pn (1)


   {move 1}

   >>> open


      {move 2}

      >>> declare k in Nat


      k : in Nat


      {move 2}

      >>> declare indhyp that Pn k


      indhyp : that Pn (k)


      {move 2}

      >>> postulate indstep k indhyp : that \
          Pn Succ k


      indstep : [(k_1 : in Nat), (indhyp_1 
          : that Pn (k_1)) => (--- : that 
          Pn (Succ (k_1)))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Induction n Pn, basis, indstep \
       : that Pn n


   Induction : [(n_1 : in Nat), (Pn_1 
       : [(n2_2 : in Nat) => (--- : prop)]), (basis_1 
       : that Pn_1 (1)), (indstep_1 : [(k_2 
          : in Nat), (indhyp_2 : that Pn_1 
          (k_2)) => (--- : that Pn_1 (Succ 
          (k_2)))]) => (--- : that 
       Pn_1 (n_1))]


   {move 0}

   >>> comment >>> comment We introduce the \
       declarations for the properties


   {move 1}

   >>> comment of equality of natural numbers \
       .


   {move 1}

   >>> declare m in Nat


   m : in Nat


   {move 1}

   >>> declare m2 in Nat


   m2 : in Nat


   {move 1}

   >>> postulate Eqn n m : prop


   Eqn : [(n_1 : in Nat), (m_1 : in 
       Nat) => (--- : prop)]


   {move 0}

   >>> comment We develop the substitution \
       rule (equality elimination)


   {move 1}

   >>> declare eqev that Eqn m m2


   eqev : that m Eqn m2


   {move 1}

   >>> declare pnpf that Pn m


   pnpf : that Pn (m)


   {move 1}

   >>> postulate Subs Pn, m m2 eqev pnpf \
       : that Pn m2


   Subs : [(Pn_1 : [(n2_2 : in Nat) => 
          (--- : prop)]), (m_1 : in 
       Nat), (m2_1 : in Nat), (eqev_1 
       : that m_1 Eqn m2_1), (pnpf_1 : that 
       Pn_1 (m_1)) => (--- : that Pn_1 
       (m2_1))]


   {move 0}

   >>> comment We develop the equality introduction \
       rule (Leibniz)


   {move 1}

   >>> open


      {move 2}

      >>> open


         {move 3}

         >>> declare n3 in Nat


         n3 : in Nat


         {move 3}

         >>> postulate Pn2 n3 : prop


         Pn2 : [(n3_1 : in Nat) => (--- 
             : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> declare pnn that Pn2 n


      pnn : that Pn2 (n)


      {move 2}

      >>> postulate eqpf Pn2, pnn : that \
          Pn2 m


      eqpf : [(Pn2_1 : [(n3_2 : in Nat) => 
             (--- : prop)]), (pnn_1 
          : that Pn2_1 (n)) => (--- : that 
          Pn2_1 (m))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Eqnproof n m, eqpf : that \
       n Eqn m


   Eqnproof : [(n_1 : in Nat), (m_1 
       : in Nat), (eqpf_1 : [(Pn2_2 : [(n3_3 
             : in Nat) => (--- : prop)]), (pnn_2 
          : that Pn2_2 (n_1)) => (--- 
          : that Pn2_2 (m_1))]) => (--- 
       : that n_1 Eqn m_1)]


   {move 0}

   >>> comment >>> comment We test the equality \
       introduction rule


   {move 1}

   >>> comment by proving reflexivity of \
       equality .


   {move 1}

   >>> open


      {move 2}

      >>> open


         {move 3}

         >>> declare n3 in Nat


         n3 : in Nat


         {move 3}

         >>> postulate Pn2 n3 : prop


         Pn2 : [(n3_1 : in Nat) => (--- 
             : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> declare pnn that Pn2 n


      pnn : that Pn2 (n)


      {move 2}

      >>> define eqpftest Pn2, pnn : pnn


      eqpftest : [(Pn2_1 : [(n3_2 : in 
             Nat) => (--- : prop)]), (pnn_1 
          : that Pn2_1 (n)) => (--- : that 
          Pn2_1 (n))]


      {move 1}

      >>> close


   {move 1}

   >>> define Refln n : Eqnproof n n, eqpftest


   Refln : [(n_1 : in Nat) => 
       ({def} Eqnproof (n_1, n_1, [(Pn2_2 
          : [(n3_3 : in Nat) => (--- : prop)]), (pnn_2 
          : that Pn2_2 (n_1)) => 
          ({def} pnn_2 : that Pn2_2 (n_1))]) : that 
       n_1 Eqn n_1)]


   Refln : [(n_1 : in Nat) => (--- : that 
       n_1 Eqn n_1)]


   {move 0}

   >>> postulate Pa3 n : that ~ (Succ n Eqn \
       1)


   Pa3 : [(n_1 : in Nat) => (--- : that 
       ~ (Succ (n_1) Eqn 1))]


   {move 0}

   >>> postulate Pa4 n m : that (Succ n Eqn \
       Succ m) -> n Eqn m


   Pa4 : [(n_1 : in Nat), (m_1 : in 
       Nat) => (--- : that (Succ (n_1) Eqn 
       Succ (m_1)) -> n_1 Eqn m_1)]


   {move 0}

   >>> comment >>> comment These definitions \
       are by no means exhaustive .One wants


   {move 1}

   >>> comment to >>> declare quantifiers \
       over natural numbers for example .


   {move 1}

   >>> comment Declarations for second order \
       type theory .


   {move 1}

   >>> postulate level n : type


   level : [(n_1 : in Nat) => (--- : type)]


   {move 0}

   >>> comment level n is what we usually \
       call type n .The bottom type will be type \
       1 .


   {move 1}

   >>> declare n3 in Nat


   n3 : in Nat


   {move 1}

   >>> declare x10 in level n3


   x10 : in level (n3)


   {move 1}

   >>> declare y10 in level Succ n3


   y10 : in level (Succ (n3))


   {move 1}

   >>> comment >>> declare the membership \
       relation (with a type argument)


   {move 1}

   >>> postulate E n3 x10 y10 : prop


   E : [(n3_1 : in Nat), (x10_1 : in 
       level (n3_1)), (y10_1 : in level 
       (Succ (n3_1))) => (--- : prop)]


   {move 0}

   >>> comment >>> declare the set abstract \
       >>> postulateor


   {move 1}

   >>> open


      {move 2}

      >>> declare x11 in level n3


      x11 : in level (n3)


      {move 2}

      >>> postulate Pt x11 : prop


      Pt : [(x11_1 : in level (n3)) => 
          (--- : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> comment >>> declare the comprehension \
       axioms


   {move 1}

   >>> postulate setof n3 Pt : in level Succ \
       n3


   setof : [(n3_1 : in Nat), (Pt_1 : [(x11_2 
          : in level (n3_1)) => (--- : prop)]) => 
       (--- : in level (Succ (n3_1)))]


   {move 0}

   >>> declare compev1 that E (n3, x10, setof \
       n3 Pt)


   compev1 : that E (n3, x10, n3 setof 
    Pt)


   {move 1}

   >>> postulate Comp1 n3 x10, Pt : that \
       Pt x10


   Comp1 : [(n3_1 : in Nat), (x10_1 
       : in level (n3_1)), (Pt_1 : [(x11_2 
          : in level (n3_1)) => (--- : prop)]) => 
       (--- : that Pt_1 (x10_1))]


   {move 0}

   >>> declare compev2 that Pt x10


   compev2 : that Pt (x10)


   {move 1}

   >>> postulate Comp2 n3 x10, Pt : that \
       E (n3, x10, setof n3 Pt)


   Comp2 : [(n3_1 : in Nat), (x10_1 
       : in level (n3_1)), (Pt_1 : [(x11_2 
          : in level (n3_1)) => (--- : prop)]) => 
       (--- : that E (n3_1, x10_1, n3_1 
       setof Pt_1))]


   {move 0}

   >>> comment >>> declare the extensionality \
       axiom


   {move 1}

   >>> declare xx10 in level Succ n3


   xx10 : in level (Succ (n3))


   {move 1}

   >>> declare yy10 in level Succ n3


   yy10 : in level (Succ (n3))


   {move 1}

   >>> declare ww10 in level Succ (Succ \
       n3)


   ww10 : in level (Succ (Succ (n3)))


   {move 1}

   >>> declare xinw that (Succ n3) E xx10 \
       ww10


   xinw : that E (Succ (n3), xx10, ww10)


   {move 1}

   >>> open


      {move 2}

      >>> declare z11 in level n3


      z11 : in level (n3)


      {move 2}

      >>> declare zinx that n3 E z11 xx10


      zinx : that E (n3, z11, xx10)


      {move 2}

      >>> declare ziny that n3 E z11 yy10


      ziny : that E (n3, z11, yy10)


      {move 2}

      >>> postulate xincy z11 zinx : that \
          n3 E z11 yy10


      xincy : [(z11_1 : in level (n3)), (zinx_1 
          : that E (n3, z11_1, xx10)) => 
          (--- : that E (n3, z11_1, yy10))]


      {move 1}

      >>> postulate yincx z11 ziny : that \
          n3 E z11 xx10


      yincx : [(z11_1 : in level (n3)), (ziny_1 
          : that E (n3, z11_1, yy10)) => 
          (--- : that E (n3, z11_1, xx10))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Extensionality n3 xx10 yy10 \
       ww10, xinw, xincy, yincx : that (Succ \
       n3) E yy10 ww10


   Extensionality : [(n3_1 : in Nat), (xx10_1 
       : in level (Succ (n3_1))), (yy10_1 
       : in level (Succ (n3_1))), (ww10_1 
       : in level (Succ (Succ (n3_1)))), (xinw_1 
       : that E (Succ (n3_1), xx10_1, ww10_1)), (xincy_1 
       : [(z11_2 : in level (n3_1)), (zinx_2 
          : that E (n3_1, z11_2, xx10_1)) => 
          (--- : that E (n3_1, z11_2, yy10_1))]), (yincx_1 
       : [(z11_2 : in level (n3_1)), (ziny_2 
          : that E (n3_1, z11_2, yy10_1)) => 
          (--- : that E (n3_1, z11_2, xx10_1))]) => 
       (--- : that E (Succ (n3_1), yy10_1, ww10_1))]


   {move 0}

   >>> comment >>> comment All of these declarations \
       are shockingly economical : a useful treatment


   {move 1}

   >>> comment >>> comment would at least \
       provide quantifiers and quantifier rules \
       for the types shown .


   {move 1}

   >>> comment This can be done readily .


   {move 1}

   >>> comment Declaring the universal quantifier \
       for general types .


   {move 1}

   >>> declare tau type


   tau : type


   {move 1}

   >>> open


      {move 2}

      >>> declare uu in tau


      uu : in tau


      {move 2}

      >>> postulate Ptt uu : prop


      Ptt : [(uu_1 : in tau) => (--- 
          : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Forallt tau Ptt : prop


   Forallt : [(tau_1 : type), (Ptt_1 
       : [(uu_2 : in tau_1) => (--- : prop)]) => 
       (--- : prop)]


   {move 0}

   >>> comment Declaring the rule U I of \
       universal instantiation (for general \
       types)


   {move 1}

   >>> declare Ptt2 that Forallt tau Ptt


   Ptt2 : that tau Forallt Ptt


   {move 1}

   >>> declare xt in tau


   xt : in tau


   {move 1}

   >>> postulate Uit tau Ptt, Ptt2 xt : that \
       Ptt xt


   Uit : [(tau_1 : type), (Ptt_1 : [(uu_2 
          : in tau_1) => (--- : prop)]), (Ptt2_1 
       : that tau_1 Forallt Ptt_1), (xt_1 
       : in tau_1) => (--- : that Ptt_1 
       (xt_1))]


   {move 0}

   >>> comment >>> comment Note in the previous \
       line that we follow P


   {move 1}

   >>> comment >>> comment with a comma : an \
       abstraction argument may need to be


   {move 1}

   >>> comment guarded with commas so it \
       will not be read as applied .


   {move 1}

   >>> comment >>> comment >>> opening an \
       environment to >>> declare a function


   {move 1}

   >>> comment that witnesses provability \
       of a universal statement


   {move 1}

   >>> open


      {move 2}

      >>> declare ut in tau


      ut : in tau


      {move 2}

      >>> postulate Qt2 ut : that Ptt ut


      Qt2 : [(ut_1 : in tau) => (--- 
          : that Ptt (ut_1))]


      {move 1}

      >>> close


   {move 1}

   >>> comment The rule of universal generalization \
       (for general types)


   {move 1}

   >>> postulate Ugt tau Ptt, Qt2 : that \
       Forallt tau Ptt


   Ugt : [(tau_1 : type), (Ptt_1 : [(uu_2 
          : in tau_1) => (--- : prop)]), (Qt2_1 
       : [(ut_2 : in tau_1) => (--- : that 
          Ptt_1 (ut_2))]) => (--- : that 
       tau_1 Forallt Ptt_1)]


   {move 0}

   >>> comment The existential quantifier \
       (for general types)


   {move 1}

   >>> postulate Existst tau Ptt : prop


   Existst : [(tau_1 : type), (Ptt_1 
       : [(uu_2 : in tau_1) => (--- : prop)]) => 
       (--- : prop)]


   {move 0}

   >>> comment the rule E G (existential \
       introduction) (for general types)


   {move 1}

   >>> declare evt that Ptt xt


   evt : that Ptt (xt)


   {move 1}

   >>> postulate Egt tau Ptt, xt evt : that \
       Existst tau Ptt


   Egt : [(tau_1 : type), (Ptt_1 : [(uu_2 
          : in tau_1) => (--- : prop)]), (xt_1 
       : in tau_1), (evt_1 : that Ptt_1 
       (xt_1)) => (--- : that tau_1 Existst 
       Ptt_1)]


   {move 0}

   >>> comment the rule E I (existential \
       elimination) (for general types)


   {move 1}

   >>> declare gt prop


   gt : prop


   {move 1}

   >>> declare ext that Existst tau Ptt


   ext : that tau Existst Ptt


   {move 1}

   >>> open


      {move 2}

      >>> declare wt in tau


      wt : in tau


      {move 2}

      >>> declare evt2 that Ptt wt


      evt2 : that Ptt (wt)


      {move 2}

      >>> postulate wit wt evt2 : that gt


      wit : [(wt_1 : in tau), (evt2_1 
          : that Ptt (wt_1)) => (--- : that 
          gt)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Eit tau Ptt, gt, ext, wit \
       : that gt


   Eit : [(tau_1 : type), (Ptt_1 : [(uu_2 
          : in tau_1) => (--- : prop)]), (gt_1 
       : prop), (ext_1 : that tau_1 Existst 
       Ptt_1), (wit_1 : [(wt_2 : in tau_1), (evt2_2 
          : that Ptt_1 (wt_2)) => (--- 
          : that gt_1)]) => (--- : that 
       gt_1)]


   {move 0}

   >>> comment Equality uniqueness and definite \
       description


   {move 1}

   >>> declare y obj


   y : obj


   {move 1}

   >>> comment Equality of untyped objects


   {move 1}

   >>> postulate = x y : prop


   =: [(x_1 : obj), (y_1 : obj) => 
       (--- : prop)]


   {move 0}

   >>> comment Develop equality introduction \
       rule (indiscernibility)


   {move 1}

   >>> open


      {move 2}

      >>> open


         {move 3}

         >>> declare x2 obj


         x2 : obj


         {move 3}

         >>> postulate Peq2 x2 : prop


         Peq2 : [(x2_1 : obj) => (--- 
             : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> declare pxev that Peq2 x


      pxev : that Peq2 (x)


      {move 2}

      >>> postulate pyev Peq2, pxev : that \
          Peq2 y


      pyev : [(Peq2_1 : [(x2_2 : obj) => 
             (--- : prop)]), (pxev_1 
          : that Peq2_1 (x)) => (--- : that 
          Peq2_1 (y))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Eqintro x y pyev : that \
       x = y


   Eqintro : [(x_1 : obj), (y_1 : obj), (pyev_1 
       : [(Peq2_2 : [(x2_3 : obj) => 
             (--- : prop)]), (pxev_2 
          : that Peq2_2 (x_1)) => (--- 
          : that Peq2_2 (y_1))]) => (--- 
       : that x_1 = y_1)]


   {move 0}

   >>> comment >>> postulate equality elimination \
       rule (substitution)


   {move 1}

   >>> declare xyeqev that x = y


   xyeqev : that x = y


   {move 1}

   >>> declare pxev that P x


   pxev : that P (x)


   {move 1}

   >>> postulate Eqelim P, x y xyeqev pxev \
       : that P y


   Eqelim : [(P_1 : [(xx_2 : obj) => 
          (--- : prop)]), (x_1 : obj), (y_1 
       : obj), (xyeqev_1 : that x_1 = y_1), (pxev_1 
       : that P_1 (x_1)) => (--- : that 
       P_1 (y_1))]


   {move 0}

   >>> comment >>> comment The same rules \
       for equality, adapted to general types


   {move 1}

   >>> declare yt in tau


   yt : in tau


   {move 1}

   >>> postulate eqt tau xt yt : prop


   eqt : [(tau_1 : type), (xt_1 : in 
       tau_1), (yt_1 : in tau_1) => (--- 
       : prop)]


   {move 0}

   >>> comment Develop equality introduction \
       rule (indiscernibility)


   {move 1}

   >>> open


      {move 2}

      >>> open


         {move 3}

         >>> declare x2 in tau


         x2 : in tau


         {move 3}

         >>> postulate Peqt2 x2 : prop


         Peqt2 : [(x2_1 : in tau) => (--- 
             : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> declare pxevt that Peqt2 xt


      pxevt : that Peqt2 (xt)


      {move 2}

      >>> postulate pyevt Peqt2, pxevt : that \
          Peqt2 yt


      pyevt : [(Peqt2_1 : [(x2_2 : in 
             tau) => (--- : prop)]), (pxevt_1 
          : that Peqt2_1 (xt)) => (--- 
          : that Peqt2_1 (yt))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Eqintrot tau xt yt pyevt \
       : that tau eqt xt yt


   Eqintrot : [(tau_1 : type), (xt_1 
       : in tau_1), (yt_1 : in tau_1), (pyevt_1 
       : [(Peqt2_2 : [(x2_3 : in tau_1) => 
             (--- : prop)]), (pxevt_2 
          : that Peqt2_2 (xt_1)) => (--- 
          : that Peqt2_2 (yt_1))]) => 
       (--- : that eqt (tau_1, xt_1, yt_1))]


   {move 0}

   >>> comment >>> comment >>> postulate \
       equality elimination rule (substitution)


   {move 1}

   >>> declare xyeqevt that tau eqt xt yt


   xyeqevt : that eqt (tau, xt, yt)


   {move 1}

   >>> declare pxevt that Ptt xt


   pxevt : that Ptt (xt)


   {move 1}

   >>> postulate Eqelimt tau Ptt, xt yt \
       xyeqevt pxevt : that Ptt yt


   Eqelimt : [(tau_1 : type), (Ptt_1 
       : [(uu_2 : in tau_1) => (--- : prop)]), (xt_1 
       : in tau_1), (yt_1 : in tau_1), (xyeqevt_1 
       : that eqt (tau_1, xt_1, yt_1)), (pxevt_1 
       : that Ptt_1 (xt_1)) => (--- : that 
       Ptt_1 (yt_1))]


   {move 0}

   >>> comment The definite description operator


   {move 1}

   >>> declare atleast1 that Exists P


   atleast1 : that Exists (P)


   {move 1}

   >>> open


      {move 2}

      >>> declare x1 obj


      x1 : obj


      {move 2}

      >>> declare x2 obj


      x2 : obj


      {move 2}

      >>> declare thatpx1 that P x1


      thatpx1 : that P (x1)


      {move 2}

      >>> declare thatpx2 that P x2


      thatpx2 : that P (x2)


      {move 2}

      >>> postulate atmost1 x1 x2 thatpx1 \
          thatpx2 : that x1 = x2


      atmost1 : [(x1_1 : obj), (x2_1 
          : obj), (thatpx1_1 : that P (x1_1)), (thatpx2_1 
          : that P (x2_1)) => (--- : that 
          x1_1 = x2_1)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate The P, atleast1 atmost1 \
       : obj


   The : [(P_1 : [(xx_2 : obj) => (--- 
          : prop)]), (atleast1_1 : that 
       Exists (P_1)), (atmost1_1 : [(x1_2 
          : obj), (x2_2 : obj), (thatpx1_2 
          : that P_1 (x1_2)), (thatpx2_2 
          : that P_1 (x2_2)) => (--- : that 
          x1_2 = x2_2)]) => (--- : obj)]


   {move 0}

   >>> postulate Theprop P, atleast1, atmost1 \
       : that P (The (P, atleast1, atmost1))


   Theprop : [(P_1 : [(xx_2 : obj) => 
          (--- : prop)]), (atleast1_1 
       : that Exists (P_1)), (atmost1_1 
       : [(x1_2 : obj), (x2_2 : obj), (thatpx1_2 
          : that P_1 (x1_2)), (thatpx2_2 
          : that P_1 (x2_2)) => (--- : that 
          x1_2 = x2_2)]) => (--- : that 
       P_1 (The (P_1, atleast1_1, atmost1_1)))]


   {move 0}

   >>> comment >>> comment The definite description \
       operator (for general types)


   {move 1}

   >>> declare atleastt1 that Existst tau \
       Ptt


   atleastt1 : that tau Existst Ptt


   {move 1}

   >>> open


      {move 2}

      >>> declare x1 in tau


      x1 : in tau


      {move 2}

      >>> declare x2 in tau


      x2 : in tau


      {move 2}

      >>> declare thatpx1 that Ptt x1


      thatpx1 : that Ptt (x1)


      {move 2}

      >>> declare thatpx2 that Ptt x2


      thatpx2 : that Ptt (x2)


      {move 2}

      >>> postulate atmostt1 x1 x2 thatpx1 \
          thatpx2 : that tau eqt x1 x2


      atmostt1 : [(x1_1 : in tau), (x2_1 
          : in tau), (thatpx1_1 : that 
          Ptt (x1_1)), (thatpx2_1 : that 
          Ptt (x2_1)) => (--- : that eqt 
          (tau, x1_1, x2_1))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Thet tau Ptt, atleastt1 \
       atmostt1 : in tau


   Thet : [(tau_1 : type), (Ptt_1 : [(uu_2 
          : in tau_1) => (--- : prop)]), (atleastt1_1 
       : that tau_1 Existst Ptt_1), (atmostt1_1 
       : [(x1_2 : in tau_1), (x2_2 : in 
          tau_1), (thatpx1_2 : that Ptt_1 
          (x1_2)), (thatpx2_2 : that 
          Ptt_1 (x2_2)) => (--- : that 
          eqt (tau_1, x1_2, x2_2))]) => 
       (--- : in tau_1)]


   {move 0}

   >>> postulate Thepropt tau Ptt, atleastt1, atmostt1 \
       : that Ptt (Thet (tau, Ptt, atleastt1, atmostt1))


   Thepropt : [(tau_1 : type), (Ptt_1 
       : [(uu_2 : in tau_1) => (--- : prop)]), (atleastt1_1 
       : that tau_1 Existst Ptt_1), (atmostt1_1 
       : [(x1_2 : in tau_1), (x2_2 : in 
          tau_1), (thatpx1_2 : that Ptt_1 
          (x1_2)), (thatpx2_2 : that 
          Ptt_1 (x2_2)) => (--- : that 
          eqt (tau_1, x1_2, x2_2))]) => 
       (--- : that Ptt_1 (Thet (tau_1, Ptt_1, atleastt1_1, atmostt1_1)))]


   {move 0}

   >>> comment >>> comment Drafting Zermelo \
       - style set theory in untyped objects


   {move 1}

   >>> comment The membership relation


   {move 1}

   >>> postulate e x y : prop


   e : [(x_1 : obj), (y_1 : obj) => 
       (--- : prop)]


   {move 0}

   >>> comment The axiom of extensionality


   {move 1}

   >>> open


      {move 2}

      >>> declare z obj


      z : obj


      {move 2}

      >>> declare zinx that z e x


      zinx : that z e x


      {move 2}

      >>> postulate xcy z zinx : that z e y


      xcy : [(z_1 : obj), (zinx_1 : that 
          z_1 e x) => (--- : that z_1 e y)]


      {move 1}

      >>> declare ziny that z e y


      ziny : that z e y


      {move 2}

      >>> postulate ycx z ziny : that z e x


      ycx : [(z_1 : obj), (ziny_1 : that 
          z_1 e y) => (--- : that z_1 e x)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Zext x y, xcy, ycx : that \
       x = y


   Zext : [(x_1 : obj), (y_1 : obj), (xcy_1 
       : [(z_2 : obj), (zinx_2 : that 
          z_2 e x_1) => (--- : that z_2 
          e y_1)]), (ycx_1 : [(z_2 
          : obj), (ziny_2 : that z_2 e y_1) => 
          (--- : that z_2 e x_1)]) => 
       (--- : that x_1 = y_1)]


   {move 0}

   >>> comment >>> comment more to do here \
       of course


   {move 1}

   >>> comment >>> comment development of \
       iterators


   {move 1}

   >>> comment >>> comment develop the definition \
       of the relation


   {move 1}

   >>> comment which is the graph of a function \
       (easy)


   {move 1}

   >>> declare sigma type


   sigma : type


   {move 1}

   >>> open


      {move 2}

      >>> declare xf in tau


      xf : in tau


      {move 2}

      >>> postulate ff xf : in sigma


      ff : [(xf_1 : in tau) => (--- : in 
          sigma)]


      {move 1}

      >>> close


   {move 1}

   >>> declare xtt in tau


   xtt : in tau


   {move 1}

   >>> declare yss in sigma


   yss : in sigma


   {move 1}

   >>> define Graph tau sigma ff, xtt yss \
       : sigma eqt yss ff xtt


   Graph : [(tau_1 : type), (sigma_1 
       : type), (ff_1 : [(xf_2 : in tau_1) => 
          (--- : in sigma_1)]), (xtt_1 
       : in tau_1), (yss_1 : in sigma_1) => 
       ({def} eqt (sigma_1, yss_1, ff_1 
       (xtt_1)) : prop)]


   Graph : [(tau_1 : type), (sigma_1 
       : type), (ff_1 : [(xf_2 : in tau_1) => 
          (--- : in sigma_1)]), (xtt_1 
       : in tau_1), (yss_1 : in sigma_1) => 
       (--- : prop)]


   {move 0}

   >>> comment >>> comment Then develop the \
       function whose graph is a given


   {move 1}

   >>> comment functional relation (much \
       trickier)


   {move 1}

   >>> open


      {move 2}

      >>> declare xt2 in tau


      xt2 : in tau


      {move 2}

      >>> declare ys in sigma


      ys : in sigma


      {move 2}

      >>> postulate Rst xt2 ys : prop


      Rst : [(xt2_1 : in tau), (ys_1 
          : in sigma) => (--- : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> open


      {move 2}

      >>> declare xt2 in tau


      xt2 : in tau


      {move 2}

      >>> open


         {move 3}

         >>> declare ys2 in sigma


         ys2 : in sigma


         {move 3}

         >>> define Rst2 ys2 : Rst xt2 ys2


         Rst2 : [(ys2_1 : in sigma) => 
             (--- : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> postulate Rstex xt2 : that Existst \
          sigma Rst2


      Rstex : [(xt2_1 : in tau) => (--- 
          : that sigma Existst [(ys2_2 : in 
             sigma) => 
             ({def} xt2_1 Rst ys2_2 : prop)])]


      {move 1}

      >>> close


   {move 1}

   >>> open


      {move 2}

      >>> declare xt2 in tau


      xt2 : in tau


      {move 2}

      >>> declare ys3 in sigma


      ys3 : in sigma


      {move 2}

      >>> declare ys4 in sigma


      ys4 : in sigma


      {move 2}

      >>> declare ysfact3 that xt2 Rst ys3


      ysfact3 : that xt2 Rst ys3


      {move 2}

      >>> declare ysfact4 that xt2 Rst ys4


      ysfact4 : that xt2 Rst ys4


      {move 2}

      >>> postulate Rsunique xt2 ys3 ys4 \
          ysfact3 ysfact4 : that sigma eqt ys3 \
          ys4


      Rsunique : [(xt2_1 : in tau), (ys3_1 
          : in sigma), (ys4_1 : in sigma), (ysfact3_1 
          : that xt2_1 Rst ys3_1), (ysfact4_1 
          : that xt2_1 Rst ys4_1) => (--- 
          : that eqt (sigma, ys3_1, ys4_1))]


      {move 1}

      >>> close


   {move 1}

   >>> open


      {move 2}

      >>> declare xt2 in tau


      xt2 : in tau


      {move 2}

      >>> open


         {move 3}

         >>> declare ys2 in sigma


         ys2 : in sigma


         {move 3}

         >>> define Rst2 ys2 : Rst xt2 ys2


         Rst2 : [(ys2_1 : in sigma) => 
             (--- : prop)]


         {move 2}

         >>> declare ys3 in sigma


         ys3 : in sigma


         {move 3}

         >>> declare ys4 in sigma


         ys4 : in sigma


         {move 3}

         >>> declare ysfact3 that xt2 Rst \
             ys3


         ysfact3 : that xt2 Rst ys3


         {move 3}

         >>> declare ysfact4 that xt2 Rst \
             ys4


         ysfact4 : that xt2 Rst ys4


         {move 3}

         >>> define Rsunique2 ys3 ys4 ysfact3 \
             ysfact4 : Rsunique xt2 ys3 ys4 ysfact3 \
             ysfact4


         Rsunique2 : [(ys3_1 : in sigma), (ys4_1 
             : in sigma), (ysfact3_1 : that 
             xt2 Rst ys3_1), (ysfact4_1 
             : that xt2 Rst ys4_1) => (--- 
             : that eqt (sigma, ys3_1, ys4_1))]


         {move 2}

         >>> close


      {move 2}

      >>> define Rstarget xt2 : Thet sigma, Rst2, Rstex \
          xt2, Rsunique2


      Rstarget : [(xt2_1 : in tau) => 
          (--- : in sigma)]


      {move 1}

      >>> define Rstargetprop xt2 : Thepropt \
          sigma Rst2, Rstex xt2, Rsunique2


      Rstargetprop : [(xt2_1 : in tau) => 
          (--- : that xt2_1 Rst Thet (sigma, [(ys2_3 
             : in sigma) => 
             ({def} xt2_1 Rst ys2_3 : prop)], Rstex 
          (xt2_1), [(ys3_3 : in sigma), (ys4_3 
             : in sigma), (ysfact3_3 : that 
             xt2_1 Rst ys3_3), (ysfact4_3 
             : that xt2_1 Rst ys4_3) => 
             ({def} Rsunique (xt2_1, ys3_3, ys4_3, ysfact3_3, ysfact4_3) : that 
             eqt (sigma, ys3_3, ys4_3))]))]


      {move 1}

      >>> close


   {move 1}

   >>> declare xttt in tau


   xttt : in tau


   {move 1}

   >>> define Ungraph tau sigma, Rst, Rstex, Rsunique, xttt \
       : Rstarget xttt


   Ungraph : [(tau_1 : type), (sigma_1 
       : type), (Rst_1 : [(xt2_2 : in 
          tau_1), (ys_2 : in sigma_1) => 
          (--- : prop)]), (Rstex_1 : [(xt2_2 
          : in tau_1) => (--- : that sigma_1 
          Existst [(ys2_3 : in sigma_1) => 
             ({def} xt2_2 Rst ys2_3 : prop)])]), (Rsunique_1 
       : [(xt2_2 : in tau_1), (ys3_2 
          : in sigma_1), (ys4_2 : in sigma_1), (ysfact3_2 
          : that xt2_2 Rst ys3_2), (ysfact4_2 
          : that xt2_2 Rst ys4_2) => (--- 
          : that eqt (sigma_1, ys3_2, ys4_2))]), (xttt_1 
       : in tau_1) => 
       ({def} Thet (sigma_1, [(ys2_2 
          : in sigma_1) => 
          ({def} xttt_1 Rst ys2_2 : prop)], Rstex_1 
       (xttt_1), [(ys3_2 : in sigma_1), (ys4_2 
          : in sigma_1), (ysfact3_2 : that 
          xttt_1 Rst ys3_2), (ysfact4_2 
          : that xttt_1 Rst ys4_2) => 
          ({def} Rsunique_1 (xttt_1, ys3_2, ys4_2, ysfact3_2, ysfact4_2) : that 
          eqt (sigma_1, ys3_2, ys4_2))]) : in 
       sigma_1)]


   Ungraph : [(tau_1 : type), (sigma_1 
       : type), (Rst_1 : [(xt2_2 : in 
          tau_1), (ys_2 : in sigma_1) => 
          (--- : prop)]), (Rstex_1 : [(xt2_2 
          : in tau_1) => (--- : that sigma_1 
          Existst [(ys2_3 : in sigma_1) => 
             ({def} xt2_2 Rst ys2_3 : prop)])]), (Rsunique_1 
       : [(xt2_2 : in tau_1), (ys3_2 
          : in sigma_1), (ys4_2 : in sigma_1), (ysfact3_2 
          : that xt2_2 Rst ys3_2), (ysfact4_2 
          : that xt2_2 Rst ys4_2) => (--- 
          : that eqt (sigma_1, ys3_2, ys4_2))]), (xttt_1 
       : in tau_1) => (--- : in sigma_1)]


   {move 0}

   >>> define Ungraphprop tau sigma, Rst, Rstex, Rsunique, xttt \
       : Rstargetprop xttt


   Ungraphprop : [(tau_1 : type), (sigma_1 
       : type), (Rst_1 : [(xt2_2 : in 
          tau_1), (ys_2 : in sigma_1) => 
          (--- : prop)]), (Rstex_1 : [(xt2_2 
          : in tau_1) => (--- : that sigma_1 
          Existst [(ys2_3 : in sigma_1) => 
             ({def} xt2_2 Rst ys2_3 : prop)])]), (Rsunique_1 
       : [(xt2_2 : in tau_1), (ys3_2 
          : in sigma_1), (ys4_2 : in sigma_1), (ysfact3_2 
          : that xt2_2 Rst ys3_2), (ysfact4_2 
          : that xt2_2 Rst ys4_2) => (--- 
          : that eqt (sigma_1, ys3_2, ys4_2))]), (xttt_1 
       : in tau_1) => 
       ({def} Thepropt (sigma_1, [(ys2_2 
          : in sigma_1) => 
          ({def} xttt_1 Rst ys2_2 : prop)], Rstex_1 
       (xttt_1), [(ys3_2 : in sigma_1), (ys4_2 
          : in sigma_1), (ysfact3_2 : that 
          xttt_1 Rst ys3_2), (ysfact4_2 
          : that xttt_1 Rst ys4_2) => 
          ({def} Rsunique_1 (xttt_1, ys3_2, ys4_2, ysfact3_2, ysfact4_2) : that 
          eqt (sigma_1, ys3_2, ys4_2))]) : that 
       xttt_1 Rst Thet (sigma_1, [(ys2_3 
          : in sigma_1) => 
          ({def} xttt_1 Rst ys2_3 : prop)], Rstex_1 
       (xttt_1), [(ys3_3 : in sigma_1), (ys4_3 
          : in sigma_1), (ysfact3_3 : that 
          xttt_1 Rst ys3_3), (ysfact4_3 
          : that xttt_1 Rst ys4_3) => 
          ({def} Rsunique_1 (xttt_1, ys3_3, ys4_3, ysfact3_3, ysfact4_3) : that 
          eqt (sigma_1, ys3_3, ys4_3))]))]


   Ungraphprop : [(tau_1 : type), (sigma_1 
       : type), (Rst_1 : [(xt2_2 : in 
          tau_1), (ys_2 : in sigma_1) => 
          (--- : prop)]), (Rstex_1 : [(xt2_2 
          : in tau_1) => (--- : that sigma_1 
          Existst [(ys2_3 : in sigma_1) => 
             ({def} xt2_2 Rst ys2_3 : prop)])]), (Rsunique_1 
       : [(xt2_2 : in tau_1), (ys3_2 
          : in sigma_1), (ys4_2 : in sigma_1), (ysfact3_2 
          : that xt2_2 Rst ys3_2), (ysfact4_2 
          : that xt2_2 Rst ys4_2) => (--- 
          : that eqt (sigma_1, ys3_2, ys4_2))]), (xttt_1 
       : in tau_1) => (--- : that xttt_1 
       Rst Thet (sigma_1, [(ys2_3 : in 
          sigma_1) => 
          ({def} xttt_1 Rst ys2_3 : prop)], Rstex_1 
       (xttt_1), [(ys3_3 : in sigma_1), (ys4_3 
          : in sigma_1), (ysfact3_3 : that 
          xttt_1 Rst ys3_3), (ysfact4_3 
          : that xttt_1 Rst ys4_3) => 
          ({def} Rsunique_1 (xttt_1, ys3_3, ys4_3, ysfact3_3, ysfact4_3) : that 
          eqt (sigma_1, ys3_3, ys4_3))]))]


   {move 0}

   >>> comment Now begin to >>> define iterators \
       (f ^ n (x))


   {move 1}

   >>> clearcurrent

{move 1}

   >>> declare tau type


   tau : type


   {move 1}

   >>> open


      {move 2}

      >>> declare y in tau


      y : in tau


      {move 2}

      >>> postulate f y : in tau


      f : [(y_1 : in tau) => (--- : in 
          tau)]


      {move 1}

      >>> close


   {move 1}

   >>> declare x in tau


   x : in tau


   {move 1}

   >>> declare u in Nat


   u : in Nat


   {move 1}

   >>> declare vv in tau


   vv : in tau


   {move 1}

   >>> comment We will now >>> define a way \
       to iterate f


   {move 1}

   >>> open


      {move 2}

      >>> open


         {move 3}

         >>> declare y in Nat


         y : in Nat


         {move 3}

         >>> declare z in tau


         z : in tau


         {move 3}

         >>> postulate R y z : prop


         R : [(y_1 : in Nat), (z_1 : in 
             tau) => (--- : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> comment >>> comment F is a variable \
          property of


      {move 2}

      >>> comment binary relations from Nat \
          to tau


      {move 2}

      >>> postulate F, R : prop


      F : [(R_1 : [(y_2 : in Nat), (z_2 
             : in tau) => (--- : prop)]) => 
          (--- : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> comment >>> comment Forallrel is the \
       universal quantifier over


   {move 1}

   >>> comment a variable representing a binary \
       relation from Nat to tau


   {move 1}

   >>> postulate Forallrel tau F : prop


   Forallrel : [(tau_1 : type), (F_1 
       : [(R_2 : [(y_3 : in Nat), (z_3 
             : in tau_1) => (--- : prop)]) => 
          (--- : prop)]) => (--- : prop)]


   {move 0}

   >>> comment develop the reasoning rules \
       for Forallrel


   {move 1}

   >>> comment Declaring the rule U I of \
       universal instantiation (for binary relations)


   {move 1}

   >>> comment The fact that we C A N >>> \
       define second order quantifiers is interesting \
       .


   {move 1}

   >>> declare Funiv that Forallrel tau F


   Funiv : that tau Forallrel F


   {move 1}

   >>> open


      {move 2}

      >>> declare y3 in Nat


      y3 : in Nat


      {move 2}

      >>> declare z3 in tau


      z3 : in tau


      {move 2}

      >>> postulate S y3 z3 : prop


      S : [(y3_1 : in Nat), (z3_1 : in 
          tau) => (--- : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Uitrel tau F, Funiv, S : that \
       F S


   Uitrel : [(tau_1 : type), (F_1 : [(R_2 
          : [(y_3 : in Nat), (z_3 : in 
             tau_1) => (--- : prop)]) => 
          (--- : prop)]), (Funiv_1 : that 
       tau_1 Forallrel F_1), (S_1 : [(y3_2 
          : in Nat), (z3_2 : in tau_1) => 
          (--- : prop)]) => (--- : that 
       F_1 (S_1))]


   {move 0}

   >>> open


      {move 2}

      >>> open


         {move 3}

         >>> declare y3 in Nat


         y3 : in Nat


         {move 3}

         >>> declare z3 in tau


         z3 : in tau


         {move 3}

         >>> postulate S2 y3 z3 : prop


         S2 : [(y3_1 : in Nat), (z3_1 
             : in tau) => (--- : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> postulate Qrel2 S2 : that F S2


      Qrel2 : [(S2_1 : [(y3_2 : in Nat), (z3_2 
             : in tau) => (--- : prop)]) => 
          (--- : that F (S2_1))]


      {move 1}

      >>> close


   {move 1}

   >>> comment The rule of universal generalization \
       (for binary relations)


   {move 1}

   >>> postulate Ugtrel tau F, Qrel2 : that \
       Forallrel tau F


   Ugtrel : [(tau_1 : type), (F_1 : [(R_2 
          : [(y_3 : in Nat), (z_3 : in 
             tau_1) => (--- : prop)]) => 
          (--- : prop)]), (Qrel2_1 : [(S2_2 
          : [(y3_3 : in Nat), (z3_3 : in 
             tau_1) => (--- : prop)]) => 
          (--- : that F_1 (S2_2))]) => 
       (--- : that tau_1 Forallrel F_1)]


   {move 0}

   >>> open


      {move 2}

      >>> open


         {move 3}

         >>> declare y in Nat


         y : in Nat


         {move 3}

         >>> declare z in tau


         z : in tau


         {move 3}

         >>> postulate R y z : prop


         R : [(y_1 : in Nat), (z_1 : in 
             tau) => (--- : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> open


         {move 3}

         >>> declare y2 in Nat


         y2 : in Nat


         {move 3}

         >>> open


            {move 4}

            >>> declare z2 in tau


            z2 : in tau


            {move 4}

            >>> define Zpred z2 : (y2 R z2) -> \
                (Succ y2) R (f z2)


            Zpred : [(z2_1 : in tau) => 
                (--- : prop)]


            {move 3}

            >>> close


         {move 3}

         >>> define Ypred y2 : Forallt tau \
             Zpred


         Ypred : [(y2_1 : in Nat) => (--- 
             : prop)]


         {move 2}

         >>> close


      {move 2}

      >>> define Rpred R : (1 R x) & Forallt \
          Nat Ypred


      Rpred : [(R_1 : [(y_2 : in Nat), (z_2 
             : in tau) => (--- : prop)]) => 
          (--- : prop)]


      {move 1}

      >>> comment >>> define Iterfx y z as \
          holding when for all R, Rpred R -> \
          y R z


      {move 2}

      >>> define Preiter R : (Rpred R) -> \
          u R vv


      Preiter : [(R_1 : [(y_2 : in Nat), (z_2 
             : in tau) => (--- : prop)]) => 
          (--- : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> define Iter tau f, x u vv : Forallrel \
       tau Preiter


   Iter : [(tau_1 : type), (f_1 : [(y_2 
          : in tau_1) => (--- : in tau_1)]), (x_1 
       : in tau_1), (u_1 : in Nat), (vv_1 
       : in tau_1) => 
       ({def} tau_1 Forallrel [(R_2 : [(y_3 
             : in Nat), (z_3 : in tau_1) => 
             (--- : prop)]) => 
          ({def} (R_2 (1, x_1) & Nat 
          Forallt [(y2_5 : in Nat) => 
             ({def} tau_1 Forallt [(z2_6 
                : in tau_1) => 
                ({def} R_2 (y2_5, z2_6) -> 
                R_2 (Succ (y2_5), f_1 
                (z2_6)) : prop)] : prop)]) -> 
          R_2 (u_1, vv_1) : prop)] : prop)]


   Iter : [(tau_1 : type), (f_1 : [(y_2 
          : in tau_1) => (--- : in tau_1)]), (x_1 
       : in tau_1), (u_1 : in Nat), (vv_1 
       : in tau_1) => (--- : prop)]


   {move 0}

   >>> comment >>> comment There remains \
       the serious work of showing that Iter \
       really does


   {move 1}

   >>> comment >>> comment allow us to >>> \
       define iterator functions .This is a nasty \
       higher


   {move 1}

   >>> comment >>> comment order induction \
       proof which should really put the system


   {move 1}

   >>> comment >>> comment through its paces \
       .I am beginning to master the discipline \
       of


   {move 1}

   >>> comment >>> comment scope needed to \
       set up bound variable expressions


   {move 1}

   >>> comment without binding any variables \
       .


   {move 1}

   >>> comment >>> comment I should add second \
       order Z F and Church' s simple theory \
       of types as a full


   {move 1}

   >>> comment demonstration of untyped and \
       typed object building capabilities .


   {move 1}

   >>> comment Church' s type theory


   {move 1}

   >>> comment one point type


   {move 1}

   >>> postulate One type


   One : type


   {move 0}

   >>> postulate Unique : in One


   Unique : in One


   {move 0}

   >>> declare xx1 in One


   xx1 : in One


   {move 1}

   >>> postulate Oneproof xx1 : that One \
       eqt xx1 Unique


   Oneproof : [(xx1_1 : in One) => (--- 
       : that eqt (One, xx1_1, Unique))]


   {move 0}

   >>> comment cartesian product >>> postulateion


   {move 1}

   >>> declare sigma type


   sigma : type


   {move 1}

   >>> postulate X tau sigma : type


   X : [(tau_1 : type), (sigma_1 : type) => 
       (--- : type)]


   {move 0}

   >>> declare xt in tau


   xt : in tau


   {move 1}

   >>> declare ys in sigma


   ys : in sigma


   {move 1}

   >>> postulate pair tau sigma xt ys : in \
       tau X sigma


   pair : [(tau_1 : type), (sigma_1 
       : type), (xt_1 : in tau_1), (ys_1 
       : in sigma_1) => (--- : in tau_1 
       X sigma_1)]


   {move 0}

   >>> declare zp in tau X sigma


   zp : in tau X sigma


   {move 1}

   >>> postulate pi1 tau sigma zp : in tau


   pi1 : [(tau_1 : type), (sigma_1 : type), (zp_1 
       : in tau_1 X sigma_1) => (--- : in 
       tau_1)]


   {move 0}

   >>> postulate pi2 tau sigma zp : in sigma


   pi2 : [(tau_1 : type), (sigma_1 : type), (zp_1 
       : in tau_1 X sigma_1) => (--- : in 
       sigma_1)]


   {move 0}

   >>> postulate Xexact tau sigma zp : that \
       (tau X sigma) eqt zp, pair tau sigma \
       (pi1 tau sigma zp) (pi2 tau sigma zp)


   Xexact : [(tau_1 : type), (sigma_1 
       : type), (zp_1 : in tau_1 X sigma_1) => 
       (--- : that eqt (tau_1 X sigma_1, zp_1, pair 
       (tau_1, sigma_1, pi1 (tau_1, sigma_1, zp_1), pi2 
       (tau_1, sigma_1, zp_1))))]


   {move 0}

   >>> comment power set type >>> postulateor \
       (use this to build bool from one point \
       type)


   {move 1}

   >>> postulate Pow tau type


   Pow : [(tau_1 : type) => (--- : type)]


   {move 0}

   >>> open


      {move 2}

      >>> declare xt2 in tau


      xt2 : in tau


      {move 2}

      >>> postulate tausub xt2 : prop


      tausub : [(xt2_1 : in tau) => (--- 
          : prop)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Setc tau tausub : in Pow \
       tau


   Setc : [(tau_1 : type), (tausub_1 
       : [(xt2_2 : in tau_1) => (--- : prop)]) => 
       (--- : in Pow (tau_1))]


   {move 0}

   >>> declare Ac in Pow tau


   Ac : in Pow (tau)


   {move 1}

   >>> postulate Ec tau xt Ac : prop


   Ec : [(tau_1 : type), (xt_1 : in 
       tau_1), (Ac_1 : in Pow (tau_1)) => 
       (--- : prop)]


   {move 0}

   >>> declare ev1 that tausub xt


   ev1 : that tausub (xt)


   {move 1}

   >>> declare ev2 that tau Ec xt tau Setc \
       tausub


   ev2 : that Ec (tau, xt, tau Setc tausub)


   {move 1}

   >>> postulate Compc1 tau xt, tausub, ev1 \
       : that tau Ec xt tau Setc tausub


   Compc1 : [(tau_1 : type), (xt_1 : in 
       tau_1), (tausub_1 : [(xt2_2 : in 
          tau_1) => (--- : prop)]), (ev1_1 
       : that tausub_1 (xt_1)) => (--- 
       : that Ec (tau_1, xt_1, tau_1 Setc 
       tausub_1))]


   {move 0}

   >>> postulate Compc2 tau xt, tausub, ev2 \
       : that tausub xt


   Compc2 : [(tau_1 : type), (xt_1 : in 
       tau_1), (tausub_1 : [(xt2_2 : in 
          tau_1) => (--- : prop)]), (ev2_1 
       : that Ec (tau_1, xt_1, tau_1 Setc 
       tausub_1)) => (--- : that tausub_1 
       (xt_1))]


   {move 0}

   >>> declare Bc in Pow tau


   Bc : in Pow (tau)


   {move 1}

   >>> open


      {move 2}

      >>> declare xt1 in tau


      xt1 : in tau


      {move 2}

      >>> declare xtina1 that tau Ec xt1 \
          Ac


      xtina1 : that Ec (tau, xt1, Ac)


      {move 2}

      >>> postulate aincb xt1 xtina1 : that \
          tau Ec xt1 Bc


      aincb : [(xt1_1 : in tau), (xtina1_1 
          : that Ec (tau, xt1_1, Ac)) => 
          (--- : that Ec (tau, xt1_1, Bc))]


      {move 1}

      >>> declare xtinb1 that tau Ec xt1 \
          Bc


      xtinb1 : that Ec (tau, xt1, Bc)


      {move 2}

      >>> postulate binca xt1 xtinb1 : that \
          tau Ec xt1 Ac


      binca : [(xt1_1 : in tau), (xtinb1_1 
          : that Ec (tau, xt1_1, Bc)) => 
          (--- : that Ec (tau, xt1_1, Ac))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Extc tau Ac Bc, aincb, binca \
       : that (Pow tau) eqt Ac Bc


   Extc : [(tau_1 : type), (Ac_1 : in 
       Pow (tau_1)), (Bc_1 : in Pow (tau_1)), (aincb_1 
       : [(xt1_2 : in tau_1), (xtina1_2 
          : that Ec (tau_1, xt1_2, Ac_1)) => 
          (--- : that Ec (tau_1, xt1_2, Bc_1))]), (binca_1 
       : [(xt1_2 : in tau_1), (xtinb1_2 
          : that Ec (tau_1, xt1_2, Bc_1)) => 
          (--- : that Ec (tau_1, xt1_2, Ac_1))]) => 
       (--- : that eqt (Pow (tau_1), Ac_1, Bc_1))]


   {move 0}

   >>> comment arrow type >>> postulateor


   {move 1}

   >>> postulate ==> tau sigma : type


   ==>: [(tau_1 : type), (sigma_1 : type) => 
       (--- : type)]


   {move 0}

   >>> open


      {move 2}

      >>> declare var in tau


      var : in tau


      {move 2}

      >>> postulate lambdabody var : in sigma


      lambdabody : [(var_1 : in tau) => 
          (--- : in sigma)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Lambda tau sigma lambdabody \
       : in tau ==> sigma


   Lambda : [(tau_1 : type), (sigma_1 
       : type), (lambdabody_1 : [(var_2 
          : in tau_1) => (--- : in sigma_1)]) => 
       (--- : in tau_1 ==> sigma_1)]


   {move 0}

   >>> declare Fc in tau ==> sigma


   Fc : in tau ==> sigma


   {move 1}

   >>> declare Gc in tau ==> sigma


   Gc : in tau ==> sigma


   {move 1}

   >>> declare xt2 in tau


   xt2 : in tau


   {move 1}

   >>> postulate Applyc tau sigma Fc, xt2 \
       : in sigma


   Applyc : [(tau_1 : type), (sigma_1 
       : type), (Fc_1 : in tau_1 ==> sigma_1), (xt2_1 
       : in tau_1) => (--- : in sigma_1)]


   {move 0}

   >>> postulate Beta tau sigma lambdabody, xt2 \
       : that sigma eqt Applyc tau sigma (Lambda \
       tau sigma lambdabody) xt2 lambdabody \
       xt2


   Beta : [(tau_1 : type), (sigma_1 
       : type), (lambdabody_1 : [(var_2 
          : in tau_1) => (--- : in sigma_1)]), (xt2_1 
       : in tau_1) => (--- : that eqt (sigma_1, Applyc 
       (tau_1, sigma_1, Lambda (tau_1, sigma_1, lambdabody_1), xt2_1), lambdabody_1 
       (xt2_1)))]


   {move 0}

   >>> comment There remains extensionality \
       for arrow types


   {move 1}

   >>> open


      {move 2}

      >>> declare xt3 in tau


      xt3 : in tau


      {move 2}

      >>> postulate sameval xt3 : that sigma \
          eqt (Applyc tau sigma Fc xt3) (Applyc \
          tau sigma Gc xt3)


      sameval : [(xt3_1 : in tau) => (--- 
          : that eqt (sigma, Applyc (tau, sigma, Fc, xt3_1), Applyc 
          (tau, sigma, Gc, xt3_1)))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Extfnc tau sigma Fc Gc sameval \
       : that (tau ==> sigma) eqt Fc Gc


   Extfnc : [(tau_1 : type), (sigma_1 
       : type), (Fc_1 : in tau_1 ==> sigma_1), (Gc_1 
       : in tau_1 ==> sigma_1), (sameval_1 
       : [(xt3_2 : in tau_1) => (--- : that 
          eqt (sigma_1, Applyc (tau_1, sigma_1, Fc_1, xt3_2), Applyc 
          (tau_1, sigma_1, Gc_1, xt3_2)))]) => 
       (--- : that eqt (tau_1 ==> sigma_1, Fc_1, Gc_1))]


   {move 0}

   >>> comment add dependent product and \
       dependent function types, which


   {move 1}

   >>> comment allow internalization of abstraction \
       sorts of the Lestrade framework .


   {move 1}

   >>> comment declarations for dependent \
       types


   {move 1}

   >>> open


      {move 2}

      >>> declare ys5 in tau


      ys5 : in tau


      {move 2}

      >>> postulate Rhofun ys5 : type


      Rhofun : [(ys5_1 : in tau) => (--- 
          : type)]


      {move 1}

      >>> close


   {move 1}

   >>> comment dependent product >>> postulateion


   {move 1}

   >>> postulate Xx tau Rhofun : type


   Xx : [(tau_1 : type), (Rhofun_1 : [(ys5_2 
          : in tau_1) => (--- : type)]) => 
       (--- : type)]


   {move 0}

   >>> declare xt5 in tau


   xt5 : in tau


   {move 1}

   >>> declare ys5 in Rhofun xt5


   ys5 : in Rhofun (xt5)


   {move 1}

   >>> postulate paird tau Rhofun, xt5 ys5 \
       : in tau Xx Rhofun


   paird : [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]), (xt5_1 
       : in tau_1), (ys5_1 : in Rhofun_1 
       (xt5_1)) => (--- : in tau_1 Xx 
       Rhofun_1)]


   {move 0}

   >>> declare zp5 in tau Xx Rhofun


   zp5 : in tau Xx Rhofun


   {move 1}

   >>> postulate Pi1 tau Rhofun, zp5 : in \
       tau


   Pi1 : [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]), (zp5_1 
       : in tau_1 Xx Rhofun_1) => (--- : in 
       tau_1)]


   {move 0}

   >>> postulate Pi2 tau Rhofun, zp5 : in \
       Rhofun (Pi1 tau Rhofun, zp5)


   Pi2 : [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]), (zp5_1 
       : in tau_1 Xx Rhofun_1) => (--- : in 
       Rhofun_1 (Pi1 (tau_1, Rhofun_1, zp5_1)))]


   {move 0}

   >>> postulate Xxexact tau Rhofun, zp5 \
       : that (tau Xx Rhofun) eqt zp5, paird \
       tau Rhofun, (Pi1 tau Rhofun, zp5) (Pi2 \
       tau Rhofun, zp5)


   Xxexact : [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]), (zp5_1 
       : in tau_1 Xx Rhofun_1) => (--- : that 
       eqt (tau_1 Xx Rhofun_1, zp5_1, paird 
       (tau_1, Rhofun_1, Pi1 (tau_1, Rhofun_1, zp5_1), Pi2 
       (tau_1, Rhofun_1, zp5_1))))]


   {move 0}

   >>> comment dependent function type >>> \
       postulateor


   {move 1}

   >>> postulate ==>> tau Rhofun : type


   ==>>: [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]) => 
       (--- : type)]


   {move 0}

   >>> open


      {move 2}

      >>> declare var in tau


      var : in tau


      {move 2}

      >>> postulate lambdabodyd var : in \
          Rhofun var


      lambdabodyd : [(var_1 : in tau) => 
          (--- : in Rhofun (var_1))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Lambdad tau Rhofun, lambdabodyd \
       : in tau ==>> Rhofun


   Lambdad : [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]), (lambdabodyd_1 
       : [(var_2 : in tau_1) => (--- : in 
          Rhofun_1 (var_2))]) => (--- 
       : in tau_1 ==>> Rhofun_1)]


   {move 0}

   >>> declare Fd in tau ==>> Rhofun


   Fd : in tau ==>> Rhofun


   {move 1}

   >>> declare Gd in tau ==>> Rhofun


   Gd : in tau ==>> Rhofun


   {move 1}

   >>> declare xt6 in tau


   xt6 : in tau


   {move 1}

   >>> postulate Applyd tau Rhofun, Fd, xt6 \
       : in Rhofun xt6


   Applyd : [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]), (Fd_1 
       : in tau_1 ==>> Rhofun_1), (xt6_1 
       : in tau_1) => (--- : in Rhofun_1 
       (xt6_1))]


   {move 0}

   >>> postulate Betad tau Rhofun, lambdabodyd, xt6 \
       : that (Rhofun xt6) eqt Applyd tau Rhofun, (Lambdad \
       tau Rhofun, lambdabodyd) xt6 lambdabodyd \
       xt6


   Betad : [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]), (lambdabodyd_1 
       : [(var_2 : in tau_1) => (--- : in 
          Rhofun_1 (var_2))]), (xt6_1 
       : in tau_1) => (--- : that eqt (Rhofun_1 
       (xt6_1), Applyd (tau_1, Rhofun_1, Lambdad 
       (tau_1, Rhofun_1, lambdabodyd_1), xt6_1), lambdabodyd_1 
       (xt6_1)))]


   {move 0}

   >>> comment There remains extensionality \
       for arrow types


   {move 1}

   >>> open


      {move 2}

      >>> declare xt7 in tau


      xt7 : in tau


      {move 2}

      >>> postulate samevald xt7 : that (Rhofun \
          xt7) eqt (Applyd tau Rhofun, Fd \
          xt7) (Applyd tau Rhofun, Gd xt7)


      samevald : [(xt7_1 : in tau) => 
          (--- : that eqt (Rhofun (xt7_1), Applyd 
          (tau, Rhofun, Fd, xt7_1), Applyd 
          (tau, Rhofun, Gd, xt7_1)))]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Extfnd tau Rhofun, Fd Gd \
       samevald : that (tau ==>> Rhofun) eqt \
       Fd Gd


   Extfnd : [(tau_1 : type), (Rhofun_1 
       : [(ys5_2 : in tau_1) => (--- : type)]), (Fd_1 
       : in tau_1 ==>> Rhofun_1), (Gd_1 
       : in tau_1 ==>> Rhofun_1), (samevald_1 
       : [(xt7_2 : in tau_1) => (--- : that 
          eqt (Rhofun_1 (xt7_2), Applyd 
          (tau_1, Rhofun_1, Fd_1, xt7_2), Applyd 
          (tau_1, Rhofun_1, Gd_1, xt7_2)))]) => 
       (--- : that eqt (tau_1 ==>> Rhofun_1, Fd_1, Gd_1))]


   {move 0}

   >>> comment >>> comment further remarks \
       about internalization : Pow One


   {move 1}

   >>> comment >>> comment implements prop \
       .Then all the propositional operations


   {move 1}

   >>> comment >>> comment correspond to \
       type >>> postulateors just given, with \
       all types


   {move 1}

   >>> comment that p actually being identified \
       with either One or Empty .


   {move 1}

   >>> postulate Empty : type


   Empty : type


   {move 0}

   >>> declare xnot in Empty


   xnot : in Empty


   {move 1}

   >>> postulate notthere xnot : that ??


   notthere : [(xnot_1 : in Empty) => 
       (--- : that ??)]


   {move 0}

   >>> comment >>> comment this means that \
       the entire logical framework can


   {move 1}

   >>> comment >>> comment be internalized, at \
       least in its classical version :


   {move 1}

   >>> comment >>> comment the full type \
       system of abstraction sorts


   {move 1}

   >>> comment can be studied internally \
       to Lestrade .


   {move 1}
end Lestrade execution

(* quit *)
