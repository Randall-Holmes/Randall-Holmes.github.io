
















\documentclass[12pt]{article}

\title{A concrete approach to mathematics?}

\author{M. Randall Holmes}

\begin{document}

\maketitle

In this essay we consider a view of the modern mathematics of the continuous and the infinite which views the objects and the arguments of mathematics as objects which can be concretely presented as inhabitants of data types representable in practice on a computer.   We illustrate this using actual general purpose software with this aim.

The software we use is called the Lestrade Type Inspector, implementing a formal system called Lestrade.  We will initially present Lestrade code in contexts where it is clear what it does.  A formal description will eventually appear.

The ontology for mathematics (and mathematical arguments) that we employ is typed.  Mathematical objects do come in kinds.  Both new objects and new sorts of objects can be introduced in Lestrade theory development, as we will see.

We begin with logic.

\begin{verbatim}

begin Lestrade execution

   >>> declare A prop


   A : prop


   {move 1}

   >>> declare B prop


   B : prop


   {move 1}
end Lestrade execution

\end{verbatim}

This document is among other things a Lestrade script.  The commands behind {\tt >>>} were typed in by the author, but the responses were generated by the Inspector.  Here we have declared variable parameters $A$ and $B$ of type {\tt prop}.
The type {\tt prop} is one of the few Lestrade built-ins, the type of propositions.

Now we will introduce a logical primitive.  Notice that the operation of conjunction, which we are about to introduce, though certainly foundational, is not a built-in of Lestrade:  Lestrade is working at an even more basic level (which supports introduction of different logics with different rules, for example).

\begin{verbatim}

begin Lestrade execution

   >>> postulate & A B prop


   & : [(A_1 : prop), (B_1 : prop) => 
       (--- : prop)]


   {move 0}
end Lestrade execution
\end{verbatim}

We postulate an operation \& which takes two proposition arguments and has proposition output.  This is not enough of course to tell us that this operation is conjunction (``and").

\begin{verbatim}

begin Lestrade execution

   >>> declare aa that A


   aa : that A


   {move 1}

   >>> declare bb that B


   bb : that B


   {move 1}

   >>> declare cc that A & B


   cc : that A & B


   {move 1}
end Lestrade execution

\end{verbatim}

With each proposition $p$ (object of type {\tt prop}) we associate a new type {\tt that} $p$, which is inhabited by evidence for $p$ (one could say, by proofs of $p$, but there is some philosophical objection to this).  In any case, if there is
an object of type {\tt that} $p$, it is to be understood that $p$ is true.

The use of these special types will become evident.

One should also notice that Lestrade understands infix notation $A \& B$.

\newpage

\begin{verbatim}

begin Lestrade execution

   >>> postulate Simp1 cc that A


   Simp1 : [(.A_1 : prop), (.B_1 : prop), (cc_1 
       : that .A_1 & .B_1) => (--- : that 
       .A_1)]


   {move 0}

   >>> postulate Simp2 cc that B


   Simp2 : [(.A_1 : prop), (.B_1 : prop), (cc_1 
       : that .A_1 & .B_1) => (--- : that 
       .B_1)]


   {move 0}

   >>> postulate Conj aa bb that A & B


   Conj : [(.A_1 : prop), (.B_1 : prop), (aa_1 
       : that .A_1), (bb_1 : that .B_1) => 
       (--- : that .A_1 & .B_1)]


   {move 0}
end Lestrade execution

\end{verbatim}

We claim that the text above (which requires a little reading) tells us that \& actually is something like logical conjunction.

The function {\tt Simp1} takes an argument which is evidence for$A \wedge B$ (switching over to more usual notation for ``and'') and returns a value which is evidence for $A$.  This is one of the versions of the rule of simplification.  {\tt Simp2}, the other flavor of simplification, takes evidence for $A \wedge B$ as input and output evidence for $B$.

The function {\tt Conj} takes as arguments evidence for $A$ and evidence for $B$ and returns evidence for $A\wedge B$:  this can reasonably be taken to implement the rule of conjunction.

Our description is an oversimplification which Lestrade supports:  if you look at the type information about {\tt Conj} for example, it actually takes four arguments, $A$ of type {\tt prop}, $B$ of type {\tt prop}, {\tt aa} of type {\tt that} $A$ and
{\tt bb} of type {\tt that} $B$.   The underlying type system of Lestrade is a system of dependent types, in which the type of an argument to a function may depend on the types of earlier arguments.   The arguments $A$ and $B$ are needed in a formal sense, but deducible from the explicitly given arguments.

We exhibit some evidence that we have captured at least part of the logic of ``and".

\begin{verbatim}

begin Lestrade execution

   >>> define Reverseconj cc : Conj Simp2 \
       cc Simp1 cc


   Reverseconj : [(.A_1 : prop), (.B_1 
       : prop), (cc_1 : that .A_1 & .B_1) => 
       ({def} Simp2 (cc_1) Conj Simp1 (cc_1) : that 
       .B_1 & .A_1)]


   Reverseconj : [(.A_1 : prop), (.B_1 
       : prop), (cc_1 : that .A_1 & .B_1) => 
       (--- : that .B_1 & .A_1)]


   {move 0}
end Lestrade execution


\end{verbatim}

We introduced objects and operations before by declaration of parameters and postulation of operations with given input and output types.  Here we introduce a further way to introduce objects or (as in this case) operations, by explicit definition.  Lestrade accepts the name of the defined operation, the parameters of the operation (already defined, so we know their types) and the expression for the body of the definition.  Lestrade checks that the body of the definition is well typed and computes its type.

In this case, the object we have defined is the rule which allows us to deduce $B \wedge A$ from $A \wedge B$.

The rule is perfectly general in its applicability as we illustrate.

\newpage

\begin{verbatim}

begin Lestrade execution

   >>> declare C prop


   C : prop


   {move 1}

   >>> declare dd that A & (B & C)


   dd : that A & B & C


   {move 1}

   >>> define test dd : Reverseconj dd


   test : [(.A_1 : prop), (.B_1 : prop), (.C_1 
       : prop), (dd_1 : that .A_1 & .B_1 
       & .C_1) => 
       ({def} Reverseconj (dd_1) : that 
       (.B_1 & .C_1) & .A_1)]


   test : [(.A_1 : prop), (.B_1 : prop), (.C_1 
       : prop), (dd_1 : that .A_1 & .B_1 
       & .C_1) => (--- : that (.B_1 & .C_1) & .A_1)]


   {move 0}
end Lestrade execution

\end{verbatim}

Having shown the validity of the rule ``from $A \wedge B$ deduce $B \wedge A$ is not the same thing as proving the
statement ``if $A \wedge B$ then $B \wedge A$, for which our notation is $A \wedge B \rightarrow B \wedge A$, though one feels there is a relationship.  In fact, our way of implementing implication will bring out the relationship.

\begin{verbatim}

begin Lestrade execution

   >>> postulate -> A B prop


   -> : [(A_1 : prop), (B_1 : prop) => 
       (--- : prop)]


   {move 0}

   >>> declare imp that A -> B


   imp : that A -> B


   {move 1}

   >>> postulate Mp imp aa that B


   Mp : [(.A_1 : prop), (.B_1 : prop), (aa_1 
       : that .A_1), (imp_1 : that .A_1 
       -> .B_1) => (--- : that .B_1)]


   {move 0}
end Lestrade execution

\end{verbatim}

In the block of Lestrade code above, we declare implication, an operation on two propositions which returns a proposition, and
declare the possibly familiar rule of {\tt modus ponens\/}, ``from $A$ and $A \rightarrow B$, deduce $B$".

The other rule of implication requires more attention because it brings in essentially new Lestrade features.

\begin{verbatim}

begin Lestrade execution

   >>> open


      {move 2}

      >>> declare aa2 that A


      aa2 : that A


      {move 2}

      >>> postulate ded1 aa2 that B


      ded1 : [(aa2_1 : that A) => (--- 
          : that B)]


      {move 1}

      >>> close


   {move 1}

   >>> postulate Ded1 ded1 that A -> B


   Ded1 : [(.A_1 : prop), (.B_1 : prop), (ded1_1 
       : [(aa2_2 : that .A_1) => (--- 
          : that .B_1)]) => (--- : that 
       .A_1 -> .B_1)]


   {move 0}
end Lestrade execution

\end{verbatim}

{\tt Ded1} implements the rule of deduction:  if we can show that assuming $A$ allows us to prove $B$, then we have proved $A \rightarrow B$.

In terms of the metaphysics of Lestrade, we have expressed this by postulating a function which takes implicit arguments $A,B$ and an explicit argument which is a function taking evidence for $A$ to evidence for $B$.  If I suppose $A$ I am postulating evidence for it, to which I can apply this function to get evidence for $B$.

The way in which the parameter {\tt ded1} is declared is a bit esoteric, our first introduction to local environments in Lestrade,  of which more examples will be given soon with more comment, and a full explanation a bit later.  There is a briefer way to make the same declaration.

\begin{verbatim}

begin Lestrade execution

   >>> declare ded [aa => that B]


   ded : [(aa_1 : that A) => (--- : that 
       B)]


   {move 1}

   >>> postulate Ded ded that A -> B


   Ded : [(.A_1 : prop), (.B_1 : prop), (ded_1 
       : [(aa_2 : that .A_1) => (--- : that 
          .B_1)]) => (--- : that .A_1 
       -> .B_1)]


   {move 0}
end Lestrade execution

\end{verbatim}

Here we just declare the parameter {\tt ded} of the type which takes an argument which is evidence for $A$ to evidence for $B$ and postulate {\tt Ded}, which takes a function of that type as argument and returns evidence for $A \rightarrow B$.

\begin{verbatim}

begin Lestrade execution

   >>> open


      {move 2}

      >>> declare cc2 that A & B


      cc2 : that A & B


      {move 2}

      >>> define andcommev cc2 : Reverseconj \
          cc2


      andcommev : [(cc2_1 : that A & B) => 
          (--- : that B & A)]


      {move 1}

      >>> close


   {move 1}

   >>> define Andrev A B : Ded andcommev


   Andrev : [(A_1 : prop), (B_1 : prop) => 
       ({def} Ded ([(cc2_2 : that A_1 
          & B_1) => 
          ({def} Reverseconj (cc2_2) : that 
          B_1 & A_1)]) : that (A_1 & B_1) -> 
       B_1 & A_1)]


   Andrev : [(A_1 : prop), (B_1 : prop) => 
       (--- : that (A_1 & B_1) -> B_1 & A_1)]


   {move 0}
end Lestrade execution

\end{verbatim}

\end{document}

(* quit *)
