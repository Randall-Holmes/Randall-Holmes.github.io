\documentclass[12pt]{article}

\title{Marcel Theorem Prover Lab}

\author{Dr. Holmes}

\date{9/9/2021}

\begin{document}

\maketitle

\section{Introduction to Marcel}

This is the lab manual with the first (and probably only) computer lab to be done with the Marcel prover in Math 189, Fall 2021.

Marcel is a computer program designed to manipulate arguments.

An argument is made up of a list of premises and a conclusion.  An argument is valid iff any assignment of values to variables which makes all the premises
true will also make the conclusion true.  Many of our logical rules are presented exactly as small valid arguments.

Marcel is designed to try to prove that arguments are valid.  Its basic commands transform a given argument into a single argument or a list of arguments
whose validity is equivalent to the validity of the original argument.  Marcel then displays each of these arguments in turn and invites the user to show that the argument is valid.  When it is done showing that one argument is valid, it will remember and display the next one that needs to be shown to be valid.

The list of commands that we use in the first lab is extremely short:

\begin{description}

\item[s:]  The {\bf s}  command has a single string as input, Marcel notation for a theorem to be proved.  An argument is constructed and displayed with no premises and the intended theorem as conclusion.

\item[r:]  The {\bf r} (for {\bf Right}) command takes no inputs:  this command transforms
the argument we are working on by simplifying the conclusion in a way appropriate to its logical form (possibly producing two arguments to verify instead of one).

\item[l:]  The {\bf l} (for {\bf Left}) command takes no inputs.  This command transforms the argument we
are working on by simplifying the first premise in a way appropriate to its logical form (possibly producing two arguments to verify instead of one).

\item[gl:]  The {\bf gl} (for {\bf Getleft}) command takes a number as its input:  the number indicates which of the premises to bring to the front of the premise list (so as to be able to apply {\bf l}).

\item[d:]  The {\bf d} (for {\bf Done}) command takes no inputs.  When the first premise and the conclusion are the same, use of the {\bf d} command causes Marcel to record the current argument as valid, and the next one that we need to verify will be served up (or Marcel will say QED and report that the current theorem is proved!)

\end{description}

For propositional logic proofs, these are the only commands that are needed!

There are some other useful commands.  The final command is important for saving your work and sending it to me.

\begin{description}

\item[b:]  back up a step!

\item[L:]  display the argument you are currently looking at.  This might be useful after a Python error (Python errors will generally not hurt your proof at all, but they do fill the display with distracting red stuff).

\item[SA:]  Display an almost readable proof of what you have done so far.  When you have not finished the current theorem, it will display
a partial proof.

\item[SL:]  Use {\bf SL (filename)")} to create a log file.  This will be called {\tt (filename)logfile.py} and as you write Marcel commands
they will be recorded in the logfile, which can actually be run under Python to reassemble your proof.  Use {\bf SL done} to close your log file (this creates a dummy log file called {\bf donelogfile.py} of which we make no use).  When you are finished with a proof (when Marcel reports QED)
you might want to use the {\bf LP} command, which inserts the proof which would be shown by {\bf SA} into the log file as a comment.

\end{description}

We say something briefly about Marcel notation for propositional logic.  This is driven by the fact that we need to use characters found on the typewriter keyboard!
Negation is written $\sim$,  conjunction (and) is written \&, disjunction is written V (that is capital V and Marcel is case sensitive), implication is written
{\tt ->}, and the biconditional is written {\tt ==}.  Marcel has built-in order of operations:  the operations presented first in the list just given bind more tightly.
Implication and the biconditional group to the right, while conjunction and disjunction group to the left.  You can always supply extra parentheses if you are not sure how something groups;  Marcel will drop ones that it doesn't need.  Use single lower case letters followed immediately by a question mark as propositional variables.  We will supply completely
set up start commands with Marcel notation already written out for most exercises.

I will do extensive examples in class:  I am not going to try to embed the examples in this file at this point, though I may add them later.

Do the proofs in the exercises.  Make log files of your proofs and send them to me in email.  It is also acceptable to paste the contents of your Python window into a text file and mail that to me, but I prefer the log file because I can just run it in Python to see immediately that your work is correct.

\section{Exercises for Lab I on propositional logic}

\begin{enumerate}

\item Here are some examples with commands set up.

\begin{verbatim}

#Examples for you to try out

#s p?&(p?->q?)->q?

#s ((p?&q?)->r?)==(p?->(q?->r?))

#s p?Vq?== ~(~p?& ~q?)

\end{verbatim}

\item Set up the other deMorgan law in Marcel and prove it.

\item Show the validity of the rule of {\bf constructive dilemma}:  from $P \vee Q$, $P \rightarrow R$ and $Q \rightarrow S$, derive $R \vee S$.  To do this, you not only need to translate the 
notations for the individual propositions, but also write a single larger proposition to prove.  Hint:  the first example proof above is the sentence
that sets up a proof of the validity of the rule of modus ponens:  the conjunction of the premises implies the conclusion.

\item Carry out the proof starting with 

{\tt s p?Vq?)\&(r?V$\sim$p?)\&(s?V$\sim$q?)->(r?Vs?)}

Write out this theorem in standard propositional logic notation and write a paper proof.

\item (optional) {\tt s (a? == b?) == c?) == (a? == (b? == c?))}

\end{enumerate}

\section{Remarks on how Marcel works}

The ideas that Marcel is based on are closely parallel to the proof strategies in the manual of logical style.  What Marcel does is take an argument, and simplify it, presenting one or two arguments whose validity is equivalent to the validity of the original argument.

One comment which can be put here as well as anywhere is that it is the one line notation
$P_1, P_2, \ldots, P_n \vdash C$ motivates the names of Marcel rules:  premises appear on the left and conclusions on the right, and this is why the rules acting on premises are {\bf l} and {\bf gl}, and the rule acting on conclusions is {\bf r}.

\newpage

\subsection{Conjunction (and)}

Validity of

\begin{verbatim}

A & B

P2

P3

.
.
. 

Pn

--------

C

\end{verbatim}

is equivalent to validity of 

\newpage

\begin{verbatim}

A

B

P2

P3

.
.
. 

Pn

--------

C

\end{verbatim}

This corresponds to the strategy, if we have $A \wedge B$, we can deduce $A$ and $B$, for using a conjunction.

\newpage

Validity of 

\begin{verbatim}

P1

P2 

P3 
.
.
.

Pn

----------

A & B

\end{verbatim}

is equivalent to both of 

\begin{verbatim}

P1

P2 

P3 
.
.
.

Pn

----------

A

\end{verbatim}

and 

\begin{verbatim}

P1

P2 

P3 
.
.
.

Pn

----------

B

\end{verbatim}

being valid.  This corresponds to the strategy, to prove $A \wedge B$, first prove $A$, then prove $B$.

\newpage

\subsection{Disjunction (or)}

The validity of 

\begin{verbatim}

A V B

P2

P3

.
.
.

Pn

----------

C

\end{verbatim}

is equivalent to the validity of both

{\small \begin{verbatim}

A

P2

P3

.
.
.

Pn

----------

C

\end{verbatim}}

and

\begin{verbatim}

B

P2

P3

.
.
.

Pn

----------

C

\end{verbatim}

This corresponds precisely to the strategy of proof by cases for using the hypothesis $A \vee B$.

\newpage

The validity of 

\begin{verbatim}

P1

P2 

.
.
.

Pn

---------

A V B

\end{verbatim}

is equivalent to the validity of 

\begin{verbatim}

P1

P2 

.
.
.

Pn

~B  [apply double negation if possible]

---------

A

\end{verbatim}

This is equivalent to the strategy of alternative elimination for proving a disjunction $A \vee B$.

\newpage

\subsection{Negation}

The validity of

\begin{verbatim}

~A

P2

P3

.
.
.

Pn 

________

C

\end{verbatim}

is equivalent to the validity of
{\small 
\begin{verbatim}

P2

P3

.
.
.

Pn

~C [apply double negation if possible]

-------

A

\end{verbatim}}

This is equivalent to an application of the contrapositive and double negation:  it's an indirect
proof move converting proving $C$ given $\neg A$ to proving $A$ given $\neg C$.  Further, if C were itself
a negation $\neg D$, we would get just $D$ rather than $\neg \neg D$.  Note the same comment in
the rule for manipulation disjunctions as conclusions.

\newpage

Validity of 

\begin{verbatim}

P1

P2

.
.
.

Pn

------

~A


\end{verbatim}

is equivalent to validity of 

\begin{verbatim}

A

P1

P2

.
.
.

Pn

------

_|_


\end{verbatim}

This is the usual strategy of negation introduction:  to prove $\neg A$ assume $A$ and deduce the absurd $\perp$.

When this appears in Marcel, you will notice that the absurd symbol gets no line number.  When one of the rules
is applied that moves the negation of the conclusion into the premises, the special conclusion $\perp$ simply disappears
(a premise $\neg \perp$ has no content, it is simply true without conveying any information).

\newpage

\subsection{Implication (only if)}

Validity of 

{\small \begin{verbatim}

P1

P2

.
.
.

Pn

----------

A -> B

\end{verbatim}}

is equivalent to the validity of

{\small \begin{verbatim}

A

P1

P2

.
.
.

Pn

----------

B

\end{verbatim}}

This is equivalent to our direct strategy for proving an implication:  to prove $A \rightarrow B$, assume $A$ and prove $B$.

You may notice that we didn't put the rule for using an implication first.  That is because the form of this rule
in Marcel is a little unexpected.

The validity of

\begin{verbatim}

A -> B

P2

P3

.
.
.

Pn

---------

C

\end{verbatim}

is equivalent to validity of both

\newpage

{\small \begin{verbatim}

P2

P3

.
.
.

Pn

~C  [apply double negation if possible]

---------

A

\end{verbatim}}

and 

{\small \begin{verbatim}

B

P2

P3

.
.
.

Pn

---------

C

\end{verbatim}}

This is the rule of modus ponens in disguise.  The first part proves that either $A$ or $C$ follows from the
other premises.  The second part shows that if we assume $B$ and the other premises, we can deduce $C$.
Now do proof by cases on the first part:  if $C$ follows from just the other premises of course we are done;
otherwise, we deduce $A$ from the other premises, and then deduce $B$ by modus ponens from
$A$ and $A \rightarrow B$, and then the second part allows us to deduce $C$.

The reason it is different is that Marcel is committed for the most part to a strategy of manipulating one premise or conclusion at a time, and the usual form of {\em modus ponens\/} acts on two premises.

I am not at this point writing out the rules for the biconditional:  they will not be surprising to a student of my manual of style.
\end{document}