
<h1>The Loglan PEG Grammar</H1>



<tt>
<li>In this file I will develop the entire Loglan grammar on top of the phonetic proposal

<h2> PEG notation </H2>

<li>A PEG (Parsing Expression Grammar) is made up of lines of the form

<tt> class_name <- PEG  notation</TT>

<li>Each PEG notation describes a set of strings with conditions on the context in which they occur.<p>

<li>Concrete strings: <tt>'string'</TT> or <tt>"string"</TT> literally denotes the 6 character string given.<p>

<li>Classes of characters: <tt>[aeiou]</TT> describes the set of one character strings which are either
<li>a, e, i, o, or u.  Ranges can appear: <tt>[a-zA-z]</TT> describes the union of the sets of lower case letters and upper case letters, considered as one character strings.<p>

<li>If <tt>A</TT> and <tt>B</TT> are PEG notations, <tt>(A B)</TT> denotes a string of class <tt>A</TT> followed by a string of class <tt>B</TT> (in which the string of class <tt>A</TT> is the preferred string of this class read from the beginning of the source string).<p>

<li>If <tt>A</TT> and <tt>B</TT> are PEG notations, <tt>(A / B)</TT> denotes a string of either class <tt>A</TT> or a string of class <tt>B</TT>, with a string of class <tt>A</TT> being read by preference if possible.  The fact that a preference is indicated in alternative lists makes PEG reading deterministic (in a sense, there are no ambiguities for a PEG grammar).  The problem in a PEG corresponding to ambiguity in a BNF  grammar is incorrectly ordered lists of alternatives.<p>

<li>If <tt>A</TT> is a PEG notation, <tt>(A)?</TT> represents a string of class <tt>A</TT> (preferred) or an empty string if there is no string of class <tt>A</TT>:  this represents optional appearance of <tt>A</TT>.  <tt>(A)*</TT> represents zero or more consecutive strings of class <tt>A</TT> (as many as possible) and <tt>(A)+</TT> represents one or more consecutive such strings.<p>

<li>If <tt>A</TT> is a PEG notation, <tt>&(A)</TT> represents a length 0 string which is followed by a string of class <tt>A</TT>, and <tt>!(A)</TT> represents a length 0 string which is <B>not</B> followed by a string of class <tt>A</TT>.  This gives us powerful lookahead features:  for example, <tt>((A)! B</TT> represents a string of class <tt>B</TT> whose beginning is not also the beginning of a string of class
<li><tt>A</TT>:  it is tempting but not accurate to say that it does not have an initial segment of class <tt>A</TT>, because detection of a string of class <tt>A</TT> longer than the string of class <tt>B</TT> read would cause reading of this class to fail.<p>

<li>The period . represents the class of single characters (so !. is end of text).<p>

<li>New notations are introduced by lines <p>

<li><tt> class_name <- PEG  notation</TT>:<p>

<li>this is not just an abbreviation facility because such definitions may be mutually recursive.<p>

<li>A PEG notation applied to a source string will give either failure or a uniquely determined initial string of the source (parsed suitably); in a sense PEG is unambiguous.  What corresponds as an issue to ambiguity for a BNF grammar is
<li>inappropriate choice of order of alternatives in PEG disjunctions <tt>(A / B)</TT>:  what often represents a problem with a grammar is what I call <li><li><li>    <li>"preemption", where an earlier alternative reads an initial segment of a string where a later alternative could have read more of it.<p>

<li>It's possible to have a PEG go into an infinite loop and fail to produce a parse.  My PEG generator has a termination checker, so the Loglan grammar does not have these problems.  I have contemplated writing a preemption checker, but this is a rather difficult problem.<p>

<p>

<h2>Dated updates now to appear here</H2>

<p>

<li> 1/31/2022 removes a lot of use of literal characters by defining rules sp and stress2.  Corrects some minor errors in literal character lists.

<p>

<li>a note, not reflecting a modification.  I'm wondering whether the pause required in [fo tonira] ([fotonira] means something quite
<li>different) should be a mandatory comma pause.  It looks as if it might not be hard to implement.

<li>

<p>  No modification as yet:  I am thinking of banning JIO followed by an imperative.  JI should be used.

<p>
<li>  fixed a bug which broke the end of speech marker "#"
#p$

<li> 1/29/2022 Created wrapper classes so that parses which mix letters and grammar classes are avoided.  
<p>
<li> 1/29/2022 Also fixed a small bug in class headterms.  Fixed an apparent bug in class NameWord ([hue] was omitted)  which has never caused any identifiable trouble.

<p>

<li> 1/26/2022 complete elimination of the alternative parser and all constituent rules (including the word [gaa]) as I have abandoned this idea.

<li>a note:  there is a problem with interaction of quoted forms with alien text operators.
<p>
<li> 1/23/2022  made imperative important and cloned sentence and uttAx in versions which will not be marked as imperative if they lack subjects.  Considering simply forbidding jio clauses to contain no subject sentences, but this is not implemented (ji should be used).  Fixing the restriction on <ci> as a name marker to allow it to be followed by whitespace and a name.
<p>
<li>1/22/2022:  provisionally removing the requirement that the terms before the predicate in an SVO sentence contain no more than one untagged argument.
<li>The option of using the particle [gio] before any sutori untagged arguments before the predicate remains.<p>

<p>

<li>1/21/2022 Starting a literate programming exercise:  turn this document into HTML while preserving its performance as a PEG grammar.
#Also note that the alternative version is now turned off.  The only component present is [gaa] and I do not see a reason for anyone to use it.
#The alternative parser is readily turned back on by changing the line statement1x.  This version labels the default stressed syllable in a predicate in the PhoneticComplex parse.

<p>


<li>a serious problem with ICA, an actual ambiguity which has existed since the beginning of the language,
<li>hopefully fixed:  the fix is that an apparent ICA initial utterance which could without the period be
<li>a continuation of a sentence is read as such.  The important point is that there is no audible difference
<li>between comma followed by ICA and period followed by ICA:  we solve the problem by reading the latter
<li>as the former where possible.

<p>

<li>11/24/2021  KIA, the one "word" deletion operator, is installed.  What it actually does is a bit subtle.

<p>

<li>2/4/2021  Imposed the rule that two final consonants cannot be consonants from voiced/unvoiced pairs
<li>with different voice.  Also forbid second final consonant to be h.

<p>

<li>I have further fine-tuning of djifoa gluing in mind.
<li>Allow the -r glue to be expressed as
<li>-rr after all mandatory monosyllables, removing the annoying pronunciation problem?
<li>I was thinking of allowing -hy gluing in other contexts, but it is actually a bad idea.

<p>

<li>9/15/2019 installed semantic case tags with order distinctions for use with predicates with more than one argument of the same case.
<li>one solution is beucine, beucito...  another is beuzi, beuza, beuzu.

<p>


<li>4/28/2019  Various debugging of the new predicate algorithm.  Added CVVhy as a glued form for CVV djifoa.
<li>added capitalization of djifoa glue!  Confirming my apparent earlier decision that a CVV(h)y djifoa must be followed
<li>by a full predicate complex.

<p>

<li>4/26/2019:  this incorporates various revisions to the phonetics, correcting errors or clarifying rules,
<li>motivated by my development of the phonetics section of a new grammar document.  The one notable
<li>change is that [ci] is now only a name marker if followed by an explicit pause.  This only requires
<li>changes in writing in serial names.  In speech, it is recommended that one not pause after [ci]
<li>except before a name word.  The benefit is that non-serial-name related uses of [ci] no longer
<li>threaten mysterious needs to add explicit pauses before following name words.

<p>

<li>I want to add the [zao] proposal of John Cowan.  Done, 4/15/2019.  the imperative pronoun [koo] has been added though not officially.  I should also add [dao] for the dummy argument, but not today (it is in as of 4/18)

<p>

#4/25  Making note of the idea that [ci] should not be a name marker unless followed
<li>by a pause.  This would require that one pause before ci-marked names and it would
<li>remove some very confusing corrections for the false name marker problem.  If we
<li>required the pause to be explicit we would be imposing the expectation that whitespace
<li>after [ci] is not a pause.  Otherwise we could encourage writing a juncture after [ci]
<li>to deny presence of a pause, which is reasonable considering the meanings of [ci].
<li>I am implementing the version with explicit pauses between [ci] and names
<li>and the directive not to pause after [ci] without explicit indication.  This solution
<li>involves rewriting existing text only in the rare instances where [ci] precedes a name.

<p>

<li>4/25/2019  Corrected some instances of (expanded) badstress.  Now forbidding (C)VVVV initial predicates.  Probably I should use class badstress systematically in defining cmapua.

<p>

<li>4/24/2019  Final consonants in syllables cannot be followed by syllabic continuants.  
<li>this rationalizes the definition of SyllableA.

<p>

<li>4/22 I am thinking of explicitly flagging imperative sentences;  not changing
<li>the grammar but making this visible in the parse.  This might also have some
<li>effects on logical connections.  4/23 created an imperative class for atomic
<li>imperative sentences;  this has no actual effect on parses, just
<li>organizes them in a more enlightening way.

<p>

<li>4/17-18 2019:  updates commented out which make sentpred linkable with forethought
<li>and afterthought connectives (making some uses of [guu] to share arguments 
<li>unnecessary).  There are subtleties.  Basically, untensed predicates without
<li>argument lists will be linked by A and KA series connectives.  Such a linked
<li>set can be tensed as a whole.  Such a linked set will share a following termset.
<li>This will probably change many parses in the Visit and other legacy sources.
<li>This required some really subtle adjustments to work right, divinable from
<li>the actual rules given.  Definitely experimental.

<p>

<li>3/9/2019 further, extended LIU1 to handle [ainoi] and its kin
<li>(actual mod is to class Cmapua)  Further, fixing mismatch 
<li>between connective and A classes.  One does now have to pause
<li>before [ha] and its compounds.

<p>

<li>3/9/2019 repaired bugs in negative attitudinals.  A pause
<li>in a negative attitudinal of the [no, ui] form will not break
<li>it.  [ainoi] didnt work for two reasons:  the clauses
<li>in the definition of NOUI were in the wrong order, and
<li>the connective class mistakenly included [noi] so the 
<li>phonetics checker was crashing!  I had to move N and NOI 
<li>earlier to make this work.  Not yet installed in the other 
<li>version.

<p>

<li>1/26/2019  added [vie], JCB's "objective subjunctive" as a PA
<li>class word.  I should add this to the other file as well.

<p>

<li>12/22/18:  just a comment:  one does not have to pause before [ha] and its compounds.
<li>I do not know whether to fix this.  One did not have to in LIP either.  For the moment I will
<li>leave it as it is.  As a matter of style, one probably should pause.

<p>

<li>10/6/18  minor adjustments, made only in this file.  Allow [sujo] (a wicked thing to say).  Do not
<li>allow [futo]:  suffixed conversion operators must be nu + suffix.

<p>

<li>6/2 fixed LIO + alien text.  I also fixed some other glitches described in the reference grammar.

<p>

<li>5/11 making version without "alternative parser" features.  This version allows GAA but it doesn't
<li>do anything:  the definitions of argumentA and kin are the only point of difference.  Master version:
<li>becomes "alternative" by reinstating alternative definitions of argumentA and kin.  Further, made changes
<li>recommended in the reference grammar.  ALTERNATIVE -- this is actually my master version.  Edit
<li>this and revise the argumentA and kin entries to make the original version.

<p>

<li>4/24 discovered and repaired a bug re ci-marked names suffixed to descriptions.  Discovered a bug in numerical
<li>descriptions yet to be fixed:  [lio] needs to be an alien text marker, maybe taking double quotes.  The description-
<li>with-suffixed-name bug was actually quite gruesome.  I think it is repaired.

<p>

<li>4/23 streamlined definition of descriptn.  Shouldn't change anything.  It was remarkably tricky though;  preserving the old form
<li>in case of further trouble.

<p>

<li>4/22 I think this will be the  master grammar file, with alternative lines to turn off the 
<li>GAA-related features.  (1/21/2022, they are now turned off)

<p>

<li>4/22 allowing general predicates in gasent1.  This removes an extreme oddity in parsing of imperatives.
<li>I do not see any new dangers from this.

<p>

<li>4/22 I changed the final element of a keksent to be a sentence (new class uttA0), not a general sentence fragment.
<li>several parse errors in the Visit were uncovered by this.

<p>

<li>4/22:  note that I still have the obligation to restore the [zao] construction.

<p>

<li>4/9/2018 the large subject marker GAA can also be used to defend the beginnings of gasents and imperatives
<li>from absorbing trailing arguments into an unintended statement.  In this context [gaa] may be followed by [ga] ;-)

<p>

<li>4/8/2018 this is an alternative version in which an argument which starts an SVO sentence will not be accepted
<li>as a trailing argument of a previous sentence.  This allows neat termination of [lepo] clauses preceding
<li>a subject, for example.  Unlike the previous alternative approach, this seems to involve a single fairly
<li>tidy change:  it is all an issue of avoiding needs for explicit closure.  Further refinement:  SVO sentences
<li>can be marked with GAA (which is not a tense:  it appears optionally just before the predicate, or just
<li>before sutori arguments marked with GIO if there are any), the "large subject marker":  an argument which 
<li>starts an SVO sentence *not marked with GAA* will not be accepted as a trailing argument of a previous
<li>sentence.  This is a sufficiently complex grammar change that it requires thought:  it is not conservative
<li>in my usual sense.  The fact that GAA carries a mandatory stress is virtuous.  Its resemblance to the 
<li>particle GA when used as a tense is not a bad thing:  it would often be used instead of GA to close
<li>a [lepo] clause appearing as a subject, and it is perhaps better for that purpose.  Note that GAA can
<li>and often will be followed by a tense.  This grammar change depends strongly on the previous ruling that the O in
<li>SOV(O) sentences must be marked with [gio]:  S gio O^n V (O^m).

<p>

<li>nuu is an atomic A core and there is no nu-affix to A connectives and their kin

<li>1/20/2018 redefined CA cores to include a possible NU prefix. This allows more logically connected tenses, for example.

<p>

<li>1/13/2018 reorganized the internals of class PA in a way which should allow more things and not forbid anything legal now.
<li>this is pursuant on an analysis of the classes NI and PA as phrases, rather than words, as I start writing a global lexicography
<li>proposal document.  Enforced explicit pauses after PA phrases appearing as arguments with a following modifier with an argument.

<p>

<li>12/30/2017 fixed a problem with name markers in the clas NameWord and made a slight change to the new option in NI (names
<li>as dimensions).

<p>

<li>12/27/2017 installing an alternative treatment of acronyms under which they are simply names (suffix -n to acronyms in all uses).
<li>supporting this requires no change at all to acronymic name usage (just use the -n versions with the usual rules for names),
<li>and for dimension usage requires [mue] to be a name marker and support for [mue] PreName as an alternative suffix to NI.

<p>

<li>12/27/2017  Frivolously fooling with the capitalization conventions.  They ought to work better now...but I could have broken something.
<li>the main new idea was to require that a capitalized embedded letteral actually be followed by lowercase if it was preceded by lowercase
<li>(with the obvious exception for a letteral followed by a letteral).  Also changed the rules for diphthongs in cmapua to make all-caps
<li>legal for cmapua.  The general idea is that one can start with a capital letter and stay capitalized until one hits a lower case letter,
<li>at which point one can jump back up to caps only at a juncture (after which you can remain capitalized) or temporarily for a vowel
<li>after z- (after which lower case resumes) or an embedded literal (after which lowercase resumes).  The total effect is that this allows
<li>attested capitalization patterns in Loglan (including capitalization of embedded literals as in possessive articles and acronyms)
<li>and also allows all-caps for individual words (attested in Leith but suppressed in my version) and supports capitalization of components
<li>of names as in [la Beibi-Djein] (by artful use of syllable breaks:  Leith just has BeibiDjein, which does not work for me).

<p>

<li>12/26/2017  Installed [niu] (quotation of phonetically legal but so far non-Loglan words).  I did not make [niu] a name marker, so if one were to
<li>use it with names (where it isn't really appropriate), one would have to pause initially:  [niu, Djan].

<p>

<li>I note in this connection that quotation of names with li...lu remains limited, since names by themselves are not
<li>utterances:  one needs the [la].  I fixed this as an exception in the previous parser;  I may do it here or I may
<li>not, haven't decided.  Single name words can be quoted with [liu], of course, but not serial names.

<p>

<li>12/24/2017  Refined treatment of vowel pairs for Cvv-V cmapua units.  First 12/24 version rather disastrously
<li>broken:  this should be fixed!

<p>

<li>12/23/2017  This is now completely commented, with minor local exceptions to which I will return later.
<li>This document is the basis on which I will build all subsequent parsers, with due modifications to the comments.
<li>The Python PEG engine and preamble files contain commands for constructinging a Python parser from it directly.

<p>

<li>12/22/2017 major progress on commenting the grammar

<p>

<li>yet later 12/20:  no change in performance of the grammar, extensive commenting in the
<li>grammar section.  Considerable changes in arrangement:  for example, vocatives, inverse vocatives,
<li>and free modifiers are moved to a much earlier point.  I'm hoping to get a genuinely almost readable
<li>commented grammar...

<p>

<li>later 12/20  starting the process of commenting and editing the grammar, starting
<li>at basic sentence structures.  Notably rewrote the class [keksent] more compactly,
<li>one hopes with no actual effect on parses.

<p>

<li>12/20/2017  Do not require expression of pause after finally stressed cmapua before
<li>vowel initial predicate as a comma, since the initial vowel signals the pause anyway.  
<li>Allow final stress in names.  Fixed bug in CVVHiddenStress.  Prevented
<li>broken monosyllables in finally stressed CVV djifoa.  refinement of caprule

<p>

<li>12/19/2017 seem to have had a versioning failure and lost the fix which requires
<li>CVVy djifoa to be followed by complete complexes.  Restored.

<p>

<li>12/18/2017 fixed a bug in treatment of stressed syllables in recognizing predicate starts.  Also
<li>narrowed the generalized VCCV rule to allow more of the quite unlikely space of predicates with lots
<li>of vowels before the CC pair.  Probably they should be banned (and none have ever been proposed with
<li>more than three) but that rule is not the context in which to arbitrarily ban half of them.  Some cleanup
<li>of the display of parses, for which updated version of logicpreamble.py should also be uploaded. A refinement
<li>to class "connective" checking that apparent logical connectives are not initial segments of predicates.
<li>This has the effect of delaying the declaration of "connective" until after the declaration of
<li>"predstart".

<p>

<li>12/17/2017 further refinement of the 12/16 version:  a couple of bugs spotted.

<p>

<li>12/16/2017 There should be no change in parsing behavior, but the predstart ruleset is shorter
<li>and more intelligible, and I realized that Complex doesnt need a check for the anti-slinkui test
<li>(the requirement that certain initial CVC cmapua be y hypenated which replaces the slinkui test))
<li>at all:  the way predstart works already ensures that initial CV cmapua fall off in the excluded
<li>cases, the idea being that we test the front of a predicate without lookahead in all cases.  Also
<li>addressed the subtle point that one wasn't forced to pause after a predicate before following y
<li>(not likely to arise as a problem).

<p>


<li>12/14/2017  Corrected vowel grouping to avoid paradoxical vowel triples which are default
<li>grouped in a way which becomes illegal if made explicit.  SyllableA really should contain a final
<li>consonant:  the previous form was messing up vowel grouping.  Serious bug where end of djifoa
<li>and syllable resolution of a predicate may fail to agree.  I think I blocked this by ensuring that
<li>final djifoa are not followed by vowels.  Other fine tuning of the complex algorithm.  Also had
<li>to repair the check for CVCCCV and CVCCVV predicates.

<p>


<li>12/13/2017:  added kie ( utterance ) kiu to class LiQuote.  Did fine tuning to ensure
<li>that cmapua streams stop before [li] or [kie], that names can stop at double quotes or close
<li>parentheses, and that the capitalization rule ignores opening parentheses as well as double
<li>quotes.  One can now adorn li lu with quotes (on the inside) in a reasonable way
<li>and adorn kie kiu with parentheses (on the inside) in a reasonable way.  One cannot
<li>*replace* these words (or any words) with punctuation in my model of Loglan.  Also,
<li>updates to comments, and <li>(end of utterance) added as a marker of terminal punctuation.

<p>

<h2>Comments on the initial release of this grammar</H2>

<li>This is now done, in a first pass.  That is, the grammar is adapted and appears to work, more or less.
<li>What is needed is comments on the lexicography and the grammar...Phonetics has now pretty clearly been sorted
<li>from the grammar (there are some places where the phonetics accept grammar information with regard to punctuation).
<p>
<li>Alien text is now handled somewhat differently.  Some issues to do with quoting names are not finalized and have not been tested.
<p>
<li>I added -iy and -uy as VV forms allowed in general in cmapua but not in other words;  they are always monosyllabic.  What this
<li>immediately allows me to do is to give Y a name which is not phonetically irregular!  [ziy] is supported:  [yfi] is too, now.
<p>
<li>capitalization is roughly back to where it was in the original, but all-caps are allowed.
<p>
<li>acronyms are liable to be horrible.
<p>
<li>Fixed the recursion problem in a way which will not be visible in ordinary parses.  Streams of cmapua will always
<li>be broken at name or alien text markers (instead of using lookahead to check that we do not stand at the beginning
<li>of a name word  or alien text word).  The next cycle will then check for a name or alien text, and also check for
<li>badnamemarkers;  no lookahead is happening while a stream of cmapua is being read except checking for
<li>the markers of names and alien text.  This will change the way phonetic parses look (streams of cmapua will
<li>break (and sometimes resume) at name markers or alien text markers, but it will not change any grammatical
<li>parses.
<p>
<h2>Part I Phonetics</H2>

<li>Mod bugs, I have implemented all of Loglan phonetics as described in my proposal.  Borrowing djifoa are pretty tricky.
<p>
<li>I have now parsed all the words in the dictionary, and all single words of appropriate classes parse successfully.
<li>I have added alien text and quotation constructions which do not conform to these rules; so actually
<li>all Loglan text should parse,  mod some punctuation and capitalization issues.  The conventions for
<li>alien text here are not the same as those in the current provisional parser.
<p>
<li>I believe the conventions for forcing comma pauses before vowel initial cmapua and after names
<li>except in special contexts have been enforced.  In a full grammar, one probably would want
<li>to disable pauses before vowel initial letterals (done).  This grammar also does not support the lingering
<li>irregularities in acronyms (and won't).
<p>
<li>This grammar (in Part I) is entirely about phonetics:  all it does is parse text into names (with associated initial
<li>pauses or name markers), cmapua (qua unanalyzed streams of cmapua units), 
<li>borrowings and complexes, along with interspersed comma pauses and marks
<li>of terminal punctuation.  It does support conventions about where commas are required
<li>and a simple capitalization rule.  Streams of cmapua break when markers initial
<li>in other forms are encountered (and may in some cases resume when the markers
<li>are a deception).
<p>
<li>a likely locus for odd bugs is the group of predstartX rules which detect apparent cmapua which
<li>are actually preambles to predicates.  These are tricky! (and I did indeed find some lingering
<li>problems when I parsed the dictionary).  Another reason to watch this rule predstart
<li>is that it carries a lot of weight:  !predstart is used as a lightweight test
<li>that what follows is a cmapua (a point discussed in more detail later).
<p>
<li>In reviewing this, I think that very little is different from 1990's Loglan (the borrowing djifoa
<li>are post-1989 L1, but not my creation).  Some things add precision without making anything in 1990's Loglan incorrect.
<li>The requirement that syllabic consonants be doubled is new, and makes some 1990's Loglan names incorrect.
<li>The requirement that names resolve into syllables is new, and makes some 1990's Loglan names incorrect,
<li> usually because they end in three consonants.
<li>The rule restricting final consonant pairs from being noncontinuant/continuant is new, but
<li>  does not affect any actual predicate ever proposed.
<li>Enhancing the VccV rule to also forbid CVVV...ccV caused one predicate to be changed
<li> ([haiukre] became [haiukrre], and haiukre was a novelty anyway, using a new name for X in X-ray)
<li>The exact definition of syllables and use of syllable breaks and stress marks is new (the close comma
<li> was replaced with the hyphen, so Lo,is becomes Lo-is); but this does not make anything in 1990's Loglan
<li> incorrect, it merely increases precision and makes phonetic transcript possible.
<li>Forbidding doubled vowels in borrowings was new, was already approved, and caused us to change
<li> [alkooli] to [alkoholi].
<li>Formally allowing the CVccVV and CVcccV predicates without y-hyphens took a proposal in 2013 because
<li> Appendix H was careless in describing their abandonment of the slinkui test, but the dictionary
<li> makes it evident that this was their intent all along.  The slinkui test had already been
<li> abandoned in the 1990s.
<li>Formally abandoning qwx was already something that the dictionary workers in the 1990's were working
<li> on; we completed it.
<li>Allowing glottal stop in vowel pairs and forbidding it as an allophone of pause is a new phonetic
<li> feature in the proposal but not reflected in the parser, of course.   Alternative pronunciations of
<li> y and h and allowing h in final position are invisible or do not make any 1990's Loglan incorrect.
<li>Permitting false name markers in names was already afoot in the 1990's and the basic outlines of our
<li> approach were already in place.  The rule requiring explicit pauses between a name marker not starting
<li> a name word and the beginning of the next name word is new, but reflects something which was already
<li> a fact about 1990's Loglan pronunciation:  those pauses had to be made in speech
<li>(and in the 1990's they had no tools to do relevant computer tests)!  The requirement
<li> that names resolve into syllables restricts which literal occurrences of name markers are actually
<li> false name markers (the tail they induce in the name must itself resolve into syllables).
<li>Working out the full details of borrowing djifoa was interesting:  I'm not sure that I've done anything
<li> *new* there;  explicitly noting the stress shift in borrowing djifoa might be viewed as something
<li> new but it is a logical consequence of JCB's permission to pause after a borrowing djifoa, which contains
<li> explicit language about how it is to be stressed, and the
<li> final definition of a borrowing djifoa as simply a borrowing followed by -y.  The shift strikes
<li> me as a really good idea anyway, because it marks djifoa with a pause after it as phonetically different
<li> in an additional way other than ending with the very indistinct vowel y.  My rules as given here do not
<li> directly enforce the rule that a borrowing djifoa must be preceded by y but I think they indirectly
<li> enforce it in all or almost all cases:  the parser tries to read a borrowing djifoa before reading
<li> any other kind of djifoa, so it is hard to see how to deploy a short djifoa in such a way that it would
<li> fall off the head of a borrowing without using y.
<li>These phonetics do not support certain irregularities in acronyms.  We note that
<li>it is now allowed to insert [, mue] into an acronym, which would be necessary for example
<li>between a Ceo letteral and a following VCV letteral.
<p>

<h3>Sounds</H3>

<p>

<li> the sound of silence

<p>

sp <- [ ]+

<h4>Vowels</H4>
<p>
#all vowels
<p>
V1 <- [aeiouyAEIOUY]
<p>
#regular vowels
<p>
V2 <- [aeiouAEIOU]

<h3>Consonants</H3>
<p>
#consonants
<p>
C1 <- [bcdfghjklmnprstvzBCDFGHJKLMNPRSTVZ]
<p>
#consonants in voiced/unvoiced pairs
<p>
Cvoiced <- [bdgjvzBDGJVZ]
<p>
Cunvoiced <- [ptkcfsPTKCFS]
<p>
<li>bad voice pair (or pair second term of which is h)
<li>forbidden as pairs of final consonants
<p>
Badvoice <- (Cvoiced (Cunvoiced/[Hh])/Cunvoiced (Cvoiced/[Hh]))
<p>

<h4>Letters and capitalization</H4>
<li>letters
<p>
letter <- (![qwxQWX] [a-zA-Z])
<p>
<li>a capitalization convention which allows what our current one allows and also allows all-caps.
<li>if case goes down from upper case to lower case, it can only go back up in certain cases.  This
<li>does allow capitalization of initial segments of words.  There is a forward reference to the grammar
<li>in that free capitalization of embedded literals is permitted, and capitalization of vowels
<li>guarded with z in literals as in DaiNaizA.
<p>
lowercase <- (![qwx] [a-z])
<p>
uppercase <- (![QWX] [A-Z])
<p>
caprule <- [\"(]? &([z] V1 (!uppercase/&TAI0)/lowercase TAI0 (!uppercase/&TAI0)/!(lowercase uppercase).) letter (&([z] V1 (!uppercase/&TAI0)/lowercase TAI0 (!uppercase/&TAI0)/!(lowercase uppercase).) (letter/juncture))* !(letter/juncture)
<p>
<h4>Junctures:  syllable breaks and stresses</H4>

<li>syllable markers:  the hyphen is always medial so must be followed by a letter.
<li>the stress marks can be syllable final and word final.  A juncture is never followed
<li>by another juncture.

<p>
stress2 <- [\'*] 
<p>
juncture <- (([-] &letter)/stress2) !juncture
<p>
stress <- [\'*] !juncture



<h4>Terminal punctuations and general characters</H4>

<li>terminal punctuation

terminal <- ([.:?!;#])

<p>

<li>characters which can occur in words

<p>

character <- (letter/juncture)

<p>

<h3>Alien text</H3>

<li>to really get all Loglan text, we should add the alien text constructions and the markers of alien text,
<li>[lie], [lao], [sao], [sue] and certain quotations which violate the phonetic rules.

<p>

<li>we adopt the convention that all alien text may be but does not have to be enclosed in quotes.
<li>it needs to be understood that in quoted alien text, whitespace is understood as [, y,]; in the unquoted
<li>version this is shown explicitly.  This handling of alien text is taken from the final 1990's treatment
<li>of Linnaeans = foreign names, and extended by us to replace the impossible treatment of strong
<li>quotation in 1989 Loglan.

<p>

<li>this is a little different from what is allowed in the previous provisional parser, but similar.
<li>A difference is that all the alien text markers are allowed to be followed by the same sorts of alien text.

<p>

<li>the forms with [hoi] and [hue] are required to have following quotes in written form to avoid
<li>unintended parses, which otherwise become likely in case of typos in non-alien text cases.

<p>

AlienText <- ([,]? sp [\"] (![\"].)+ [\"]/ [,]? sp (![, ]!terminal .)+ ([,]? sp [Yy] [,]? sp (![, ]!terminal .)+)*)

<li> adding wrapper classes for alien text markers

<p>

HOIalien <-[Hh] [Oo] [Ii]

<p>

HUEalien <- [Hh][Uu] juncture? [Ee]

<p>

LIEalien <- [Ll] [Ii] juncture? [Ee]

<p>

LAOalien <- [Ll] [Aa] [Oo]

<p>

LIOalien <- [Ll] [Ii] juncture? [Oo]

<p>

SAOalien <- [Ss] [Aa] [Oo]

<p>

SUEalien <- [Ss] [Uu] juncture? [Ee]

<p>

AlienWord <- &caprule (HOIalien juncture? &([,]? sp [\"])/HUEalien juncture? &([,]? sp [\"]) / LIEalien juncture? /LAOalien juncture? /LIOalien  juncture? /SAOalien juncture?/SUEalien juncture?) AlienText

<p>

<li>while reading streams of cmapua, the parser will watch for the markers of alien text.

<p>

alienmarker <- ([Hh] [Oo] [Ii] juncture? &([,]? sp [\"])/[Hh][Uu] juncture? [Ee] juncture? &([,]? sp [\"]) / [Ll] [Ii] juncture? [Ee] juncture? /[Ll] [Aa] [Oo] juncture? /[Ll] [Ii] juncture? [Oo] juncture?  /[Ss] [Aa] [Oo] juncture?/[Ss] [Uu] juncture? [Ee] juncture?) !V1

<p>

<li>5/11/18 added [lio] as an alien text marker, to support numerals.

<p>

<li>the continuant consonants and the syllabic pairs they can form

<h3>Complex Vowel Forms</H3>

continuant <- [mnlrMNLR]

<p>

syllabic <- (([mM] [mM] !(juncture? [mM]))/([nN] [nN] !(juncture? [nN]))/([rR] [rR] !(juncture? [rR]))/([lL] [lL] !(juncture? [lL])))
<p>
<li>the obligatory monosyllables, and these syllables when broken by a usually bad syllable juncture.
<li>The i-final forms are not obligatory mono when followed by another i.

<p>

MustMono <- (([aeoAEO] [iI] ![iI]) /([aA] [oO]))

<p>

BrokenMono <- (([aeoAEO] juncture [iI] ![iI])/([aA] juncture [oO]))

<p>

<li>the obligatory and optional monosyllables.  Sequences of three of the same letter
<li>are averted.  Avoid formation of doubled i or u after ui or ui.

<p>

Mono <- (MustMono/([iI] !([uU] [uU]) V2)/([uU] !([iI] [iI]) V2))

<p>

<li>vowel pairs of the form found in cmapua and djifoa.
<li>(other than the special IY, UY covered in the cmapua rules)

<p>

<li>The mysterious prohibition controls a permitted phonetic exception in djifoa gluing.
<li>compua are never followed directly by vocalic continuants in any case.

<p>

VV <- !(!MustMono V2 juncture? V2 juncture? [Rr] [Rr]) (!BrokenMono V2 juncture? V2)

<p>

<li>the next vocalic unit to be chosen from a stream of vowels
<li>in a predicate or name.  This is different than in our Sources
<li>and formally described in the proposal.

<p>

NextVowels <- (MustMono/(V2 &MustMono)/Mono/!([Ii] juncture [Ii] V1) !([Uu] juncture [Uu] V1) V2)

<p>

<li>5/11/18 forbidding consonantal vowels to follow the same vowel.

<p>

<li>the doubled vowels that trigger the rule that one of them must be stressed

<p>

DoubleVowel <- (([aA] juncture? [aA])/([eE] juncture? [eE])/([oO] juncture? [oO])/([iI] juncture [iI])/([uU] juncture [uU])/[iI] [Ii] &[iI]/[Uu] [uU] &[uU])

<p>

<li>the mandatory "vowel" component of a syllable

<p>

Vocalic <- (NextVowels/syllabic/[Yy])

<p>

<h3>Complex Consonant Forms</H3>

<p>

<li>the permissible initial pairs of consonants, and the same pairs possibly
<li>broken by syllable junctures.

<p>

Initial <- (([Bb] [Ll])/([Bb] [Rr])/([Cc] [Kk])/([Cc] [Ll])/([Cc] [Mm])/([Cc] [Nn])/([Cc] [Pp])/([Cc] [Rr])/([Cc] [Tt])/([Dd] [Jj])/([Dd] [Rr])/([Dd] [Zz])/([Ff] [Ll])/([Ff] [Rr])/([Gg] [Ll])/([Gg] [Rr])/([Jj] [Mm])/([Kk] [Ll])/([Kk] [Rr])/([Mm] [Rr])/([Pp] [Ll])/([Pp] [Rr])/([Ss] [Kk])/([Ss] [Ll])/([Ss] [Mm]) /[Ss] [Nn]/([Ss] [Pp])/([Ss] [Rr])/([Ss] [Tt])/([Ss] [Vv])/([Tt] [Cc])/([Tt] [Rr])/([Tt] [Ss])/([Vv] [Ll])/([Vv] [Rr])/([Zz] [Bb])/([Zz] [Ll])/([Zz] [Vv]))

<p>

MaybeInitial <- (([Bb] juncture? [Ll])/([Bb]juncture?  [Rr])/([Cc]juncture?  [Kk])/([Cc] juncture? [Ll])/([Cc]juncture?  [Mm])/([Cc]juncture?  [Nn])/([Cc]juncture?  [Pp])/([Cc]juncture?  [Rr])/([Cc]juncture?  [Tt])/([Dd]juncture?  [Jj])/([Dd]juncture?  [Rr])/([Dd]juncture?  [Zz])/([Ff]juncture?  [Ll])/([Ff]juncture?  [Rr])/([Gg]juncture?  [Ll])/([Gg]juncture?  [Rr])/([Jj]juncture?  [Mm])/([Kk]juncture?  [Ll])/([Kk] juncture? [Rr])/([Mm]juncture?  [Rr])/([Pp]juncture?  [Ll])/([Pp]juncture?  [Rr])/([Ss]juncture?  [Kk])/([Ss]juncture?  [Ll])/([Ss] juncture? [Mm]) /[Ss] juncture? [Nn]/([Ss]juncture?  [Pp])/([Ss]juncture?  [Rr])/([Ss]juncture?  [Tt])/([Ss]juncture?  [Vv])/([Tt]juncture?  [Cc])/([Tt]juncture?  [Rr])/([Tt] juncture? [Ss])/([Vv]juncture?  [Ll])/([Vv]juncture?  [Rr])/([Zz]juncture?  [Bb])/([Zz] juncture? [Ll])/([Zz] juncture? [Vv]))

<p>

<li>the permissible initial consonant groups in a syllable.  Adjacent consonants should be initial pairs.
<li>The group should not overlap a syllabic pair.  Such a group is of course followed by a vocalic unit.

<p>

<li>this rule for initial consonant groups is stated in NB3.

<p>

<li>I forbid a three-consonant initial group to be followed by a syllabic pair.  This seems obvious.

<p>

InitialConsonants <- ((!syllabic C1 &Vocalic)/(!(C1 syllabic) Initial &Vocalic)/(&Initial C1 !(C1 syllabic) Initial !syllabic &Vocalic))

<p>

<li>the forbidden medial pairs and triples.  These are forbidden regardless of placement
<li>of syllable breaks.

<p>

<li>each of these is actually a single consonant followed by an initial, and the idea was to identify CVC-CCV junctions which
<li>would be hard to pronounce.  But the placement of the syllable break is not relevant to the exclusion of the sequence.
<li>Notice that the continuant syllabic pairs are excluded:  this prevents final consonants from being included in such pairs.

<p>

NoMedial2 <- (([Bb] juncture? [Bb])/([Cc] juncture? [Cc])/([Dd] juncture? [Dd])/([Ff] juncture? [Ff])/([Gg] juncture? [Gg])/([Hh] juncture? C1)/([Jj] juncture? [Jj])/([Kk] juncture? [Kk])/([Ll] juncture? [Ll])/([Mm] juncture? [Mm])/([Nn] juncture? [Nn])/([Pp] juncture? [Pp])/([Rr] juncture? [Rr])/([Ss] juncture? [Ss])/([Tt] juncture? [Tt])/([Vv] juncture? [Vv])/([Zz] juncture? [Zz])/([CJSZcjsz] juncture? [CJSZcjsz])/([Ff] juncture? [Vv])/([Kk] juncture? [Gg])/([Pp] juncture? [Bb])/([Tt] juncture? [Dd])/([FKPTfkpt] juncture? [JZjz])/([Bb] juncture? [Jj])/([Ss] juncture? [Bb]))

<p>

NoMedial3 <- (([Cc] juncture? [Dd] juncture? [Zz])/([Cc] juncture? [Vv] juncture? [Ll])/([Nn] juncture? [Dd] juncture? [Jj])/([Nn] juncture? [Dd] juncture? [Zz])/([Dd] juncture? [Cc] juncture? [Mm])/([Dd] juncture? [Cc] juncture? [Tt])/([Dd] juncture? [Tt] juncture? [Ss])/([Pp] juncture? [Dd] juncture? [Zz])/([Gg] juncture? [Tt] juncture? [Ss])/([Gg] juncture? [Zz] juncture? [Bb])/([Ss] juncture? [Vv] juncture? [Ll])/([Jj] juncture? [Dd] juncture? [Jj])/([Jj] juncture? [Tt] juncture? [Cc])/([Jj] juncture? [Tt] juncture? [Ss])/([Jj] juncture? [Vv] juncture? [Rr])/([Tt] juncture? [Vv] juncture? [Ll])/([Kk] juncture? [Dd] juncture? [Zz])/([Vv] juncture? [Tt] juncture? [Ss])/([Mm] juncture? [Zz] juncture? [Bb]))

<p>

<h3>The Syllable</H3>

<li>there are no formal rules about syllables as such in our Sources, which is odd since
<li>the definition of predicates depends on the placement of stresses on syllables.

<p>

<li>The first rule enforces the special point needed in complexes that
<li>a CVC syllable is preferred to a CV syllable where possible; we economically apply
<li>the same rule for default placement of syllable breaks everywhere, which is, with
<li>that exception, that the break comes as soon as possible.

<p>

<li>the SyllableB approach is taken if the following syllable would otherwise start with a syllabic pair.

<p>

<li>the reason for this approach is that if one syllabizes a well formed complex in this way...
<li>the syllable breaks magically fall on the djifoa boundaries.  This does mean that the
<li>default break in [cabro] is [cab-ro], which feels funny but is harmless.  Explicitly breaking
<li>it [ca-bro] will also parse correctly.

<p>

SyllableA <- (C1 V2 FinalConsonant (!Syllable FinalConsonant)?)

<p>

SyllableB <- (InitialConsonants? Vocalic (!Syllable FinalConsonant)? (!Syllable FinalConsonant)?)

<p>

Syllable <- ((SyllableA/SyllableB) juncture?)

<p>

<li>The final consonant in a syllable.  There may be one or two final consonants.  A pair of final
<li>consonants may not be a non-continuant followed by a continuant.  A final consonant may not
<li>start a forbidden medial pair or triple.

<p>

<li>The rule that a final consonant pair may not be a non-continuant followed by a continuant
<li>is natural and obvious but not in our Sources.  Such a pair of consonants would seem to 
<li>naturally form another syllable.

<p>


<li>a pair of final consonants cannot be differently voiced

<p>

FinalConsonant <- !syllabic !(&Badvoice C1 !Syllable) (!(!continuant C1 !Syllable continuant) !NoMedial2 !NoMedial3 C1 !(juncture? (V2/syllabic)))

<p>

#!((!MaybeInitial)C1 juncture? !syllabic C1 juncture? !syllabic C1) !(&MaybeInitial C1 juncture C1 !(juncture? C1))

<h4>Varieties of Syllable</H4>

<li>Here are various flavors of syllable we may need.

<p>

<li>this is a portmanteau definition of a bad syllable (the sort not allowed in a borrowing).

SyllableD <- &(InitialConsonants? ([Yy]/DoubleVowel/BrokenMono/&Mono V2 DoubleVowel/!MustMono &Mono V2 BrokenMono)) Syllable

<p>

<li>this (below) is the kind of syllable which can exist in a borrowed predicate:
<li>it cannot start with a continuant pair, it cannot have a y as vocalic unit,
<li>and its vocalic unit (whether it has one or two regular vowels) 
<li>cannot be involved in a double vowel or an explicitly broken 
<li>mandatory monosyllable.

<p>

BorrowingSyllable <- !syllabic (!SyllableD) Syllable

<p>

<li>this is the final syllable of a predicate.  It cannot be followed
<li>without pause by a regular vowel.

<p>

VowelFinal <- InitialConsonants? Vocalic juncture? !V2

<p>

<li>syllables with syllabic consonant vocalic units
<li>this class is only used in borrowings, and we *could* reasonably
<li>require it to be followed by a vowel.  But I won't for now.
<li>for gluing this restriction would work, but we might literally borrow predicates
<li>with syllabic continuant pronunciations.

<p>

SyllableC <- (&(InitialConsonants? syllabic) Syllable)

<p>

<li>syllables with y

<p>

SyllableY <- (&(InitialConsonants? [Yy]) Syllable)

<p>

<li>an explicitly stressed syllable.

<p>

StressedSyllable <- ((SyllableA/SyllableB) stress2)

<p>

<h3>Name Words</H3>

<li>a final syllable in a word, ending in a consonant.

<p>

NameEndSyllable <- (InitialConsonants? (syllabic/Vocalic &FinalConsonant) FinalConsonant? FinalConsonant? stress? !letter)

<p>

<h4>The Pause</H4>

<li>the pause classes actually hang on the letter before the pause.

<p>

<li>whitespace which might or might not be a pause.

<p>

maybepause <- (V1 stress2? sp C1)

<p>

<li>explicit pauses:  these are whitespace before a vowel or after a consonant, or comma marked pauses.
<p>

pause <- ((C1 stress2? sp &letter)/(letter stress2? sp &V1)/(letter stress2? [,] sp &letter))

<p>

<h4>The full analysis of names</H4>

<li>these are final syllables in words followed by whitespace which might not be a pause.
<li>the definition actually doesnt mention the maybepause class.

<p>

MaybePauseSyllable <- InitialConsonants? Vocalic stress2? &(sp &C1)

<p>

<li>a name word (without initial marking) is resolvable into syllables and ends with a consonant.

<p>

PreName <- ((Syllable &Syllable)* NameEndSyllable)

<p>

<li>this is a busted name word with whitespace in it -- but not whitespace at which one has to pause.

<p>

BadPreName <- (MaybePauseSyllable sp/Syllable &Syllable)* NameEndSyllable

<p>

<li>This is a name marker followed by a consonant initial name word without pause.

<p>

<li>I deployed a minimal set of name marker words; I can add the others whenever.
<li>I have decided (see below) to retain the social lubrication words as vocative markers
<li>*without* making them name markers, so one must pause [Loi, Djan].  By not allowing
<li>freemods right after vocative markers in the vocative rule, I make [Loi hoi Djan] work as well,
<li>without pause.

<p>

<li>MarkedName <- &caprule ((([Ll] !pause [Aa] juncture?)/ ([Hh] [Oo] !pause [Ii] juncture?) /  ([Hh] [Uu] juncture? !pause [Ee] juncture?) / ([Cc] !pause [Ii] juncture?)/([Ll] [Ii] juncture? !pause [Uu] juncture?)/[Gg][Aa] !pause [Oo] juncture?/[Mm][Uu] juncture? !pause [Ee] juncture?) sp? &C1 &caprule PreName)

<p>

<li> adding wrapper classes for name markers

<p>

LAname <- [Ll] [Aa]

<p>

HOIname <- [Hh] [Oo] [Ii]

<p>

CIname <- [Cc] [Ii]

<p>

LIUname <- [Ll] [Ii] juncture? [Uu]

<p>

MUEname <- [Mm] [Uu] juncture? [Ee]

<p>

GAOname <- [Gg] [Aa] [Oo]

<p>

HUEname <- [Hh] [Uu] juncture? [Ee]

<p>

<li> second series is for marked names, no pauses after them

<p>

LAname2 <- [Ll] !pause [Aa]

<p>

HOIname2 <- [Hh] [Oo] !pause [Ii]

<p>

LIUname2 <- [Ll] [Ii] juncture? !pause [Uu]

<p>

MUEname2 <- [Mm] [Uu] juncture? !pause [Ee]

<p>

GAOname2 <- [Gg] [Aa] !pause [Oo]

<p>

HUEname2 <- [Hh] [Uu] juncture? !pause [Ee]

<p>

MarkedName <- (&caprule ((LAname2 juncture?)/ (HOIname2 juncture?) /  (HUEname2 juncture?) /(LIUname2 juncture?)/GAOname2  juncture?/MUEname2 juncture?) sp? &C1 &caprule PreName)

<p>


<li>This is an unmarked name word with a false name marker in it.

<p>

FalseMarked <- (&PreName (!MarkedName character)* MarkedName)

<p>

<li>This is the full definition of name words.  These are either marked consonant initial names without pause defined above,
<li>names without false name markers beginning with explicit pauses (either comma marked or vowel-initial) 
<li>and name markers followed, with or without pause, by name words.  In the latter case there must be at least
<li>whitespace before a vowel initial name.

<p>

<li>a series of names without false name markers and names marked with ci, separated by spaces, may be appended.

<p>

<li>there is a look ahead at the grammar: a NameWord can be followed without explicit pause (there is whitespace and 
<li>a pause in speech!) by another
<li>kind of utterance only in a serial name when what follows is of the form [ci] predunit, to be included
<li>in the name.



<p>

NameWord <- (&caprule MarkedName/([,] sp !FalseMarked &caprule PreName)/(&V1 !FalseMarked &caprule PreName)/&caprule (((LAname juncture?)/(HOIname juncture?)/HUEname juncture?/(CIname juncture?)/(LIUname juncture?)/MUEname juncture?/GAOname  juncture?) !V1 [,]? sp? &caprule PreName))([,]?sp !FalseMarked &caprule PreName/[,]?sp &([Cc] [Ii]) NameWord)* &(sp? [Cc] [Ii] predunit/&([,] sp/terminal/[\")]/!.)./!.)

<p>

<li>this is the minimal set of name marker words we are using.  We may add more.

<p>

<li>I am contemplating adding the words of social lubrication as name markers, but in a more restricted
<li>way that in the last provisional parser, in which I made them full-fledged vocative markers.  [Actually,
<li>I preserved their status as vocative markers without restoring their status as name markers, in the latest version].

<p>

<li>adding [mue] as a name marker

<p>

namemarker <- ([Ll] [Aa] juncture?/[Hh][Oo][Ii] juncture?/([Hh] [Uu] juncture? [Ee] juncture?)/[Cc] &(pause/ [Ii] juncture? sp PreName) [Ii] juncture?/[Ll][Ii] juncture? [Uu] juncture?/[Gg][Aa][Oo] juncture?/[Mm] [Uu] juncture? [Ee] juncture?) !V1

<p>

<li>this is the bad name marker phenomenon that needs to be excluded.  This captures the idea
<li>that what follows the name could be pronounced without pause as a name word according to the
<li>orthography, but the fact that whitespace is present shows that this is not the intention.

<p>

<li>it is worth noting that name markers at heads of name words pass this test
<li>(because I omitted the test that what follows is not a PreName in the interests
<li>of minimizing lookahead);
<li>but this test is only applied to strings that have already been determined not to
<li>be of class NameWord.

<p>

badnamemarker <- namemarker !V1 [, ]? sp? BadPreName

<li>we test for the bad name marker condition at the beginning of each stream of cmapua,
<li>and streams of cmapua stop before name markers (and may resume at a name marker
<li>if neither a NameWord nor the bad marker condition is found).

<p>

<li>We have at any rate completely solved the phonetic problem of names and their markers.

<p>

<h3>Predicate Start Test</H3>

<li>predicate start tests:  the idea is the same as class "connective" below, to recognize
<li>the start of a predicate without recursive appeals to the whole nasty definition of predicate.
<li>The reason to do it is to recognize when CV^n followed by CC cannot be a cmapua unit.
<p>
<li>New implementation 4/28/2019.  This allows only (C)V(V)(V) before the pair of vowels, for much less
<li>potential lookahead.
<p>

Vthree <- (V2 juncture?) (V2 juncture?) (V2 juncture?)

<p>

Vfour <- (V2 juncture?) (V2 juncture?) (V2 juncture?) (V2 juncture?)

<p>

<li>predicate starting with two or three consonants:  rules out CC(C)V(V) forms.  Junctures in
<li>the initial consonant group ignored.

<p>

predstartA1 <- (&MaybeInitial C1 juncture? MaybeInitial/MaybeInitial) &V2 !(V2 stress !Mono V2) !(V2 juncture? V2 !character) !(V2 juncture? !character)

<p>

<li>an apparent cmapua unit followed by a consonant group which cannot start a predicate -- CV(V) case

<p>

predstartA2 <- C1 V2 juncture? (V2 juncture?)? !predstartA1 C1 juncture? C1

<p>

<li>a stressed CV^n before a consonant group (CV(V) case)

<p>

predstartA3 <- C1 !Vthree (!StressedSyllable V2 juncture?)? &StressedSyllable V2 V2? juncture? C1 juncture? C1

<p>

<li>other (C)V^n followed by nonpredicate 

<p>

predstartA4 <- C1? V2 juncture? (V2 juncture?)?  (V2 juncture?)? !predstartA1 !(MaybeInitial V2) C1 juncture? C1

<p>

<li>other stressed (C)V^n followed by consonant group

<p>

predstartA5 <- C1? !Vfour (!StressedSyllable V2 juncture?)? (!StressedSyllable V2 juncture?)? &StressedSyllable V2 V2? juncture? !(MaybeInitial V2) C1 juncture? C1

<p>

<li>forms with y; implemented CVVhy alternative for CVV cmapua

<p>

predstartA6 <- C1 (V2 juncture?) (V2 juncture? [Hh]?/C1 juncture? (C1 juncture?)?) [Yy]

<p>

predstart <- predstartA1/predstartA2/predstartA3/predstartA4/predstartA5/predstartA6

<p>

<li>it is worth noting that in the sequel we have systematically replaced tests &Cmapua
<li>with !predstart.  The former involves lots of lookahead and was causing recursion crashes
<li>in Python.  The phonetics and the grammar are both structured so that any string
<li>starting with a name marker is tested for NameWord-hood before it is tested for 
<li>cmapua-hood; the only thing it is tested for later is predicate-hood, and predstart
<li>is a rough and ready test that something might be a predicate (and at any rate
<li>cannot be a cmapua).

<p>

<h3>Structure Word Phonetics</H3>

<li>this class requires pauses before it, after all the phonetic word classes.
<li>what is being recognized is the beginning of a logical connective.

<p>

<li>To avoid horrible recursion problems, giving this a concrete phonetic definition
<li>without much lookahead.  This can go right up in the phonetics section if it works
<li>(and here it is!).

<p>

<li>single vowel cmapua syllables early for connectives

<p>

a <- ([Aa] !badstress juncture? !V1)

<p>

e <- ([Ee] !badstress juncture? !V1)

<p>

i <- ([Ii] !badstress juncture? !V1)

<p>

o <- ([Oo] !badstress juncture? !V1)

<p>

u <- ([Uu] !badstress juncture? !V1)

<p>


Hearly <- (!predstart [Hh])

<p>

Nearly <- (!predstart [Nn])

<p>


<li>these appear here for historical reasons and could be moved later

<p>


connective <- sp? !predstart ([Nn] [Oo] juncture? !i)? (a/e/i/o/u/Hearly a/Nearly UU) juncture? !V2 !(!predstart [Ff] [Ii]) !(!predstart [Mm] [Aa]) !(!predstart [Zz] [Ii])

<p>


<li>cmapua units starting with consonants.  This is the exact description from NB3.  The fancy tail in each of the 
<li>three cases is enforcing the rule about pausing before a following predicate if stressed.

<p>

<li>consonant initial cmapua units may not be followed by vowels without pause.

<p>

<li>I am adding [iy] and [uy] (always monosyllable, yuh and wuh) as vowel pairs permitted in VV and CVV cmapua units.
<li>it is worth noting that the "yuh" and "wuh" pronunciations of these diphthongs
<li>are surprising to the English-reading eye.
<li>The use for this envisaged is that the name [ziy] of Y becomes easy to introduce.  Adding word space
<li>is always nice, and these words seem pronounceable.  I also made [yfi] possible:  Y now has phonetically
<li>regular names.
<p>

CmapuaUnit <- (C1 Mono juncture? V2 !(stress2 sp? &C1 predstart) juncture? !V1/C1 (VV/[Ii][Yy]/[Uu][Yy]) !(stress2 sp? &C1 predstart) juncture? !V1/C1 V2 !(stress2 sp? &C1 predstart) juncture? !V1) 

<p>

<li>A stream of cmapua is read until the start of a predicate or a name marker word or an alien text marker word or a quote or parenthesis marker word is encountered.
<li>the stream might resume with a name marker word if it does not in fact start a name word and does not potentially start a name
<li>word due to inexplicit whitespace (doesn't satisfy the bad name marker condition).

<p>

<li>we force explicit comma pauses before logical connectives, but not before vowel initial cmapua in general;
<li>other conditions force at least whitespace, which does stand for a pause, before such words.

<p>

<li>detect starts of quotes or parentheses with li or [kie]

<p>

likie <- ([Ll] [Ii] juncture? !V1/[Ki] [Ii] juncture? [Ee] juncture? !V1)

<p>

<li>a special provision is made for NO UI forms as single words.  [yfi] is supported.

<p>

Cmapua <- &caprule !badnamemarker (!predstart (VV/[Ii][Yy]/[Uu][Yy]) !(stress2 sp? &C1 predstart) juncture? NOI/!predstart [Nn] [Oo] juncture? !predstart (VV/[Ii][Yy]/[Uu][Yy]) !(stress2 sp? &C1 predstart) juncture?/((!predstart (VV/[Ii][Yy]/[Uu][Yy]) !(stress2 sp? &C1 predstart) juncture?)+ / ((!predstart V1 !(stress2 sp? &C1 predstart) juncture?)/ !predstart CmapuaUnit) (!namemarker !alienmarker !likie !predstart CmapuaUnit)*)/!predstart V2 !(stress2 sp? &C1 predstart) juncture?) !V1 !(C1+ juncture) !(sp? connective)

<p>

<li>I have apparently now completely solved the problem of parsing cmapua as well as name words.

<p>

<h3>Predicate Phonetics</H3>

<li>Now for predicates.

<h4>Djifoa ("affixes")</H4>

<p>

<li>the elementary djifoa (not borrowings)

<p>

<li>various special flavors of these djifoa will be needed.
<li>These are the general definitions.

<p>

<li>The NOY and Bad forms are for use for testing candidate borrowings for resolution
<li>with bad syllable break placements.  Borrowings do not contain Y...

<p>

<li>CVV djifoa with phonetic hyphens.

<p>

<li>added checks to all cmapua classes:  the vowel final ones, when not phonetically hyphenated, cannot
<li>be followed by a regular vowel.  This is crucial for getting the syllable analysis and the djifoa
<li>analysis to end at the same point.

<p>

<li>allowing h to be inserted before y in CVVy djifoa for a CVVhy form.

<p>

<li>allowing -r glue to be expressed as -rr

<li> some classes just for djifoa glue

<p>

why <- [Yy]

<p>

arr <- [Rr]

<p>

enn <- [Nn]

<p>

aitch <- [Hh]

<p>

dash <- [-]

#p$

CVV <- C1 VV (juncture? aitch? why dash? &(Complex) /juncture? arr arr? juncture? &C1/enn juncture? &arr/juncture? !V2)

<p>

CVVNoHyphen <- C1 VV juncture? !V2

<p>

CVVHiddenStress <- C1 &DoubleVowel V1 dash? V1 (dash? aitch? why dash? &Complex /arr dash? &C1/enn dash? &arr/dash? !V2)

<p>

CVVFinalStress <- C1 VV (stress2 aitch? why dash? &Complex /arr stress2 &C1/stress2 arr arr juncture? &C1/enn stress2 &arr/stress2 !V2)

<p>

CVVNOY <- C1 VV (juncture? arr arr? juncture? &C1/enn juncture? &arr/juncture? !V2) 

<p>

CVVNOYFinalStress <- C1 VV (arr stress2 &C1/stress2 arr arr juncture? &C1/enn stress2 &arr/stress2 !V2)

<p>

CVVNOYMedialStress <- C1 !BrokenMono V2 stress2 V2 dash? !V2

<p>

<li>CCV djifoa with phonetic hyphens.

<p>

CCV <- Initial V2 (juncture? why dash? &letter/juncture? !V2)

<p>

CCVStressed <- Initial V2 (stress2 why dash? &letter/stress2 !V2)

<p>

CCVNOY <- Initial V2 juncture? !V2
<p>

CCVBad <- MaybeInitial V2 juncture? !V2

CCVBadStressed <- MaybeInitial V2 stress2 !V2

<p>


<li>CVC djifoa with phonetic hyphens.  These cannot be final and are always followed by a consonant (well, the
<li>-y form may be followed by a vowel...
<li>an eccentric syllable break is supported if the CVC is y-hyphenated:
<li>[me-ky-kiu] and [mek-y-kiu] are both legal.  The default is the latter.

<p>

CVC <- (C1 V2 !NoMedial2 !NoMedial3 C1 (juncture? why dash? &letter/juncture? &C1)/C1 V2 juncture C1 why dash? &letter)

<p>

CVCStressed <- (C1 V2 !NoMedial2 !NoMedial3 C1 (stress2 why dash? &letter/stress2 &letter)/C1 V2 stress2 C1 why dash? &letter)

<p>

CVCNOY <- C1 V2 !NoMedial2 !NoMedial3 C1 juncture? &C1

<p>

CVCBad <- C1 V2 !NoMedial2 !NoMedial3 juncture? C1 &C1

<p>

CVCNOYStressed <- C1 V2 !NoMedial2 !NoMedial3 C1 stress2 &C1

<p>

CVCBadStressed <- C1 V2 !NoMedial2 !NoMedial3 stress2 C1 &C1

<p>

<li>the five letter forms (always final in complexes)

CCVCV <- Initial V2 juncture? C1 V2 dash? !V2

<p>

CCVCVStressed <- Initial V2 stress2 C1 V2 dash? !V2

<p>

CCVCVBad <- MaybeInitial V2 juncture? C1 V2 dash? !V2

<p>

CCVCVBadStressed <- MaybeInitial V2 stress2 C1 V2 dash? !V2

<p>

CVCCV <- (C1 V2 juncture? Initial V2 dash? !V2/C1 V2 !NoMedial2 C1 juncture? C1 V2 dash? !V2)

<p>

CVCCVStressed <- (C1 V2 stress2 Initial V2 dash? !V2/C1 V2 !NoMedial2 C1 stress2 C1 V2 dash? !V2)

<p>

<li>the medial five letter djifoa

<p>

CCVCY <- Initial V2 juncture? C1 why dash?

<p>

CVCCY <- (C1 V2 juncture? Initial why dash?/C1 V2 !NoMedial2 C1 juncture? C1 why dash?)

<p>

CCVCYStressed <- Initial V2 stress2 C1 why dash?

<p>

CVCCYStressed <- (C1 V2 stress2 Initial why dash?/C1 V2 !NoMedial2 C1 stress2 C1 why dash?)

<p>

<h4>Borrowed Predicates</H4>

<li>to reason about resolution of borrowings into both syllables and djifoa (we want to exclude the latter
<li>but we need to define it adequately) we need to recognize where to stop.  A predicate word ends either
<li>at a non-character (not a letter or syllable mark: whitespace, comma or terminal punctuation) or it
<li>has an explicit or deducible penultimate stress.  Borrowings do not contain doubled vowels, so they
<li>have to have explicit stress in the latter case.

<p>

<li>analysis:  the stressed tail consists of a stressed syllable followed by an unstressed syllable.
<li>identifying an unstressed final syllable is complicated by recognizing which CVV combinations can
<li>be one syllable.  This will either be an explicitly stressed syllable followed by a single syllable
<li>or a syllable suitable to be stressed followed by an explicitly final syllable.  CVV djifoa can
<li>contain both syllables in a tail and of course the five letter djifoa have to be tails.  A never stressed
<li>SyllableC (with a continuant) may intervene.

<p>

<li>tail of a borrowing with an explicit stress

<p>

BorrowingTail1 <- !SyllableC &StressedSyllable BorrowingSyllable (!StressedSyllable &SyllableC BorrowingSyllable)? !StressedSyllable &BorrowingSyllable VowelFinal

<p>

<li>tail of a borrowing or borrowing djifoa with no explicit stress

<p>

BorrowingTail2 <- !SyllableC BorrowingSyllable (!StressedSyllable &SyllableC BorrowingSyllable)? !StressedSyllable &BorrowingSyllable VowelFinal (&why/!character)

<p>

<li>tail of a stressed borrowing djifoa, different because stress is shifted to the end

<p>

BorrowingTail3 <- !SyllableC !StressedSyllable BorrowingSyllable (!StressedSyllable &SyllableC BorrowingSyllable)? &BorrowingSyllable InitialConsonants? Vocalic stress2 &why

<p>

BorrowingTail <- BorrowingTail1 / BorrowingTail2

<p>

<li>short forms that are ruled out:  CCVV and CCCVV forms.

<p>

CCVV <- (InitialConsonants V2 juncture? V2 juncture? !character / InitialConsonants V2 stress2 !Mono V2 juncture?)

<p>

<li>VCCV and some related forms are ruled out (rule predstartF above is about this)

<p>

<li>a continuant syllable cannot be initial in a borrowing and there cannot be successive continuant
<li>syllables.  There really ought to be no more than one!

<p>

<li>borrowing, before checking that it doesnt resolve into djifoa

<p>

PreBorrowing <- &predstart!CCVV!Cmapua!SyllableC(!BorrowingTail!(StressedSyllable)!(SyllableC SyllableC)BorrowingSyllable)* BorrowingTail

<p>

<li>ditto for an explicitly stressed borrowing

<p>

StressedPreBorrowing <- &predstart!CCVV!Cmapua!SyllableC(!BorrowingTail!(StressedSyllable)!(SyllableC SyllableC)BorrowingSyllable)* BorrowingTail1

<p>

<li>borrowing djifoa without explicit stress (before resolution check)

<p>

PreBorrowing2 <- &predstart!CCVV!Cmapua!SyllableC(!BorrowingTail!(StressedSyllable)!(SyllableC SyllableC)BorrowingSyllable)* BorrowingTail2

<p>

<li>stressed borrowing djifoa (before resolution check).

<p>

PreBorrowing3 <- &predstart!CCVV!Cmapua!SyllableC(!BorrowingTail3!(StressedSyllable)!(SyllableC SyllableC)BorrowingSyllable)* BorrowingTail3

<li>Now comes the problem of trying to say that a preborrowing cannot resolve into cmapua.  The difficulty is with
<li>recognizing the tail, so making sure that the two resolutions stop in the same place.

<p>

<li>we know because it is a borrowing that there is at most one explicit stress, and it has to fall
<li>in one of the cmapua!  This should make it doable.

<p>

<li>borrowing djifoa are terminated with y, so the final djifoa needs to take this into account

<p>

<li>the idea behind both djifoa analyses is the same.  If we end with a final djifoa followed by
<li>a non-character, we improve our chances of ending the syllable analysis at the same point.  We control
<li>this by identifying djifoa with stresses in them:  a medially stressed djifoa must be the last one
<li>(and the syllable analysis will find its stressed syllable and end at its final syllable, the fact
<li>that djifoa cannot be followed by vowels ensuring that the syllable analysis cannot overrun its end.
<li>When the djifoa is finally stressed, the complex analysis ends with a further djifoa guaranteed to have
<li>just one syllable, and the syllable analysis again will stop in the same place.  The medial five letter forms
<li>and borrowing djifoa of course are finally stressed mod an additional unstressed syllable which is skipped
<li>by the syllable analysis, because it allows one to ignore an actually penultimate syllable with y or 
<li>a syllabic consonant.  In the case where we never find a stress and end up at a final djifoa, the syllable
<li>analysis will carry right through to the same final point.
<p>

<li>in the attempted resolution of borrowings, our life is easier because we do not have
<li>borrowing djifoa or medial five letter forms to consider, or any forms with y-hyphens.

<p>

RFinalDjifoa <- (CCVCVBad/CVCCV/CVVNoHyphen/CCVBad/CVCBad) (&why/!character)

<p>

RMediallyStressed <- (CCVCVBadStressed/CVCCVStressed/CVVNOYMedialStress)

<p>

RFinallyStressed <- (CVVNOYFinalStress/CCVBadStressed/CVCBadStressed/CVCNOYStressed)

<p>

BorrowingComplexTail <- (RMediallyStressed/RFinallyStressed (&(C1 Mono) CVVNoHyphen/CCVBad)/RFinalDjifoa)

<p>

ResolvedBorrowing <- (!BorrowingComplexTail(CVVNOY/CCVBad/CVCBad))* BorrowingComplexTail

<p>

<li>borrowed predicates

Borrowing <- !ResolvedBorrowing &caprule PreBorrowing !(sp? (connective))

<p>

<li>explicitly stressed borrowed predicates

<p>

StressedBorrowing <- !ResolvedBorrowing &caprule StressedPreBorrowing !(sp? &V1 Cmapua)

<p>

#This is the shape of non-final borrowing djifoa.  Notice that a final stress is allowed.
#The curious provision for explicitly stressing a borrowing djifoa and pausing is supported.

<p>

<li>borrowing djifoa without explicit stress (stressed ones are not of this class!)
<li>Note that one can pause after these (explicitly, with a comma, in which case the stress must be explicit too)

<p>

BorrowingDjifoa <- !ResolvedBorrowing &caprule PreBorrowing2 (stress2 why [,] sp/juncture? why dash?)

<p>

<li>stressed borrowing djifoa finally implemented!

<p>

StressedBorrowingDjifoa <- !ResolvedBorrowing &caprule PreBorrowing3 why dash? ([,] sp)?

<p>

<h4>Complex Predicates</H4>

<li>We resolve complexes twice, once into syllables and once into djifoa.  We again have to ensure that
<li>we end up in the same place!  The syllable resolution is very similar to that of borrowings;
<li>the unstressed middle syllable of the tail can be a SyllableY, and can also be a
<li>SyllableC if the final djifoa is a borrowing.

<p>

<li>A stressed borrowing djifoa with the property that the tail is still a phonetic complex is
<li>a unit for this analysis.

<p>

<li>note here that I specifically rule out a complex being followed without pause by y.  I do not rule
<li>this out for the vowel final djifoa because they can be followed by y at the end of a borrowing
<li>djifoa.

<p>

DefaultStressedSyllable <- Syllable

<p>


PhoneticComplexTail1 <- !SyllableC !SyllableY &StressedSyllable DefaultStressedSyllable (!StressedSyllable &(SyllableC/SyllableY) Syllable)? !StressedSyllable !SyllableY VowelFinal !V1

<p>

PhoneticComplexTail2 <- !SyllableC !SyllableY DefaultStressedSyllable (!StressedSyllable &(SyllableC/SyllableY) Syllable)? !StressedSyllable !SyllableY VowelFinal !character

<p>

PhoneticComplexTail <- PhoneticComplexTail1 / PhoneticComplexTail2

<p>

<li>note the explicit predstart test here.

<p>

PhoneticComplex <- &predstart!CCVV!Cmapua!SyllableC(StressedBorrowingDjifoa &PhoneticComplex/!PhoneticComplexTail!(StressedSyllable)!(SyllableC SyllableC) Syllable)* PhoneticComplexTail

<p>

<li>the analysis of final djifoa and stressed djifoa differs only in details from
<li>what is above for resolution of borrowings.  The issues about CVV djifoa with doubled
<li>vowels are rather exciting.

<p>

<li>a stressed borrowing djifoa with the tail still a phonetic complex is a black box unit for
<li>this construction.

<p>

<li>My approach imposes the restriction on JCB's "pause after a borrowing djifoa" idea that what follows
<li>the pause must itself contain a penultimate stress:  [igllu'ymao] is a predicate but [igllu'y, mao] is not.
<li>while [iglluy', gudmao] is a predicate.

<p>

<li>the analysis of the djifoa resolution process is the same as above, with additional remarks
<li>about doubled vowel syllables:  notice that where the complex tail involved a doubled vowel syllable
<li>without explicit stress, we insist on that djifoa or the single-syllable next djifoa ending in
<li>a non-character:  in the absence of explicit stress, we always rely on whitespace or punctuation
<li>to indicate the end of the predicate.

<p>

<li>all sorts of subtleties about borrowings and borrowing djifoa are finessed by always looking for
<li>them first.  There are no restrictions re fronts of borrowings or borrowing djifoa looking like regular
<li>djifoa;  the fact that borrowing djifoa end in y and borrowings do not contain y makes it always
<li>possible to tell when one is looking at the head of a borrowing djifoa.  Regular djifoa just before a borrowing
<li>djifoa need to be y-hyphenated so as not to be absorbed into the front of the borrowing (I don't believe
<li>that I actually need to impose a formal rule to this effect, though I am not absolutely certain;  it would
<li>be difficult to formulate [and does appear in the previous version, where it is a truly unintelligible piece
<li>of PEG code]).

<p>

FinalDjifoa <- (Borrowing/CCVCV/CVCCV/CVVNoHyphen/CCVNOY) !character

<p>

MediallyStressed <- (StressedBorrowing/CCVCVStressed/CVCCVStressed/CVVNOYMedialStress)
<p>

FinallyStressed <-(StressedBorrowingDjifoa/CCVCYStressed/CVCCYStressed/CVVFinalStress/CCVStressed/CVCStressed)

<p>

ComplexTail <- (CVVHiddenStress (&(C1 Mono) CVVNoHyphen/CCVNOY) !character/FinallyStressed (&(C1 Mono) CVVNoHyphen/CCVNOY)/MediallyStressed/FinalDjifoa)

<p>

PreComplex <-  (!CVVHiddenStress (!ComplexTail)(StressedBorrowingDjifoa &PhoneticComplex/BorrowingDjifoa/CVCCY/CCVCY/CVV/CCV/CVC))* ComplexTail

<p>

<li>originally I had complicated tests here for the conditions under which an initial
<li>CVC cmapua has to be y-hyphenated:  I was being wrong headed, the predstart rules
<li>already enforce this (in the bad cases, the initial CV- falls off).  The user will
<li>simply find that they cannot put the word together otherwise.  The previous version
<li>did need this test because it actually used full lookahead to check for the start of a predicate.

<p>

Complex <- &caprule &PreComplex PhoneticComplex !(sp? (connective))

<p>

<h3>Quotation and Parenthesis of well-formed Loglan utterances; word classes</H3>

<li>format for the LI quote and KIE parenthesis

<p>

LiQuote <- (&caprule [Ll][Ii]juncture? comma2? [\"] phoneticutterance [\"] comma2? &caprule [Ll][Uu]juncture? !(sp? connective)/(&caprule [Kk][Ii]juncture?[Ee]juncture? comma2? [(] phoneticutterance [)] comma2? &caprule [Kk][Ii]juncture?[Uu]juncture? !(sp? connective)))

<p>

<li>the condition on Word that a Cmapua is not followed by another Cmapua
<li>with mere whitespace between was used by [liu] quotation, but is now redundant,
<li>because I have required that [liu] quotations be closed with explicit pauses in all cases.

<p>

Word <- (NameWord / Cmapua / Complex/CCVNOY)

<p>

<li>it is an odd point that all borrowings parse as complexes -- so when I parsed all the words the first time they all
<li>parsed as complexes.  A borrowing is a complex consisting of a single final borrowing djifoa!
<li>I did redesign this so that borrowings are parsed as borrowings.  (This is the class
<li>I used to parse the dictionary).

<p>

<li>Yes, CVC djifoa do get parsed as names in the dictionary, so the CVC case here is redundant.  I actually
<li>think that only the CCV djifoa actually get parsed as such.

<p>

SingleWord <- (Borrowing !./Complex !./ Word !./PreName !. /CCVNOY) !.

<p>

<li>name word appearing initially without leading spaces is important, because one type of NameWord includes a leading comma.

<h3>The full phonetic utterance classes</H3>

<p>

phoneticutterance1 <- (NameWord /sp? LiQuote/sp? NameWord/sp? AlienWord/sp?Cmapua/sp? '--'/sp? '...'/sp? Borrowing!why/sp? Complex/sp? (CCVNOY))+

<p>

phoneticutterance <- (phoneticutterance1/[,]sp/terminal)+

<p>

<h2>Interlude:  Phonemes and Pauses</H2>

<h3>Consonants and vowel groups in cmapua</H3>

<li>as noted above, !predstart stands in for the computationally disastrous &Cmapua

<p>

badstress <- stress2 sp? &C1 predstart
<p>
B <- (!predstart [Bb])
<p>
C <- (!predstart [Cc])
<p>
D <- (!predstart [Dd])
<p>
F <- (!predstart [Ff])
<p>
G <- (!predstart [Gg])
<p>
H <- (!predstart [Hh])
<p>
J <- (!predstart [Jj])
<p>
K <- (!predstart [Kk])
<p>
L <- (!predstart [Ll])
<p>
M <- (!predstart [Mm])
<p>
N <- (!predstart [Nn])
<p>
P <- (!predstart [Pp])
<p>
R <- (!predstart [Rr])
<p>
S <- (!predstart [Ss])
<p>
T <- (!predstart [Tt])
<p>
V <- (!predstart [Vv])
<p>
Z <- (!predstart [Zz])
<p>
<li>the monosyllabic classes may be followed by one vowel
<li>if they start a Cvv-V cmapua unit;  the others may never
<li>be followed by vowels.  Classes ending in -b are
<li>used in Cvv-V cmapua units.
<p>
<li>the single vowel classes were moved before the class
<li>connective in the phonetics section.
<p>

V3 <- juncture? V2 !badstress
<p>
AA <- ([Aa] juncture? [Aa] !badstress juncture? !V1)  
<p>
AE <- ([Aa] juncture? [Ee]  !badstress juncture? !V1)  
<p>
AI <- ([Aa] [Ii]  !badstress juncture? !(V1))  
<p>
AO <- ([Aa] [Oo]  !badstress juncture? !(V1)) 
<p>
AIb <- ([Aa] [Ii]  !badstress juncture? &(V2 juncture? !V1))  
<p>
AOb <- ([Aa] [Oo]  !badstress juncture? &(V2 juncture? !V1))  
<p> 
AU <- ([Aa] juncture? [Uu]  !badstress juncture? !V1)  
<p>
EA <- ([Ee] juncture? [Aa]  !badstress juncture? !V1)  
<p>
EE <- ([Ee] juncture? [Ee]  !badstress juncture? !V1)  
<p>
EI <- ([Ee] [Ii]  !badstress juncture? !(V1)) 
<p>
EIb <- ([Ee] [Ii]  !badstress juncture? &(V2 juncture? !V1))  
<p>
EO <- ([Ee] juncture? [Oo]  !badstress juncture? !V1)  
<p>
EU <- ([Ee] juncture? [Uu]  !badstress juncture? !V1)  
<p>
IA <- ([Ii] juncture? [Aa]   !badstress juncture? !(V1))  
<p>
IE <- ([Ii] juncture? [Ee]  !badstress juncture? !(V1))  
<p>
II <- ([Ii] juncture? [Ii]  !badstress juncture? !(V1))  
<p>
IO <- ([Ii] juncture? [Oo]  !badstress juncture? !(V1))  
<p>
IU <- ([Ii] juncture? [Uu]   !badstress juncture? !(V1)) 
<p>
IAb <- ([Ii] juncture? [Aa]   !badstress juncture? &(V2 juncture? !V1))  
<p>
IEb <- ([Ii] juncture? [Ee]  !badstress juncture? &(V2 juncture? !V1))  
<p>
IIb <- ([Ii] juncture? [Ii]  !badstress juncture? &(V2 juncture? !V1))  
<p>
IOb <- ([Ii] juncture? [Oo]  !badstress juncture? &(V2 juncture? !V1))  
<p>
IUb <- ([Ii] juncture? [Uu]   !badstress juncture? &(V2 juncture? !V1))   
<p>
OA <- ([Oo] juncture? [Aa]  !badstress juncture? !V1)  
<p>
OE <- ([Oo] juncture? [Ee]  !badstress juncture? !V1)  
<p>
OI <- ([Oo] [Ii]  !badstress juncture? !(V1)) 
<p>
OIb <- ([Oo] [Ii]  !badstress juncture? &(V2 juncture? !V1)) 
<p>
OO <- ([Oo] juncture? [Oo]  !badstress juncture? !V1)  
<p>
OU <- ([Oo] juncture? [Uu]   !badstress juncture? !V1)  
<p>
UA <- ([Uu] juncture? [Aa]   !badstress juncture? !(V1))  
<p>
UE <- ([Uu] juncture? [Ee]  !badstress juncture? !(V1))  
<p>
UI <- ([Uu] juncture? [Ii]   !badstress juncture? !(V1))  
<p>
UO <- ([Uu] juncture? [Oo]  !badstress juncture? !(V1))  
<p>
UU <- ([Uu] juncture? [Uu]  !badstress juncture? !(V1)) 
<p>
UAb <- ([Uu] juncture? [Aa]   !badstress juncture? &(V2 juncture? !V1))  
<p>
UEb <- ([Uu] juncture? [Ee]  !badstress juncture? &(V2 juncture? !V1))  
<p>
UIb <- ([Uu] juncture? [Ii]   !badstress juncture? &(V2 juncture? !V1))  
<p>
UOb <- ([Uu] juncture? [Oo]  !badstress juncture? &(V2 juncture? !V1))  
<p>
UUb <- ([Uu] juncture? [Uu]  !badstress juncture? &(V2 juncture? !V1))   
<p>
<li>adding the new IY and UY, which might see use some time.
<li>they are mandatory monosyllables but do not take a possible additional
<li>following vowel as the regular ones do.  So far only used in [ziy].
<p>
IY <- [Ii] [Yy] !badstress juncture? !V1
<p>
UY <- [Uu] [Yy] !badstress juncture? !V1
<p>
<h3>The optional pause and commas</H3>
<p>
<li>this is a pause not required by the phonetics.  This is the only
<li>sort of pause which could in principle carry semantic freight (the
<li>pause/GU equivalence beloved of our Founder) but we have abandoned
<li>this.  There is one place, after initial no in an utterance, where
<li>a pause can have effect on the parse (but not on the meaning, I believe, 
<li>unless a word break is involved).

<p>

<li>this class should NEVER be used in a context which might follow
<li>a name word.  In previous versions, pauses after name words were included
<li>in the name word;  this is not the case here, so a PAUSE
<li>after a name word would not be recognized as a mandatory pause.

<p>

<li>in any event, as long as we stay away from pause/GU equivalence, this
<li>is not a serious issue!

<p>

<li>this class does do some work in the handling of issues surrounding the legacy
<li>shape of APA connectives, concerning which the less said, the better.

<p>

PAUSE <- [,] sp !(V1/connective) &caprule

<p>

<li>more punctuation
<p>
comma <- [,] sp &caprule
<p>
comma2 <- [,]? sp &caprule
<p>
<h2>Part II: Lexicography</H2>
<li>In this section I develop the grammar of words in Loglan.  I'll work by editing the original provisional PEG grammar.

<p>

<li>I place the start of this section exactly here, just before two final items of
<li>punctuation, because these items of punctuation look forward not only to lexicography
<li>but to the full grammar!

<h3>Period and end of utterance</H3>

<p>

<li>the end of utterance symbol [#] should be added in the phonetics
<li>section as a species of terminal marker. Done.  We do *not* actually
<li>endorse use of this marker, but we can notionally support it and it is in 
<li>our sources.

<p>

end <- ((sp? '#' sp utterance)/(sp !.)/!.)

<p>

<li>this rule allows terminal punctuation to be followed by an inverse vocative,
<li>a frequent occurrence in Leith's novel, and something which makes sense.

<p>

period <- (([!.:;?] (&end/(sp &caprule))) (invvoc period?)?)

<p>

<li>Letters with y will be special cases
<li>idea:  allow IY and UY (always monosyllables) as vowel combinations in cmapua only.
<li>done:  Y has a name now.  [yfi] is also added.

<p>

<h3>The cmapua word classes</H3>

<li>the classes in this section after this point are the cmapua word classes of Loglan (if they begin with sp? or a word class).
<li>I suppose the alien text classes are not really word classes, but they are lexicographic items, as it were.
<li>Paradoxically, the PA and NI classes admit internal explicit pauses.  So of course do predicate words!

<p>

<li>Loglan does admit true multisyllable cmapua:  there are words made of cmapua units which have joints between
<li>units at which one cannot pause without breaking the word.  Lojban, I am told, does not.

<p>

<li>this version has the general feature that the quotation and alien text constructions are not hacked:
<li>they are supported by the phonetic rules (as dire exceptions, of course) and the grammatical constructions
<li>conform with the phonetic layer.  Alien text and utterances quoted with [li]...[lu] can be enclosed in double quotes.
<li>LI only supports full utterances, for the moment.  All alien text constructors take the same class as argument:
<li>the vocative and inverse vocative *require* quotes to avoid misreading ungrammatical expressions with typos
<li>as correct (inverse) vocatives.

<p>

<h4>Letterals (first approximation) </H4>

<li>the names [yfi], [ziy] for Y are supported.  The Ceo names are left as they are.  I decided that a second short series
<li>of letteral pronouns is actually a reasonable use of short words, and the Ceio words are there for other uses.

<p>

TAI0 <- (V1 juncture? M a/V1 juncture? F i/V1 juncture? Z i/!predstart C1 AI/!predstart C1 EI/!predstart C1 AIb u/!predstart C1 EIb (u)/!predstart C1 EO/ Z [Ii] V1 !badstress juncture? !V1 (M a)?)

<p>

<h4>Logical and causal connectives</H4>

<li>a negative suffix used in various contexts.  Always a suffix:  its use as a prefix in tenses was a mistake in NB3 and I 
<li>think still supported in LIP.  Ambiguities demonstrably followed from this usage (an example of how the demonstration
<li>of non-ambiguity of 1989 Loglan was compromised by the opaque lexicography).

<p>

NOI <- (N OI)

<p>

<li>the logical connectives.  [A0] is the class of core logical connectives.  [A] is the fully decorated logical connective with
<li>possible nu- (always in nuno- or nuu) and no- prefixes, possible -noi suffix, and possible (problematic) PA suffix, closed
<li>with -fi (our new proposal) or an explicit pause.

<p>

A0 <- &Cmapua (a/e/o/u/H a/N UU)
<p>
A <- sp? !predstart !TAI0 (N [o])? A0 NOI? !(sp PANOPAUSES PAUSE) !(PANOPAUSES !PAUSE [ ,]) (PANOPAUSES ((F i)/&PAUSE))?
<p>
<li>4/18 in connected sentpreds, fi must be used to close, not a pause.
<p>
<li>A2 <- sp? !predstart !TAI0 (N [o])? A0 NOI? !(sp PANOPAUSES PAUSE) !(PANOPAUSES !PAUSE [ ,]) (PANOPAUSES (F i))?
<p>


<li>A not closed with -fi or a pause
<p>
ANOFI <- sp? (!predstart !TAI0 ( (N [o])? A0 NOI? PANOPAUSES?))
<p>
A1 <- A
<p>
<li>versions of A with different binding strength
<p>
ACI <- (ANOFI C i)
<p>
AGE <- (ANOFI G e)
<p>
<li>a tightly binding series of logical connectives used to link predicates
<li>this also includes the fusion connective [ze] when used between predicates.
<p>
CA0 <- (( (N o)? ((C a)/(C e)/(C o)/(C u)/(Z e)/(C i H a)/N u C u)) NOI?)
<p>
CA1 <- (CA0 !(sp PANOPAUSES PAUSE) !(PANOPAUSES !PAUSE [ ,]) (PANOPAUSES ((F i)/&PAUSE))?)
<p>
CA1NOFI <- (CA0 PANOPAUSES?)
<p>
CA <- (sp? CA1)
<p>
<li>the fusion connective when used in arguments
<p>
ZE2 <- (sp? (Z e))
<p>
<li>sentence connectives.  [I] is the class of utterance initiators (no logical definition).
<li>the subsequent classes are inhabited by sentence logical connectives with various binding
<li>strengths.
<p>
I <- (sp? !predstart !TAI0 i !(sp PANOPAUSES PAUSE) !(PANOPAUSES !PAUSE [ ,]) (PANOPAUSES ((F i)/&PAUSE))?)
<p>
ICA <- (sp? i ((H a)/CA1))
<p>
ICI <- (sp? i CA1NOFI? C i)
<p>
IGE <- (sp? i CA1NOFI? G e)
<p>
<li>forethought logical connectives
<p>
KA0 <- ((K a)/(K e)/(K o)/(K u)/(K i H a)/(N u K u))
<p>
<li>causal and comparative modifiers
<p>
KOU <- ((K OU)/(M OI)/(R AU)/(S OA)/(M OU)/(C IU))
<p>
<li>negative and converse forms
<p>
KOU1 <- (((N u N o)/(N u)/(N o)) KOU)
<p>
<li>the full type of forethought connectives, adding the causal and comparative connectives
<p>
KA <- (sp? ((KA0)/((KOU1/KOU) K i)) NOI?)
<p>
<li>the last component of the KA...KI... structure of forethought connections
<p>
KI <- (sp? (K i) NOI?)
<p>
<li>causal and comparative modifiers which are *not* forethought connectives

KOU2 <- (KOU1 !KI)
<p>
<h4>Quantity words</H4>
<p>
<li>a test used to at least partially enforce the penultimate stress rule on quantifier predicates
<p>
BadNIStress <- ((C1 V2 V2? stress (M a)? (M OA)? NI RA)/(C1 V2 stress V2 (M a)? (M OA)? NI RA))
<p>
<li>root quantity words, including the numerals
<p>
NI0 <- (!BadNIStress ((K UA)/(G IE)/(G IU)/(H IE)/(H IU)/(K UE)/(N EA)/(N IO)/(P EA)/(P IO)/(S UU)/(S UA)/(T IA)/(Z OA)/(Z OO)/(H o)/(N i)/(N e)/(T o)/(T e)/(F o)/(F e)/(V o)/(V e)/(P i)/(R e)/(R u)/(S e)/(S o)/(H i)))
<p>
<li>the class of SA roots, which modify quantifiers
<p>
SA <- (!BadNIStress ((S a)/(S i)/(S u)/(IE (comma2? !IE SA)?)) NOI?)
<p>
<li>the family of quantifiers which double as suffixes for the quantifier predicates
<li>this class perhaps should also include some other quantifier words. [re] for example ought to be handled in the same way as [ra,ri,ro].
<li>No action here, just a remark.
<p>
RA <- (!BadNIStress ((R a)/(R i)/(R o)/R e/R u))
<p>
<li>re and ru added to class RA 5/11/18
<p>
<li>quantifier units consisting of a NI or RA root with [ma] 00 or [moa] 000 appended; to [moa] one can further
<li>append a digit to iterate [moa]:  [fomoate] is four billion, for example.  [rimoa], a few thousand.
<p>
<li>a NI1 or RA1 may be followed by a pause before another NI word other than a numerical predicate;
<li>one is allowed to breathe in the middle of long numerals.  I question whether the pause
<li>provision makes sense in RA1.
<p>
NI1 <- ((NI0 (!BadNIStress M a)? (!BadNIStress M OA NI0*)?) (comma2 !(NI RA) &NI)?)
<p>
RA1 <- ((RA (!BadNIStress M a)? (!BadNIStress M OA NI0*)?) (comma2 !(NI RA) &NI)?)
<p>
<li>a composite NI word, optional SA prefix before a sequence of NI words or a RA word,
<li>or a single SA word [which will modify a default quantifier not expressed], 
<li>possibly negated, connected with CA0 roots to other such constructs.
<p>
NI2 <- (( (SA? (NI1+/RA1))/SA) NOI? (CA0 ((SA? (NI1+/RA1))/SA) NOI?)*)
<p>
<li>a full NI word with an acronymic dimension (starting with [mue], ending with a pause) or [cu] appended.  I need to look up [cu]
<li>and figure out its semantics.  An arbitrary name word may now be used as a dimension, as well.
<p>
NI <- (sp? NI2 (&(M UE) Acronym (comma/&end/&period) !(C u)/comma2? M UE comma2? PreName !(C u))? (C u)?)
<p>
<li>mex is now identical with NI, but it's in use in later rules.
<p>
mex <- (sp? NI)

<p>

<h4> The overused CI</H4>

<li>a word used for various tightly binding constructions:  a sort of verbal hyphen.
<li>also a name marker, which means phonetic care is needed (pause after constructions with [ci]).
<p>
CI <- (sp? (C i))

<h4>Acronyms</H4>

<li>Acronyms, which are names (not predicates as in 1989 Loglan) or dimensions (in NI above).
<li>units in acronym are TAI0 letterals, zV short forms for vowels, the dummy unit [mue], and NI1
<li>quantity units.  NI1 quantity units may not be initial. [mue] units may be preceded by pauses.
<li>An acronym has at least two units.
<p>


<li>it is worth noting that acronyms, once viewed as names, could be entirely suppressed as a feature of the
<li>grammar by really making them names (terminate them with -n).  I suppose a similar approach would work
<li>for dimensions, allowing any name word to serve as a dimension.  [mue] would be a name marker for use
<li>with dimensions in this case.  [temuedain], three dollars.  Now supported.

<p>

Acronym <- (sp? &caprule ((M UE)/TAI0/(Z V2 !V2)) ((comma &Acronym M UE)/NI1/TAI0/(Z V2 (!V2/(Z &V2))))+)

<p>

<h4>Letterals and other pronouns</H4>

<li>the full class of letterals, including the [gao] construction whose details I should look at.

<p>

TAI <- (sp? (TAI0/((G AO) !V2 sp? (PreName/Predicate/CmapuaUnit))))
<p>
<li>atomic non-letteral pronouns.
<p>
#4/15/2019 reserved [koo] for a Lojban style imperative pronoun, though not officially adopting it.  Also adding [dao] for a default, don't care argument, another Lojban feature.
<p>
DA0 <- ((T AO)/(T IO)/(T UA)/(M IO)/(M IU)/(M UO)/(M UU)/(T OA)/(T OI)/(T OO)/(T OU)/(T UO)/(T UU)/(S UO)/(H u)/(B a)/(B e)/(B o)/(B u)/(D a)/(D e)/(D i)/(D o)/(D u)/(M i)/(T u)/(M u)/(T i)/(T a)/(M o)/(K OO)/(D AO))
<p>
<li>letterals (not including [gao] constructions and atomic pronouns optionally suffixed with a digit.  One should pause after the
<li>suffixed forms, because [ci] is a name marker.
<p>
DA1 <- ((TAI0/DA0) (C i ![ ] NI0)?)
<p>
<li>general pronoun words.

DA <- (sp? DA1)
<p>

<h4>Tenses, locatives and modals</H4>

<li>roots for PA words:  tense and location words, prepositions building relative modifiers.  All can optionally be negated with -noi.  They may also be quantified.  They may also be closed with ZI class affixes.  PA cores.
<p>
<li> put the long list of atomic PA words in a wrapper
<p>
PAX <- ((G IA)/(G UA)/(P AU)/(P IA)/(P UA)/(N IA)/(N UA)/(B IU)/(F EA)/(F IA)/(F UA)/(V IA)/(V II)/(V IU)/(C OI)/(D AU)/(D II)/(D UO)/(F OI)/(F UI)/(G AU)/(H EA)/(K AU)/(K II)/(K UI)/(L IA)/(L UI)/(M IA)/(N UI)/(P EU)/(R OI)/(R UI)/(S EA)/(S IO)/(T IE)/ (V IE)/(V a)/(V i)/(V u)/(P a)/(N a)/(F a)/(V a)/(KOU !(N OI) !KI))
<p>

PA0 <- (NI2? (N u !KOU)? PAX (N OI)? ZI?)
<p>
<li>the form used for actual prepositions and suffixes to A words, with minimal pauses allowed.
<li>these are built by concatenating KOU2 and PA0 units, then linking these with CA0 roots (which can take
<li>no- prefixes and -noi suffixes, and next to which one *can* pause), optionally suffixed with a class ZI suffix.
<p>
PANOPAUSES <- ((KOU2/PA0)+ ((comma2? CA0 comma2?) (KOU2/PA0)+)*)
<p>
<li>prepositional words
<p>
PA3 <- (sp? PANOPAUSES)
<p>
<li>class PA can appear as tense markers or as relative modifiers without arguments; here pauses
<li>are allowed not only next to CA0 units but between KOU2/PA units.  Like NI words, PA
<li>words are a class of arbitrary length constructions, and we think breaths within them
<li>(especially complex ones) are natural.
<p>
PA <- ((KOU2/PA0)+ (((comma2? CA0 comma2?)/(comma2 !mod1a)) (KOU2/PA0)+)*) !modifier
<p>
PA2 <- (sp? PA)
<p>
GA <- (sp? (G a))
<p>
<li>the class of tense markers which can appear before predicates.
<p>
PA1 <- ((PA2/GA))
<p>
<li>suffixes which indicate extent or remoteness/proximity of the action of prepositions.

ZI <- ((Z i)/(Z a)/(Z u))

<p>
<h4> Articles and other descriptors</H4>
<li>the primitive description building "articles".  These include [la] which requires special
<li>care in its use because it is a name marker.
<p>
LE <- (sp? ((L EA)/(L EU)/(L OE)/(L EE)/(L AA)/(L e)/(L o)/(L a)))
<p>
<li>articles which can be used with abstract descriptions:  these include some quantity words.
<li>this means that some abstract descriptions are semantically indefinites:  I wonder if this
<li>could be improved by having a separate abstract indefinite construction.
<p>
LEFORPO <- (sp? ((L e)/(L o)/NI2))
<p>
<li>the numerical/quantity article.
<p>
LIO <- (sp? (L IO))
<p>
<li>structure words for the ordered and unordered list constructions.
<p>
LAU <- (sp? (L AU))
<p>
LOU <- (sp? (L OU))
<p>
LUA <- (sp? (L UA))
<p>
LUO <- (sp? (L UO))
<p>
ZEIA <- (sp? Z EIb a)
<p>
ZEIO <- (sp? Z EIb o)
<p>
<li>initial and final words for quoting Loglan utterances.
<p>
LI1 <- (L i)
<p>
LU1 <- (L u)
<p>

<h4>Quotations and other alien text constructions</H4>
<li>quoting Loglan utterances, with or without explicit double quotes (if they appear, they must
<li>appear on both sides).  The previous version allowed quotation of names;  likely this should
<li>be restored.
<p>
LI <- (sp? LI1 comma2? utterance0 comma2? LU1/sp? LI1 comma2? [\"] utterance0 [\"] comma2? LU1)
<p>
<li>the foreign name construction.  This is an alien text construction
<p>
LAO <- (sp? &(LAOalien juncture?) AlienWord)
<p>
<li>the strong quotation construction.  This is an alien text construction.
<p>
LIE <- (sp? &(LIEalien juncture?) AlienWord)
<p>
LIO1 <- (sp? &(LIOalien juncture?) AlienWord)
<p>


<li>I am not sure this class is used at all.
<p>
LW <- Cmapua
<p>
<li>articles for quotation of words
<p>
LIU0 <- ((L IU)/(N IU))
<p>
<li>this now imposes the condition that an explicit comma pause (or terminal punctuation, or end) must appear at the end of the
<li>Word or PreName quoted with [liu].  This seems like a good idea, anyway.
<p>
<li>this class appeals to the phonetics.  Words and PreNames can be quoted.  The ability to quote names
<li>here may remove the need to quote them with [li]...[lu].  Of course, some Words are in fact phrases rather
<li>than single words:  we will see whether the privileges afforded are used.  The final clause allows
<li>use of letterals as actual names of letters.
<p>
<li>added [niu]:  didn't make it a name marker.
<p>

LNIU <- ([Ll]/[Nn])[iI] juncture? [Uu]

<p>

<p>

LIU1 <- (sp? LNIU juncture? !V1 comma2? (PreName/Word) &(comma/terminal/end) /sp?(L II TAI ))
<p>
<li>the construction of foreign and onomatopoeic predicates.  These are alien text constructions.

#p

SUE <- (sp? &([Ss] [Uu] juncture? [Ee] juncture?/[Ss] [Aa] [Oo] juncture?) AlienWord)
<p>

<h4>Assorted left and right closers</H4>
<li>left marker in a predicate metaphor construction
<p>
CUI <- (sp? (C UI) )
<p>
<li>other uses of GA
<p>
GA2 <- (sp? (G a) )
<p>
<li>ge/geu act as "parentheses" to make an atomic predicate from a complex metaphorically
<li>and logically connected predicates;  [ge] has other left marking uses.
<p>
GE <- (sp? (G e) )
<p>
GEU <- (sp? ((C UE)/(G EU)) )
<p>
<li>final marker of a list of head terms
<p>
GI <- (sp? ((G i)/(G OI)) )
<p>
<li>used to move a normally prefixed metaphorical modifier after what it modifies.
<p>
GO <- (sp? (G o) )
<p>
<li>marker for second and subsequent arguments before the predicate; NEW
<p>
GIO <- (sp? (G IO) )
<p>
<li>the generic right marker of many constructions.
<p>
GU <- (sp? (G u) )

<li>various flavors of right markers.

<li>It should be noted that at one point I executed a program of simplifying these to
<li>reduce the likelihood that multiple [gu]'s would ever be needed to close an utterance.
<li>first of all, I made the closures leaner, moving them out of the classes closed
<li>to their clients so that they generally can be used only when needed. 
<li>Notably, the grammar of [guu] is quite different.   Second,
<li>I introduced some new flavors of right marker.  All can be realized with [gu],
<li>but if one knows the right flavor one can close the right structure with a single
<li>right closure.

<li>right markers of subordinate clauses (argument modifiers).
<li>[gui] closes a different class than in the trial.85 grammar, with
<li>similar but on the whole better results.
<p>
GUIZA <- (sp? (G UI) (Z a) )
<p>
GUIZI <- (sp? (G UI) (Z i) )
<p>
GUIZU <- (sp? (G UI) (Z u) )
<p>
GUI <- (!GUIZA !GUIZI !GUIZU (sp? (G UI) ))
<p>
<li>right markers of abstract predicates and descriptions.
<li>probably the forms with z are to be preferred (and the other
<li>two are not needed) but I preserve all five classes for now. 
<p>
GUO <- (sp? (G UO) )
<p>
GUOA <- (sp? (G UOb a/G UO Z a) )
<p>
GUOE <- (sp? (G UOb e) )
<p>
GUOI <- (sp? (G UOb i/G UO Z i) )
<p>
GUOO <- (sp? (G UOb o) )
<p>
GUOU <- (sp? (G UOb u/G UO Z u) )
<p>
<li>right marker used to close term (argument/predicate modifier) lists.
<li>it is important to note that in our grammar GUU is not a component of
<li>the class termset, nor is it a null termset:  it appears in other classes
<li>which include termsets as an option to close them.  The effects are similar
<li>to those in the trial.85 grammar, but there is less of a danger that
<li>extra unexpected closures will be needed.
<p>
GUU <- (sp? (G UU) )
<p>
<li>a new closure for arguments in various contexts
<p>
GUUA <- (sp? (G UUb a) )
<p>
<li>a new closure for sentences.  In particular, it
<li>may have real use in closing up the scope of a list of
<li>fronted terms before a series of logically connected sentences.
<p>
GIUO <- (sp? (G IUb o) )
<p>
<li>right marker used to close arguments tightly linked with JE/JUE.

GUE <- (sp? (G UE) )
<p>
<li>a new closure for descpreds

GUEA <- (sp? (G UEb a) )
<p>

<h4>Miscellaneous clause constructors</H4>

<li>used to build tightly linked term lists.
<p>
JE <- (sp? (J e) )
<p>
JUE <- (sp? (J UE) )
<p>
<li>used to build subordinate clauses (argument modifiers).
<p>
JIZA <- (sp? ((J IE)/(J AE)/(P e)/(J i)/(J a)/(N u J i)) (Z a) )
<p>
JIOZA <- (sp? ((J IO)/(J AO)) (Z a) )
<p>
JIZI <- (sp? ((J IE)/(J AE)/(P e)/(J i)/(J a)/(N u J i)) (Z i) )
<p>
JIOZI <- (sp? ((J IO)/(J AO)) (Z i) )
<p>
JIZU <- (sp? ((J IE)/(J AE)/(P e)/(J i)/(J a)/(N u J i)) (Z u) )
<p>
JIOZU <- (sp? ((J IO)/(J AO)) (Z u) )
<p>
JI <- (!JIZA !JIZI !JIZU (sp? ((J IE)/(J AE)/(P e)/(J i)/(J a)/(N u J i)) ))
<p>
JIO <- (!JIOZA !JIOZI !JIOZU (sp? ((J IO)/(J AO)) ))
<p>

<h4>Case tags, semantic and positional</H4>
<li>case tags, both numerical position tags and the optional semantic case tags.
<p>
DIO <- (sp? ((B EU)/(C AU)/(D IO)/(F OA)/(K AO)/(J UI)/(N EU)/(P OU)/(G OA)/(S AU)/(V EU)/(Z UA)/(Z UE)/(Z UI)/(Z UO)/(Z UU)) ) (C i ![ ] NI0/ZI)?
<p>
<li>markers of indirect reference.  Originally these had the same grammar as case tags,
<li>but they are now different.
<p>
LAE <- (sp? ((L AE)/(L UE)) )
<p>

<h4> The predicate constructor me</H4>
<li>[me] turns arguments into predicates, [meu] closes this construction.
<p>
ME <- (sp? ((M EA)/(M e)) )
<p>
MEU <- (sp? M EU )
<p>
<h4> Reflexive and conversion operators</H4>
<p>
<li>reflexive and conversion operators:  first the root forms, then those with
<li>optional numerical suffixes.
<p>
NU0 <- ((N UO)/(F UO)/(J UO)/(N u)/(F u)/(J u))
<p>
NU <- sp? (((N u/N UO) !(sp (NI0/RA)) (NI0/RA)?)/NU0)+ freemod?
<p>

<h4>Abstract predicate constructors</H4>

<li>I do *not* think
<li>that [poia] will really be confused with [po ia], particularly
<li>since we do require an explicit pause before [ia] in the latter case,
<li>but I record this concern:  the forms with z might be preferable.
<p>
#constructions from sentences

<p>
PO1 <- (sp? ((P o)/(P u)/(Z o)))
<p>
PO1A <- (sp? ((P OIb a)/(P UIb a)/(Z OIb a)/(P o Z a)/(P u Z a)/(Z o Z a)))
<p>
PO1E <- (sp? ((P OIb e)/(P UIb e)/(Z OIb e)))
<p>
PO1I <- (sp? ((P OIb i)/(P UIb i)/(Z OIb i)/(P o Z i)/(P u Z i)/(Z o Z i)))
<p>
PO1O <- (sp? ((P OIb o)/(P UIb o)/(Z OIb o)))
<p>
PO1U <- (sp? ((P OIb u)/(P UIb u)/(Z OIb u)/(P o Z u)/(P u Z u)/(Z o Z u)))
<p>
<li>abstract predicate constructor from simple predicates
<p>
POSHORT1 <- (sp? ((P OI)/(P UI)/(Z OI)))
<p>
<li>word forms associated with the above abstract predicate root forms
<p>
PO <- (sp? PO1 )
<p>
POA <- (sp? PO1A )
<p>
POE <- (sp? PO1E )
<p>
POI <- (sp? PO1E )
<p>
POO <- (sp? PO1O )
<p>
POU <- (sp? PO1U )
<p>
POSHORT <- (sp? POSHORT1 )
<p>


<h4> register markers </H4>
<p>
DIE <- (sp? ((D IE)/(F IE)/(K AE)/(N UE)/(R IE)) )
<p>
<h4> freemods and freemod builders </H4>
<p>
<li>vocative forms:  I still have the words of social lubrication as 
<li>vocative markers.
<p>
HOI <- (sp? ((H OI)/(L OI)/(L OA)/(S IA)/(S IE)/(S IU)) )
<p>
<li>the verbal scare quote.  The quantifier suffix indicates how many preceding words are affected;
<li>this is an odd mechanism.
<p>
JO <- (sp? (NI0/RA/SA)? (J o) )
<p>
<li>markers for forming parenthetical utterances as free modifiers.
<p>
KIE <- (sp? (K IE) )
<p>
KIU <- (sp? (K IU) )
<p>
KIE2 <- sp? K IE comma2? [(]
<p>
KIU2 <- sp? [)] comma2? K IU
<p>
<li>marker for forming smilies.
<p>
SOI <- (sp? (S OI) )
<p>
<li>a grab bag of attitudinal words, including but not restricted to the VV forms.
<p>
UI0 <- (!predstart (!([Ii] juncture? [Ee]) VV juncture?/(B EA)/(B UO)/(C EA)/(C IA)/(C OA)/(D OU)/(F AE)/(F AO)/(F EU)/(G EA)/(K UO)/(K UU)/(R EA)/(N AO)/(N IE)/(P AE)/(P IU)/(S AA)/(S UI)/(T AA)/(T OE)/(V OI)/(Z OU)/((L OI))/((L OA))/((S IA))/(S II)/(T OE)/((S IU))/(C AO)/(C EU)/((S IE))/(S EU)/(S IEb i)))
<p>
<li>negative forms of the attitudinals.  The ones with [no] before the two vowel forms are a phonetic exception.  The others
<li>should also be (though they present no pronunciation problem) so that they are resolved as single words.
<p>
<li>  There is a strong reason for [o] here.
<p>
NOUI <- ((sp? UI0 NOI)/(sp? N [o] juncture? comma? sp? UI0 ))
<p>
<li>all attitudinals (adding the discursives nefi, tofi... etc)
<li>there is a technical problem with mixing UI0 roots of VV and CVV shapes.
<p>
UI1 <- (sp? (UI0+/(NI F i)) )
<p>
<li>the inverse vocative marker
<p>
HUE <- (sp? (H UE))
<p>
<h4>Negation</H4>

<li>occurrences of [no] as a word rather than an affix.
<p>
NO1 <- (sp? !KOU1 !NOUI (N o) !(comma2? Z AO comma2? Predicate) !(sp? KOU) !(sp? (JIO/JI/JIZA/JIOZA/JIZI/JIOZI/JIZU/JIOZU)) )
<p>

<h3> The large word classes (names and predicates)</H3>
<li>Names, acronyms and PreNames from above.
<p>
AcronymicName <- Acronym &(comma/period/end)
<p>
DJAN <- (PreName/AcronymicName)
<p>
<li>predicate words which are phonetically cmapua
<p>
<li>"identity predicates".  Converses are provided as a new proposal.
<p>
BI <- (sp? (N u)? ((B IA)/(B IE)/(C IE)/(C IO)/(B IA)/(B i)/(B II)) )
<p>
<li>interrogative and pronoun predicates
<p>
LWPREDA <- ((H e)/(D UA)/(D UI)/(B UA)/(B UI))
<p>
<li>here I should reinstall the [zao] proposal.
<p>
<li>the predicate words defined above in the phonetics section
<p>
Predicate <- (CmapuaUnit comma2?  Z AO comma2?)* Complex (comma2? Z AO comma2? Predicate)?
<p>
<li>predicate words, other than the "identity predicates" of class [BI]
<li>these include the numerical predicates (NI RA), also cmapua phonetically.
<p>
<li>we are installing John Cowan's [zao] proposal here, experimentally, 4/15/2019
<p>
PREDA <- (sp? &caprule (Predicate/LWPREDA/(![ ] NI RA)) )
<p>
<h2>Part 3:  The Grammar Proper</H2>

<h3>Right markers turned into classes</H3>

guoa <- (PAUSE? (GUOA/GU) freemod?)
<p>
guoe <- (PAUSE? (GUOE/GU) freemod?)
<p>
guoi <- (PAUSE? (GUOI/GU) freemod?)
<p>
guoo <- (PAUSE? (GUOO/GU) freemod?)
<p>
guou <- (PAUSE? (GUOU/GU) freemod?)
<p>
guo <- (!guoa !guoe !guoi !guoo !guou (PAUSE? (GUO/GU) freemod?))
<p>
guiza <- (PAUSE? (GUIZA/GU) freemod?)
<p>
guizi <- (PAUSE? (GUIZI/GU) freemod?)
<p>
guizu <- (PAUSE? (GUIZU/GU) freemod?)
<p>
gui <- (PAUSE? (GUI/GU) freemod?)
<p>
gue <- (PAUSE? (GUE/GU) freemod?)
<p>
guea <- (PAUSE? (GUEA/GU) freemod?)
<p>
guu <- (PAUSE? (GUU/GU) freemod?)
<p>
guua <- (PAUSE? (GUUA/GU) freemod?)
<p>
giuo <- (PAUSE? (GIUO/GU) freemod?)
<p>
meu <- (PAUSE? (MEU/GU) freemod?)
<p>
geu <- GEU
<p>
<li>Here note the absence of pause/GU equivalence.
<p>
gap <- (PAUSE? GU freemod?)
<p>

<h3>The vocative and inverse vocative</H3>
<li>this is the vocative construction.  It can appear early because all of its components are marked.
<p>
<li>the intention is to indicate who is being addressed.  This can be handled via a name, a descriptive argument, a predicate or an
<li>alien text name (the last must be quoted).  The complexities of these grammatical constructions can be deferred until they are
<li>introduced.
<p>
<li>HOI0 <- sp? [Hh] [Oo] [Ii] juncture?  
<p>
<li>restore words of social lubrication as vocative markers but not as name markers:  [loi, Djan]  
<p>
<li>I do not allow a freemod to intervene between a vocative marker and the associated
<li>utterance, to avoid unintended grabbing of subjects by the words of social lubrication when they are used
<li>as vocative markers.  This lets [Loi, Djan] and [Loi hoi Djan] be equivalent.  The comma needed in the
<li>first because the social lubrication words are in this version not name markers.
<p>    
HOI0 <- (sp? ((([Hh] OI)/([Ll] OI)/([Ll] OA)/([Ss] IA)/([Ss] IE)/([Ss] IU)))) juncture? !V1
<p>
voc <- (HOI0 comma2? name /(HOI comma2? descpred guea? namesuffix?)/(HOI comma2? argument1 guua?)/sp? &([Hh] [Oo] [Ii] juncture?) AlienWord)
<p>
<li>this is the inverse vocative.  It can appear early because all of its components are marked.
<p>
<li>the intention is to indicate who is speaking.  The range of ways this can be handled is similar to the range of ways it can be
<li>handled for the vocative;  there is the further option of a sentence (the [statement] class) and there is a strong closure option
<li>for the case where an argument is used (to avoid it inadvertantly expanding to a sentence).
<p>
HUE0 <- sp? &caprule [Hh] [Uu] juncture? [Ee] juncture? !V1
<p>
invvoc <- (HUE0 comma2? name/HUE freemod? descpred guea? namesuffix?/(HUE freemod? statement giuo?)/(HUE freemod? argument1 guu?)/sp? &([Hh] [Uu] juncture? [Ee] juncture?) AlienWord)
<p>
<h3>Free modifiers</H3>
<li>this is the class of free modifiers.  Most of its components are head marked (those that aren't appear just above),
<li>and it is useful for it to appear early because these things appear everywhere in subsequent constructions.  A free modifier,
<li>of whatever sort, is a freely insertable gadget which modifies the immediately preceding construction, or the entire utterance
<li>if it is initial.

<p>

<li>NOUI is a negated attitudinal word.  UI1 is an attitudinal word:  these express an emotional attitude toward the 
<li>assertion (noting that EI marks questions (yes or no answer expected) and SEU marks utterances as answers).
<p>
<li>SOI creates smilies in a general sense:  [soi crano] indicates that the listener should imagine the speaker smiling;
<li>similarly for other predicates.
<p>
<li>DIE and NO DIE are register markers, communicating the social attitude of the speaker toward the one addressed:  [die] for
<li>example is "dear"
<p>
<li>KIE...KIU constructs a full parenthetical utterance as a comment, which can be enclosed in actual parentheses inside
<li>the marker words.
<p>
<li>JO is a scare quote device.
<p>
<li>deletion of a previous word or wordlike unit (or more than one) using K IA
<p>
kiamod <- comma2? !(!PreName !predstart K IA) ((PreName/LIU1/AlienWord/Cmapua (sp? (!(K IA)) !PreName !predstart Cmapua)*/Word) kiamod* comma2? !PreName !predstart K IA) comma2?
<p>
<li>the comma is a freemod with no semantic content:  this is a device for discarding phonetically required pauses
<li>and the speaker's optional pauses alike.   The pause before a non-pause marked prename is part of the NameWord and so
<li>is excluded.  Ellipses and dashes are fancy pauses supported as freemods.
<p>
freemod <- ((kiamod/NOUI/(SOI freemod? descpred guea?)/DIE/(NO1 DIE)/(KIE comma? utterance0 comma? KIU)/(KIE2 comma? utterance0 comma? KIU2)/invvoc/voc/(comma !(!FalseMarked PreName))/JO/UI1/(sp? '...' (sp? &letter)?)/(sp? '--' (sp? &letter)?)) freemod?)
<p>
<h3>Tightly bound arguments and lists thereof</H3>

<li>the classes juelink to linkargs describe very tightly bound arguments which can be firmly attached to predicates in 
<li>the context of metaphorical modifications and the use of predicates in descriptive arguments.
<p>
<li>note that we allow predicate modifiers (prepositional phrases) to be bound with [je/jue] which is not
<li>allowed in 1989 Loglan, but which we believe is supported in Lojban.
<p>
juelink <- (JUE freemod? (term/(PA2 freemod? gap?)))
<p>
links1 <- (juelink (freemod? juelink)* gue?)
<p>
links <- ((links1/(KA freemod? links freemod? KI freemod? links1)) (freemod? A1 freemod? links1)*)
<p>
jelink <- (JE freemod? (term/(PA2 freemod? gap?)))
<p>
linkargs1 <- (jelink freemod? (links/gue)?)
<p>
linkargs <- ((linkargs1/(KA freemod? linkargs freemod? KI freemod? linkargs1)) (freemod? A1 freemod? linkargs1)*)
<p>

<h3>Abstract argument constructions</H3>
<li>class abstractpred supports the construction of event, property, and quantity predicates from sentences.  These are
<li>closable with [guo] if introduced with [po,pu,zo] and closable with suffixed variants of [guo] if introduced with suffixed
<li>variants of [po,pu,zo] (a NEW idea but it is clear that closure of these predicates (and of the more commonly
<li>used associated descriptions) is an important issue).

<p>

<li> using sentenceclone so that subject free sentences will not be marked as imperative

<p>

abstractpred <- ((POA freemod? uttAxclone guoa?)/(POA freemod? sentenceclone guoa?)/(POE freemod? uttAxclone guoe?)/(POE freemod? sentenceclone guoe?)/(POI freemod? uttAxclone guoi?)/(POI freemod? sentenceclone guoi?)/(POO freemod? uttAxclone guoo?)/(POO freemod? sentenceclone guoo?)/(POU freemod? uttAxclone guou?)/(POU freemod? sentenceclone guou?)/(PO freemod? uttAxclone guo?)/(PO freemod? sentenceclone  guo?))
<h3>Atomic predicates (predunit)</H3>
<li>predunit1 describes the truly atomic forms of predicate.
<p>
<li>PREDA is the class of predicate words (the phonetic predicate words along with the special phonetic cmapua which are predicates, listed
<li>above under the PREDA rule.  NU PREDA handles permutations and identifications of arguments of PREDAs.
<p>
<li>SUE contains the alien text constructions with [sao] and [sue], semantically quite different but syntactically handled
<li>in the same way.
<p>
<li>[ge]...[geu/cue] (the closing optional) can parenthesize a fairly complex predicate phrase and turn it into an atomic form.  These
<li>forms can have conversion or reflexive operators (NU) applied.  I should look into why the class handled in the conversion case
<li>is different.  An important use of this is in metaphor constructions, but it has other potential uses.
<p>
<li>abstractpred is the class of abstraction predicates just introduced above.  These are treated as atomic in this grammar:  it should
<li>be noted that their privileges in the trial.85 grammar are (absurdly) limited.
<p>
<li>[me]...[meu] (the closing optional, but important to have available) forms predicates from arguments, the predicate being true of the
<li>objects to which the argument refers.  [Ti me le mrenu] :  this is one of the men we are talking about.
<p>
predunit1 <- ((SUE/(NU freemod? GE freemod? despredE (freemod? geu comma?)?)/(NU freemod? PREDA)/(comma? GE freemod? descpred (freemod? geu comma?)?)/abstractpred/(ME freemod? argument1 meu?)/PREDA) freemod?)
<p>
<li>[no] binds very tightly to predunit1:  a possibly multiply negated predunit1 (or an unadorned predunit1) is a predunit2.
<p>
predunit2 <- ((NO1 freemod?)* predunit1)
<p>

<li>an instance of NO2 is one not absorbed by a predunit.  Example:  [Da no kukra prano]  X is a slow (not-fast) runner vs
<li>[Da no ga kukra prano]  (X is not a fast runner, and in fact may not run at all).
<p>
NO2 <- (!predunit2 NO1)
<p>
<li>a predunit3 is a predunit2 with tightly attached arguments.
<p>
predunit3 <- ((predunit2 freemod? linkargs)/predunit2)
<p>
<li>a predunit is a predunit3 or a predunit3 converted by the short-scope abstraction operators
<li>[poi/pui/zoi] to an abstraction predicate.  This is the kind of predicate which can appear as
<li>a component in a serial name.
<p>
predunit <- ((POSHORT freemod?)? predunit3)
<p>
<li>a further "atomic" (because tightly packaged) form is a forethought connected pair
<li>of predicates (this being the full predicate class defined at the end of the process)
<li>possibly closed with [guu], possibly multiply negated as well.
<p>
<li>the closure with guu eliminated the historic rule against kekked heads of metaphors.
<p>
kekpredunit <- ((NO1 freemod?)* KA freemod? predicate freemod? KI freemod? predicate guu?)
<p>

<h4>The construction of metaphors</H4>
<li>there follows the construction of metaphorically modified predicates, 
<li>along with tightly logically linked predicates.

<p>

<li>CI and simple juxtaposition of predicates both represent modification of the second
<li>predicate by the first.  We impose no semantic conditions on this modification,
<li>except in the case of modification by predicates logically linked with CA,
<li>which do distribute logically in the expected way both as modifiers and as modified.
<li>We do not regard [preda1 preda2] as necessarily implying preda2:  we do regard
<li>it as having the same place structure as preda2.  It is very often but not always
<li>a qualification or kind of preda2;  in any case it is a relation analogous to preda2.

<p>

<li>modification with CI binds most tightly.

<p>

<li>we eliminated the distinction between the series of sentence and description
<li>predicate preliminary classes:  there seems to be no need for it even in the 
<li>trial.85 grammar.

<p>

despredA <- ((predunit/kekpredunit) (freemod? CI freemod? (predunit/kekpredunit))*)

<p>

<li>this is logical connection of predicates with the tightly binding CA
<li>series of logical connectives.  CUI can be used to expand the scope of
<li>a CA connective over a metaphor on the left.  [ge]...[geu] is used to expand
<li>scope on the right (and could also be used on the left, it should be noted).
<li>descpredC is an internal of despredB assisting the function of CUI.
<li>the !PREDA in front of CUI is probably not needed.

<p>

despredB <- ((!PREDA CUI freemod? despredC freemod? CA freemod? despredB)/despredA)
<p>
despredC <- (despredB (freemod? despredB)*)
<p>
<li>tight logical linkage of despredB's

<p>

despredD <- (despredB (freemod? CA freemod? despredB)*)

<p>

<li>chain of modifications of despredD's (grouping to the left)

<p>

despredE <- (despredD (freemod? despredD)*)

<p>

<li>the GO construction allows inverse modification:  [preda1 GO preda2] is [preda2 preda1] as it were.
<li> there are profound effects on grouping.

<p>

descpred <- ((despredE freemod? GO freemod? descpred)/despredE)

<p>

<li>this version which appears in sentence predicates as opposed to descriptions differs
<li>in allowing loosely linked arguments (termsets) instead of those linked with [je/jue] for the predicate
<li>moved to the end by GO.

<p>

sentpred <- ((despredE freemod? GO freemod? barepred)/despredE)

<p>

<h3>Construction of sentence modifiers</H3>

<li>the construction of predicate modifiers (prepositional phrases usable as terms along with arguments).

<p>

mod1a <- (PA3 freemod? argument1 guua?)

<p>

<li>note special treatment of predicate modifiers without actual arguments.
<li>the !barepred serves to distinguish these predicate modifiers from actual
<li>"tenses" (predicate markers).

<p>

mod1 <- ((PA3 freemod? argument1 guua?)/(PA2 freemod? !barepred gap?))

<p>

<li>forethought connection of modifiers.  There is some subtlety in
<li>how this is handled.

<p>

kekmod <- ((NO1 freemod?)* (KA freemod? modifier freemod? KI freemod? mod))

<p>

mod <- (mod1/((NO1 freemod?)* mod1)/kekmod)

<p>

<li>afterthought connection of modifiers

<p>

modifier <- (mod (A1 freemod? mod)*)

<p>

<h3>Serial names (a flash point)</H3>

<li>the serial name is a horrid heterogenous construction!  It can involve
<li>components of all three of the major phonetic classes essentially!

<li>However, I believe I have the definition right, with all the components
<li>correctly guarded :-)

<p>

name <- (PreName/AcronymicName) (comma2? !FalseMarked PreName/comma2? &([Cc] [Ii]) NameWord/comma2? CI predunit !(comma2? (!FalseMarked PreName))/comma2? CI AcronymicName)* freemod? 

<p>

LA0 <- sp? [Ll] [Aa] juncture?  

<p>

LANAME <- (LA0 comma2? name)

<p>

<h3>General construction of descriptive arguments</H3>

<li>general constructions of arguments with "articles".

<p>

<li>the rules here have the "possessive" construction as in [lemi hasfa; le la Djan, hasfa] embedded.  These are not the same
<li>construction in 1989 Loglan, though speakers might think they are.  Here they are indeed the same.  The "possessor" cannot
<li>be "indefinite" (cannot start with a quantifier word);  the possessor can be followed by a tense, as in 
<li>[le la Djan, na hasfa], "John's present house", by analogy with [lemina hasfa], which is accepted by LIP (because
<li>LIP accepts [lemina] as a word).

<p>

<li>there are other subtleties to be reviewed.

<p>

descriptn <- (!LANAME ((LAU wordset1)/(LOU wordset2)/(LE freemod? ((!mex arg1a freemod?)? (PA2 freemod?)?)? (mex freemod? arg1a/mex freemod? descpred/descpred))/(GE freemod? mex freemod? descpred)))

<p>

<li>abstract descriptions.  Note that abstract descriptions are closed with [guo] entirely independently of abstract predicates:
<li>[le po preda guo] does not have a grammatical component [po preda guo].  This avoids the double closure often apparently necessary
<li>in Lojban.

<p>

abstractn <- ((LEFORPO freemod? POA freemod? uttAxclone guoa?)/(LEFORPO freemod? POA freemod? sentenceclone guoa?)/(LEFORPO freemod? POE freemod? uttAxclone guoe?)/(LEFORPO freemod? POE freemod? sentenceclone guoe?)/(LEFORPO freemod? POI freemod? uttAxclone guoi?)/(LEFORPO freemod? POI freemod? sentenceclone guoi?)/(LEFORPO freemod? POO freemod? uttAxclone guoo?)/(LEFORPO freemod? POO freemod? sentenceclone guoo?)/(LEFORPO freemod? POU freemod? uttAxclone guou?)/(LEFORPO freemod? POU freemod? sentenceclone guou?)/(LEFORPO freemod? PO freemod? uttAxclone guo?)/(LEFORPO freemod? PO freemod? sentenceclone guo?))

<p>

<li>a wider class of basic argument constructions.  Notice that LANAME is always read by preference to descriptn.

<p>

CIforsuffix <- [Cc][Ii]

<p>

namesuffix <- (&(comma2 !FalseMarked PreName/sp? CIforsuffix juncture? comma2? (PreName/AcronymicName)) (sp? CIforsuffix juncture? comma2?/comma2)? name)

<p>

arg1 <- (abstractn/(LIO freemod? descpred guea?)/(LIO freemod? argument1 guua?)/(LIO freemod? mex gap?)/LIO1/LAO/LANAME/(descriptn guua? namesuffix?)/LIU1/LIE/LI)

<p>

<li>this adds pronouns (incl. the fancy [gao] letterals) and the option of left marking an argument with [ge]
<p>
arg1a <- ((DA/TAI/arg1/(GE freemod? arg1a)) freemod?)

<p>

<h4>Argument modifiers (subordinate clauses)</H4>

argmod1 <- (((sp? (N o) sp?)? ((JI freemod? predicate)/(JIO freemod? sentence)/(JIO freemod? uttAx)/(JI freemod? modifier)/(JI freemod? argument1)))/((sp? (N o) sp?)? (((JIZA freemod? predicate) guiza?)/((JIOZA freemod? sentence) guiza?)/((JIOZA freemod? uttAx) guiza?)/((JIZA freemod? modifier) guiza?)/(JIZA freemod? argument1 guiza?)))/((sp? (N o) sp?)? ((JIZI freemod? predicate guizi?)/(JIOZI freemod? sentence guizi?)/(JIOZI freemod? uttAx guizi?)/(JIZI freemod? modifier guizi?)/(JIZI freemod? argument1 guizi?)))/((sp? (N o) sp?)? ((JIZU freemod? predicate guizu?)/(JIOZU freemod? sentence guizu?)/(JIOZU freemod? uttAx guizu?)/(JIZU freemod? modifier guizu?)/(JIZU freemod? argument1 guizu?))))
<p>
<li>we improved the trial.85 grammar by closing not argmod1 but argmod with [gui].  But the labelled argument modifier constructors
<li>when building an argmod1 have the argmod1 construction closed with the corresponding labelled right marker, of course.  Thus
<li>gui and guiza actually have different grammar.
<p>
<li>trial.85 did not provide forethought connected argument modifiers, and we also see no need for them,
<li>though they could readily be added.
<p>
argmod <- (argmod1 (A1 freemod? argmod1)* gui?)

<p>

<h4>Arguments resume</H4>

<li>affix argument modifiers to a definite argument

<p>

arg2 <- (arg1a freemod? argmod*)

<p>

<li>build a possibly indefinite argument from an argument:  to le mrenu

<p>

arg3 <- (arg2/(mex freemod? arg2))

<p>

<li>build an indefinite argument from a predicate

<p>

indef1 <- (mex freemod? descpred)

<li>affix an argument modifier to an indefinite argument

<p>

indef2 <- (indef1 guua? argmod*)

<p>

indefinite <- indef2

<p>

<li>link arguments with the fusion connective [ze]

<p>

arg4 <- ((arg3/indefinite) (ZE2 freemod? (arg3/indefinite))*)

<p>

<li>forethought connection of arguments.  Note use of argx

<p>

arg5 <- (arg4/(KA freemod? argument1 freemod? KI freemod? argx))

<p>

<li>arguments with possible negations followed by possible indirect reference constructions.

<p>

argx <- ((NO1 freemod?)* (LAE freemod?)* arg5)

<p>

<li>afterthought connection with the tightly binding ACI connectives

<p>

arg7 <- (argx freemod? (ACI freemod? argx)?)

<p>

<li>afterthought connection with the usual A connectives.  Can't start with GE
<li>to avoid an ambiguity (to which 1989 Loglan is vulnerable) involving AGE connectives.

<p>

arg8 <- (!GE (arg7 freemod? (A1 freemod? arg7)*))

<p>

<li>afterthought connection (now right grouping, instead of the left grouping above)
<li>using the AGE connectives.  GUU can be used to affix an argument modifier at this top level.

<p>

argument1 <- (((arg8 freemod? AGE freemod? argument1)/arg8) (GUU freemod? argmod)*)

<p>

<li>possibly negated and case tagged arguments.  We (unlike 1989 Loglan) are careful
<li>to use argument only where case tags are appropriate.

<p>

argument <- ((NO1 freemod?)* (DIO freemod?)* argument1)

<p>

<li>an argument which is actually case tagged.

<p>

argxx <- (&((NO1 freemod?)* DIO) argument)

<p>

<h3>Term lists</H3>

<li>arguments and predicate modifiers actually associated with predicates.

term <- (argument/modifier)

<p>

<li>a term list consisting entirely of modifiers.

<p>

modifiers <- (modifier (freemod? modifier)*)

<p>

<li>a term list consisting entirely of modifiers and tagged arguments.

<p>

modifiersx <- ((modifier/argxx) (freemod? (modifier/argxx))*)

<p>

<li>the subject class is a list of terms (arguments and predicate modifiers) in which all but possibly one
<li>of the arguments are tagged, and there is at least one argument, tagged or otherwise.

<p>

subject <- ((modifiers freemod?)? ((argxx subject)/(argument (modifiersx freemod?)?)))

<p>


<li>these classes are exactly argument, but are used to signal
<li>which argument position after the predicate an argument occupies.
<li>I think the grammar is set up so that these will actually
<li>never be case tagged, though the grammar does not expressly forbid it.

<p>

argumentA <- argument 

<p>

argumentB <- argument 

<p>

argumentC <- argument 

<p>

<li> argumentC <- argument

<p>

argumentD <- argument 

<p>

<li>for argument lists not guarded against absorbing a following subject (now redundant)

<p>

argumentA1 <- argument

<p>

argumentB1 <- argument

<p>

argumentC1 <- argument

<p>

argumentD1 <- argument

<p>

<li>a general term list.  It cannot contain more than four untagged arguments (they will be labelled
<li>with the lettered subclasses given above).

<p>

terms <- ((modifiersx? argumentA (freemod? modifiersx)? argumentB? (freemod? modifiersx)? argumentC? (freemod? modifiersx)? argumentD?)/modifiersx)

<p>

<li>terms list not guarded against absorbing a following subject (now the same as terms)

<p>

terms1 <- ((modifiersx? argumentA1 (freemod? modifiersx)? argumentB1? (freemod? modifiersx)? argumentC1? (freemod? modifiersx)? argumentD1?)/modifiersx)

<p>

<li>innards of ordered and unordered list constructions.  These are something I totally rebuilt, as they were in a totally
<li>unsatisfactory state in trial.85.  Note the use of comma words to separate items in lists.
<p>
word <- (arg1a/indef2)
<p>

words1 <- (word (ZEIA? word)*)
<p>
words2 <- (word (ZEIO? word)*)
<p>
wordset1 <- (words1? LUA)

<p>

wordset2 <- (words2? LUO)

<p>

<li>the full term set type to be affixed to predicates.

<p>

<li>forethought connection of term lists

<p>

termset1 <- (terms/(KA freemod? termset2 freemod? guu? KI freemod? termset1))

<p>

<li>afterthought connection of term lists.  There are cunning things going on here getting [guu]
<li>to work correctly.  Note that [guu] is NOT a null term list as it was in trial.85.

<p>

termset2 <- (termset1 (guu &A1)? (A1 freemod? termset1 (guu &A1)?)*)

<p>

<li>there is an interesting option here of a list of terms followed by [go] followed by a predicate
<li>intended to metaphorically modify the predicate to which the terms are affixed.  Is there a reason
<li>why we cannot have a more complex construction in place of terms?

<p>

termset <- ((terms freemod? GO freemod? barepred)/termset2)

<p>

<h3>The general verb phrase construction</H3>

<li>this is the untensed predicate with arguments attached.  Here is the principal locus
<li>of closure with [guu], but it is deceptive to say that [guu] merely closes barepred,
<li>as we have seen above, for example in [termset2].

<p>

barepred <- (sentpred freemod? ((termset guu?)/(guu (&termset)))?)

<p>

<li>tensed predicates
<p>
markpred <- (PA1 freemod? barepred)
<p>
<li>there follows an area in which my grammar looks different from trial.85.  Distinct parallel forms for
<li>marked and unmarked predicates are demonstrably not needed even in trial.85.  The behavior of the ACI
<li>connectives is plain weird in trial.85; here we treat ACI connectives in the same way as A connectives, but
<li>binding more tightly.
<p>
<li>units for the ACI construction following -- possibly multiply negated bare or marked predicates.
<p>
<li>adding shared termsets to logically connected predicates are handled differently here than in trial.85,
<li>which uses a very elegant but dreadfully left-grouping rule which a PEG cannot handle.  Any realistic situation
<li>should be manageable.
<p>
backpred1 <- ((NO2 freemod?)* (barepred/markpred))
<p>

<li>ACI connected predicates.  Shared termsets are added.  Notice how we first group backpred1's then recursively
<li>group backpreds.
<p>
backpred <- (((backpred1 (ACI freemod? backpred1)+ freemod? ((termset guu?)/(guu &termset))?) ((ACI freemod? backpred)+ freemod? ((termset guu?)/(guu &termset))?)?)/backpred1)
<p>
<li>A connected predicates; same comments as just above.  Cannot start with GE to fix ambiguity with AGE connectives.
<p>
predicate2 <- (!GE (((backpred (A1 !GE freemod? backpred)+ freemod? ((termset guu?)/(guu &termset))?) ((A1 freemod? predicate2)+ freemod? ((termset guu?)/(guu &termset))?)?)/backpred))
<p>
<li>predicate2's linked with right grouping AGE connectives (A and ACI are left grouping).
<p>
predicate1 <- ((predicate2 AGE freemod? predicate1)/predicate2)
<p>
<li>identity predicates from above, possibly negated
<p>
identpred <- ((NO1 freemod?)* (BI freemod? argument1 guu?))
<p>
<li>predicates in general.  Note that identity predicates cannot be logically connected
<li>except by using forethought connection (see above).
<p>
predicate <- (predicate1/identpred)
<p>

<h3>The sentence</H3>

<li>The gasent is a basic form of the Loglan sentence in which the predicate leads.
<li>The basic structure is [PA word (usually a tense) or [ga]) followed optionally by terms followed optionally by
<li>[ga] followed by terms.  The list of terms after [ga] (if present) will either contain 
<li>at least one argument and no more than one untagged argument
<li>(a subject) [gasent1] or all the arguments of the predicate [gasent2].  We deprecate other arrangements possible in
<li>1989 Loglan because they would cause unexpected reorientation of the arguments already given before [ga] as second
<li>and further arguments were read after [ga].  [barepred] is an untensed predicate possibly with arguments; [sentpred]
<li>is "simply a verb", i.e., a predicate without arguments.
<p>
<li>there is a semantic change from 1989 Loglan reflected in a grammar change here:
<li>in [gasent1] the final (ga subject) is optional.  When it does not appear, the resulting
<li>sentence is an observative (a sentence with subject omitted), not an imperative.
<li>Imperatives for us are unmarked.

<p>
<li>4/22 allowing general predicates in gasent.  Otherwise the spaces of observatives and imperatives become quite confused.
<p>

gasent1 <- ((NO1 freemod?)* (freemod? &markpred predicate (GA2 freemod? subject)?))

<p>

gasent2 <- ((NO1 freemod?)* (PA1 freemod? sentpred modifiers? (GA2 freemod? subject freemod? GIO? freemod? terms?)))

<p>

gasent <- (gasent2/gasent1)

<p>

<li>this is the simple Loglan sentence in various basic orders.  The form "gasent" is discoussed just above.  
<li>Predicate modifiers
<li>can be prefixed to the gasent.  The final form given here is the basic SVO sentence.  The "subject" class is a list of terms
#(arguments and predicate modifiers) containing at most one un-case-tagged argument.  The most general SVO form is subject, followed optionally
#by [gio] followed by a list of terms (1989 Loglan allowed more than one untagged argument before the predicate, but this leads to practical problems
#in which preceding constructions with errors in them may supply extra unintended arguments.  It should be noted in NB3 that JCB envisioned
#a single argument before the predicate, followed by the predicate, which may itself contain further arguments.  A gasent nay optionally be negated
#(even multiple times).

<p>

<li>re [gio] and some other changes, in his comments on the NB3 grammar  JCB often notes restrictions on appearances of term lists which he
<li>intends but which he thought were hard to implement in the machine grammar.  The appearance of just one argument before the "verb"
<li>in an SVO sentence was one of these (though later he takes it as a virtue that the actual machine grammar supports SOV:  we did not
<li>consider it a virtue to have unmarked SOV after observing unintended parses appearing in the Visit text).  Another example of this
<li>(which would not have been hard for JCB to implement, in fact) is our restriction of the form "terms gasent" to "modifiers gasent".
<li>His comments make it clear that he does not want arguments among those terms.
<p>
# statement <- (gasent/(modifiers freemod? gasent)/(subject freemod? freemod? (GIO freemod? terms1)? predicate))
<p>
statement <- (gasent/(modifiers freemod? gasent)/(subject freemod? freemod? (GIO? freemod? terms1)? predicate))
<p>
<li>this is a forethought connected basic sentence.  It is odd (and actual odd results can be exhibited) that the final segment in both
<li>of these rules is of the very general class uttA1, which includes some quite fragmentary utterances usually intended as answers.
<p>
<li>12/20/2017 I rewrote the rule in a more compact form.  This rule looks ahead to the class [sentence] which we now develop;
<li>for the moment notice that [sentence] will include [statement].
<p>
<li>4/14 tentatively allowing initial modifiers here and leaving this out of uttA0 which replaces uttA1 below.
<li>The intention is to eliminate weird sentence fragments.
<p>
keksent <- modifiers? freemod? (NO1 freemod?)* (KA freemod? headterms? freemod? sentence freemod? KI freemod? uttA0)
<p>
<li>cloned if not marked as imperative
<p>
keksentclone <- modifiers? freemod? (NO1 freemod?)* (KA freemod? headterms? freemod? sentenceclone freemod? KI freemod? uttA0clone)
<p>
<li>sentence negation.  We allow this to be set off from the main sentence with a mere pause, because generally
<li>it does not differ in meaning from the result of negating the first argument or predicate modifier.
<p>
neghead <- ((NO1 freemod? gap)/(NO2 PAUSE))

<p>

<li>this class includes [statement], predicate modifiers preceding a predicate (which may contain arguments), a statement,
<li>a predicate, and a keksent.  Of these, the first and third are imperatives.

<p>
<li>4/23/2019 added actual rule for imperative sentences.  This should not
<li>affect the parse in any essential way.
<p>
imperative <- ((modifiers freemod?)?  !gasent predicate)

<p>

<li> clone of imperative for labelling which occurrences are actually imperative

<p>

nosubject <- ((modifiers freemod?)?  !gasent predicate)

<p>
sen1 <- (neghead freemod?)* (imperative/statement/keksent)

<p>

<li> clone of sen1 with nosubject instead of imperative

<p>

sen1clone <- (neghead freemod?)* (nosubject/statement/keksent)


<p>
<li>the class [sentence] consists of sen1's afterthought connected with A connectives
<p>
sentence <- (sen1 ([!.:;?]? ICA freemod? sen1)*)

<p>

sentenceclone <- (sen1clone ([!.:;?]? ICA freemod? sen1clone)*)

<p>
<li>[headterms] is a list of terms (arguments and predicate modifiers) ending in [gi].  Preceding a [sen1] with these
<li>causes all predicates in the [sen1] to share these arguments.  We propose either that the headterms arguments be directly
<li>appended to the argument list of each component of the [sen1], or that there is an argument with a numbered case tag at the beginning
<li>of the headterms list, and the list is inserted at the appropriate position in each component sentence.  Neither of these is
<li>the condition described in Loglan I, which presupposes that we always know what the last argument of each predicate used is.
<p>
headterms <- (terms GI freemod?)+
<p>
<li>this is the previous class prefixed with a list of fronted terms.
<li>we think the [giuo] closure might prove useful.
<p>
uttAx <- (headterms freemod? sentence giuo?)
<p>

<li> cloned if not to be marked as imperative

<p>

uttAxclone <- (headterms freemod? sentenceclone giuo?)

<h3>Utterances</H3>
<li>weird answer fragments
<p>
uttA <- ((A1/mex) freemod?)
<p>
<li>a broad class of utterances, including various things one would usually only say as answers.  Notice
<li>that this utterance class can take terminal punctuation.
<p>
uttA0 <- sen1/uttAx
<p>
uttA0clone <-sen1clone/uttAxclone
<p>
uttA1 <- ((sen1/uttAx/links/linkargs/argmod/(modifiers freemod? keksent)/terms/uttA/NO1) freemod? period?)
<p>
<li>possibly negated utterances of the previous class.
<p>
uttC <- ((neghead freemod? uttC)/uttA1)
<p>
<li>utterances linked with more tightly binding ICI sentence connectives.  Single sentences are of this class
<li>if not linked with ICI or ICA.
<p>
uttD <- ((sentence period? !ICI !ICA)/(uttC (ICI freemod? uttD)*))
<p>
<li>utterances of the previous class linked with ICA.  I went to some trouble to ensure that a freestanding
<li>[sentence] is actually parsed as a sentence, not a composite uttD, which was a deficiency, if not an ambiguity of
<li>LIP and of the trial.85 grammar.
<p>
uttE <- (uttD (ICA freemod? uttD)*)
<p>
<li>utterances of the previous class linked with I sentence connectives.
<p>
uttF <- (uttE (I freemod? uttE)*)
<p>
<li>the utterance class for use in the context of parenthetical freemods or quotations, in which it does not go to end of text.
<p>
utterance0 <- (!GE ((ICA freemod? uttF)/(!PAUSE freemod period? utterance0)/(!PAUSE freemod period?)/(uttF IGE utterance0)/uttF/(I freemod? uttF?)/(I freemod? period?)) (&I utterance0)?)
<p>
<li>Notice that there are two passes here:  the parser first checks that the entire utterance
<li>is phonetically valid, then returns and checks for grammatical validity.
<p>
<li>the full utterance class.  This goes to end of text, and incorporates the phonetics check.  This incorporates the only situations
<li>in which a freemod is initial.   The IGE connectives bind even more loosely than the I connectives and right-group instead of 
<li>left grouping.
<p>
utterance <- &(phoneticutterance end) (!GE ((ICA freemod? uttF (&I utterance)? end)/(!PAUSE freemod period? utterance)/(!PAUSE freemod period? (&I utterance)? end)/(uttF IGE utterance)/(I freemod? period? (&I utterance)? end)/(uttF (&I utterance)? end)/(I freemod? uttF (&I utterance)? end)))

</TT>
