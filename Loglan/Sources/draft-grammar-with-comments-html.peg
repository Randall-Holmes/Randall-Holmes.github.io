
<H1>The Loglan PEG Grammar</H1>



<TT>
<x>In this file I will develop the entire Loglan grammar on top of the phonetic proposal

<H2> PEG notation </H2>

<x>A PEG (Parsing Expression Grammar) is made up of lines of the form

<TT> class_name <- PEG  notation</TT>

<x>Each PEG notation describes a set of strings with conditions on the context in which they occur.<p>

<x>Concrete strings: <TT>'string'</TT> or <TT>"string"</TT> literally denotes the 6 character string given.<p>

<x>Classes of characters: <TT>[aeiou]</TT> describes the set of one character strings which are either
<x>a, e, i, o, or u.  Ranges can appear: <TT>[a-zA-z]</TT> describes the union of the sets of lower case letters and upper case letters, considered as one character strings.<p>

<x>If <TT>A</TT> and <TT>B</TT> are PEG notations, <TT>(A B)</TT> denotes a string of class <TT>A</TT> followed by a string of class <TT>B</TT> (in which the string of class <TT>A</TT> is the preferred string of this class read from the beginning of the source string).<p>

<x>If <TT>A</TT> and <TT>B</TT> are PEG notations, <TT>(A / B)</TT> denotes a string of either class <TT>A</TT> or a string of class <TT>B</TT>, with a string of class <TT>A</TT> being read by preference if possible.  The fact that a preference is indicated in alternative lists makes PEG reading deterministic (in a sense, there are no ambiguities for a PEG grammar).  The problem corresponding to ambiguity in a BNF  grammar is incorrectly ordered lists of alternatives.<p>

<x>If <TT>A</TT> is a PEG notation, <TT>(A)?</TT> represents a string of class <TT>A</TT> (preferred) or an empty string if there is no string of class <TT>A</TT>:  this represents optional appearance of <TT>A</TT>.  <TT>(A)*</TT> represents zero or more consecutive strings of class <TT>A</TT> (as many as possible) and <TT>(A)+</TT> represents one or more consecutive such strings.<p>

<x>If <TT>A</TT> is a PEG notation, <TT>&(A)</TT> represents a length 0 string which is followed by a string of class <TT>A</TT>, and <TT>!(A)</TT> represents a length 0 string which is <B>not</B> followed by a string of class <TT>A</TT>.  This gives us powerful lookahead features:  for example, <TT>((A)! B</TT> represents a string of class <TT>B</TT> whose beginning is not also the beginning of a string of class
<x><TT>A</TT>:  it is tempting but not accurate to say that it does not have an initial segment of class <TT>A</TT>, because detection of a string of class <TT>A</TT> longer than the string of class <TT>B</TT> read would cause reading of this class to fail.<p>

<x>The period . represents the class of single characters (so !. is end of text).<p>

<x>New notations are introduced by lines <p>

<x><TT> class_name <- PEG  notation</TT>:<p>

<x>this is not just an abbreviation facility because such definitions may be mutually recursive.<p>

<x>A PEG notation applied to a source string will give either failure or a uniquely determined initial string of the source (parsed suitably); in a sense PEG is unambiguous.  What corresponds as an issue to ambiguity for a BNF grammar is
<x>inappropriate choice of order of alternatives in PEG disjunctions <TT>(A / B)</TT>:  what often represents a problem with a grammar is what I call <x><x><x>    <x>"preemption", where an earlier alternative reads an initial segment of a string where a later alternative could have read more of it.<p>

<x>It's possible to have a PEG go into an infinite loop and fail to produce a parse.  My PEG generator has a termination checker, so the Loglan grammar does not have these problems.  I have contemplated writing a preemption checker, but this is a rather difficult problem.<p>

<p>

<H2>Dated updates now to appear here</H2>

<p>

<x>a note, not reflecting a modification.  I'm wondering whether the pause required in [fo tonira] ([fotonira] means something quite
<x>different) should be a mandatory comma pause.  It looks as if it might not be hard to implement.

<p>

<x>a note:  there is a problem with interaction of quoted forms with alien text operators.

<x>1/22/2022:  provisionally removing the requirement that the terms before the predicate in an SVO sentence contain no more than one untagged argument.
<x>The option of using the particle [gio] before any sutori untagged arguments before the predicate remains.<p>

<p>

<x>1/21/2022 Starting a literate programming exercise:  turn this document into HTML while preserving its performance as a PEG grammar.
#Also note that the alternative version is now turned off.  The only component present is [gaa] and I do not see a reason for anyone to use it.
#The alternative parser is readily turned back on by changing the line statement1x.  This version labels the default stressed syllable in a predicate in the PhoneticComplex parse.

<p>


<x>a serious problem with ICA, an actual ambiguity which has existed since the beginning of the language,
<x>hopefully fixed:  the fix is that an apparent ICA initial utterance which could without the period be
<x>a continuation of a sentence is read as such.  The important point is that there is no audible difference
<x>between comma followed by ICA and period followed by ICA:  we solve the problem by reading the latter
<x>as the former where possible.

<p>

<x>11/24/2021  KIA, the one "word" deletion operator, is installed.  What it actually does is a bit subtle.

<p>

<x>2/4/2021  Imposed the rule that two final consonants cannot be consonants from voiced/unvoiced pairs
<x>with different voice.  Also forbid second final consonant to be h.

<p>

<x>I have further fine-tuning of djifoa gluing in mind.
<x>Allow the -r glue to be expressed as
<x>-rr after all mandatory monosyllables, removing the annoying pronunciation problem?
<x>I was thinking of allowing -hy gluing in other contexts, but it is actually a bad idea.

<p>

<x>9/15/2019 installed semantic case tags with order distinctions for use with predicates with more than one argument of the same case.
<x>one solution is beucine, beucito...  another is beuzi, beuza, beuzu.

<p>


<x>4/28/2019  Various debugging of the new predicate algorithm.  Added CVVhy as a glued form for CVV djifoa.
<x>added capitalization of djifoa glue!  Confirming my apparent earlier decision that a CVV(h)y djifoa must be followed
<x>by a full predicate complex.

<p>

<x>4/26/2019:  this incorporates various revisions to the phonetics, correcting errors or clarifying rules,
<x>motivated by my development of the phonetics section of a new grammar document.  The one notable
<x>change is that [ci] is now only a name marker if followed by an explicit pause.  This only requires
<x>changes in writing in serial names.  In speech, it is recommended that one not pause after [ci]
<x>except before a name word.  The benefit is that non-serial-name related uses of [ci] no longer
<x>threaten mysterious needs to add explicit pauses before following name words.

<p>

<x>I want to add the [zao] proposal of John Cowan.  Done, 4/15/2019.  the imperative pronoun [koo] has been added though not officially.  I should also add [dao] for the dummy argument, but not today (it is in as of 4/18)

<p>

#4/25  Making note of the idea that [ci] should not be a name marker unless followed
<x>by a pause.  This would require that one pause before ci-marked names and it would
<x>remove some very confusing corrections for the false name marker problem.  If we
<x>required the pause to be explicit we would be imposing the expectation that whitespace
<x>after [ci] is not a pause.  Otherwise we could encourage writing a juncture after [ci]
<x>to deny presence of a pause, which is reasonable considering the meanings of [ci].
<x>I am implementing the version with explicit pauses between [ci] and names
<x>and the directive not to pause after [ci] without explicit indication.  This solution
<x>involves rewriting existing text only in the rare instances where [ci] precedes a name.

<p>

<x>4/25/2019  Corrected some instances of (expanded) badstress.  Now forbidding (C)VVVV initial predicates.  Probably I should use class badstress systematically in defining cmapua.

<p>

<x>4/24/2019  Final consonants in syllables cannot be followed by syllabic continuants.  
<x>this rationalizes the definition of SyllableA.

<p>

<x>4/22 I am thinking of explicitly flagging imperative sentences;  not changing
<x>the grammar but making this visible in the parse.  This might also have some
<x>effects on logical connections.  4/23 created an imperative class for atomic
<x>imperative sentences;  this has no actual effect on parses, just
<x>organizes them in a more enlightening way.

<p>

<x>4/17-18 2019:  updates commented out which make sentpred linkable with forethought
<x>and afterthought connectives (making some uses of [guu] to share arguments 
<x>unnecessary).  There are subtleties.  Basically, untensed predicates without
<x>argument lists will be linked by A and KA series connectives.  Such a linked
<x>set can be tensed as a whole.  Such a linked set will share a following termset.
<x>This will probably change many parses in the Visit and other legacy sources.
<x>This required some really subtle adjustments to work right, divinable from
<x>the actual rules given.  Definitely experimental.

<p>

<x>3/9/2019 further, extended LIU1 to handle [ainoi] and its kin
<x>(actual mod is to class Cmapua)  Further, fixing mismatch 
<x>between connective and A classes.  One does now have to pause
<x>before [ha] and its compounds.

<p>

<x>3/9/2019 repaired bugs in negative attitudinals.  A pause
<x>in a negative attitudinal of the [no, ui] form will not break
<x>it.  [ainoi] didnt work for two reasons:  the clauses
<x>in the definition of NOUI were in the wrong order, and
<x>the connective class mistakenly included [noi] so the 
<x>phonetics checker was crashing!  I had to move N and NOI 
<x>earlier to make this work.  Not yet installed in the other 
<x>version.

<p>

<x>1/26/2019  added [vie], JCB's "objective subjunctive" as a PA
<x>class word.  I should add this to the other file as well.

<p>

<x>12/22/18:  just a comment:  one does not have to pause before [ha] and its compounds.
<x>I do not know whether to fix this.  One did not have to in LIP either.  For the moment I will
<x>leave it as it is.  As a matter of style, one probably should pause.

<p>

<x>10/6/18  minor adjustments, made only in this file.  Allow [sujo] (a wicked thing to say).  Do not
<x>allow [futo]:  suffixed conversion operators must be nu + suffix.

<p>

<x>6/2 fixed LIO + alien text.  I also fixed some other glitches described in the reference grammar.

<p>

<x>5/11 making version without "alternative parser" features.  This version allows GAA but it doesn't
<x>do anything:  the definitions of argumentA and kin are the only point of difference.  Master version:
<x>becomes "alternative" by reinstating alternative definitions of argumentA and kin.  Further, made changes
<x>recommended in the reference grammar.  ALTERNATIVE -- this is actually my master version.  Edit
<x>this and revise the argumentA and kin entries to make the original version.

<p>

<x>4/24 discovered and repaired a bug re ci-marked names suffixed to descriptions.  Discovered a bug in numerical
<x>descriptions yet to be fixed:  [lio] needs to be an alien text marker, maybe taking double quotes.  The description-
<x>with-suffixed-name bug was actually quite gruesome.  I think it is repaired.

<p>

<x>4/23 streamlined definition of descriptn.  Shouldn't change anything.  It was remarkably tricky though;  preserving the old form
<x>in case of further trouble.

<p>

<x>4/22 I think this will be the  master grammar file, with alternative lines to turn off the 
<x>GAA-related features.  (1/21/2022, they are now turned off)

<p>

<x>4/22 allowing general predicates in gasent1.  This removes an extreme oddity in parsing of imperatives.
<x>I do not see any new dangers from this.

<p>

<x>4/22 I changed the final element of a keksent to be a sentence (new class uttA0), not a general sentence fragment.
<x>several parse errors in the Visit were uncovered by this.

<p>

<x>4/22:  note that I still have the obligation to restore the [zao] construction.

<p>

<x>4/9/2018 the large subject marker GAA can also be used to defend the beginnings of gasents and imperatives
<x>from absorbing trailing arguments into an unintended statement.  In this context [gaa] may be followed by [ga] ;-)

<p>

<x>4/8/2018 this is an alternative version in which an argument which starts an SVO sentence will not be accepted
<x>as a trailing argument of a previous sentence.  This allows neat termination of [lepo] clauses preceding
<x>a subject, for example.  Unlike the previous alternative approach, this seems to involve a single fairly
<x>tidy change:  it is all an issue of avoiding needs for explicit closure.  Further refinement:  SVO sentences
<x>can be marked with GAA (which is not a tense:  it appears optionally just before the predicate, or just
<x>before sutori arguments marked with GIO if there are any), the "large subject marker":  an argument which 
<x>starts an SVO sentence *not marked with GAA* will not be accepted as a trailing argument of a previous
<x>sentence.  This is a sufficiently complex grammar change that it requires thought:  it is not conservative
<x>in my usual sense.  The fact that GAA carries a mandatory stress is virtuous.  Its resemblance to the 
<x>particle GA when used as a tense is not a bad thing:  it would often be used instead of GA to close
<x>a [lepo] clause appearing as a subject, and it is perhaps better for that purpose.  Note that GAA can
<x>and often will be followed by a tense.  This grammar change depends strongly on the previous ruling that the O in
<x>SOV(O) sentences must be marked with [gio]:  S gio O^n V (O^m).

<p>

<x>nuu is an atomic A core and there is no nu-affix to A connectives and their kin

<x>1/20/2018 redefined CA cores to include a possible NU prefix. This allows more logically connected tenses, for example.

<p>

<x>1/13/2018 reorganized the internals of class PA in a way which should allow more things and not forbid anything legal now.
<x>this is pursuant on an analysis of the classes NI and PA as phrases, rather than words, as I start writing a global lexicography
<x>proposal document.  Enforced explicit pauses after PA phrases appearing as arguments with a following modifier with an argument.

<p>

<x>12/30/2017 fixed a problem with name markers in the clas NameWord and made a slight change to the new option in NI (names
<x>as dimensions).

<p>

<x>12/27/2017 installing an alternative treatment of acronyms under which they are simply names (suffix -n to acronyms in all uses).
<x>supporting this requires no change at all to acronymic name usage (just use the -n versions with the usual rules for names),
<x>and for dimension usage requires [mue] to be a name marker and support for [mue] PreName as an alternative suffix to NI.

<p>

<x>12/27/2017  Frivolously fooling with the capitalization conventions.  They ought to work better now...but I could have broken something.
<x>the main new idea was to require that a capitalized embedded letteral actually be followed by lowercase if it was preceded by lowercase
<x>(with the obvious exception for a letteral followed by a letteral).  Also changed the rules for diphthongs in cmapua to make all-caps
<x>legal for cmapua.  The general idea is that one can start with a capital letter and stay capitalized until one hits a lower case letter,
<x>at which point one can jump back up to caps only at a juncture (after which you can remain capitalized) or temporarily for a vowel
<x>after z- (after which lower case resumes) or an embedded literal (after which lowercase resumes).  The total effect is that this allows
<x>attested capitalization patterns in Loglan (including capitalization of embedded literals as in possessive articles and acronyms)
<x>and also allows all-caps for individual words (attested in Leith but suppressed in my version) and supports capitalization of components
<x>of names as in [la Beibi-Djein] (by artful use of syllable breaks:  Leith just has BeibiDjein, which does not work for me).

<p>

<x>12/26/2017  Installed [niu] (quotation of phonetically legal but so far non-Loglan words).  I did not make [niu] a name marker, so if one were to
<x>use it with names (where it isn't really appropriate), one would have to pause initially:  [niu, Djan].

<p>

<x>I note in this connection that quotation of names with li...lu remains limited, since names by themselves are not
<x>utterances:  one needs the [la].  I fixed this as an exception in the previous parser;  I may do it here or I may
<x>not, haven't decided.  Single name words can be quoted with [liu], of course, but not serial names.

<p>

<x>12/24/2017  Refined treatment of vowel pairs for Cvv-V cmapua units.  First 12/24 version rather disastrously
<x>broken:  this should be fixed!

<p>

<x>12/23/2017  This is now completely commented, with minor local exceptions to which I will return later.
<x>This document is the basis on which I will build all subsequent parsers, with due modifications to the comments.
<x>The Python PEG engine and preamble files contain commands for constructinging a Python parser from it directly.

<p>

<x>12/22/2017 major progress on commenting the grammar

<p>

<x>yet later 12/20:  no change in performance of the grammar, extensive commenting in the
<x>grammar section.  Considerable changes in arrangement:  for example, vocatives, inverse vocatives,
<x>and free modifiers are moved to a much earlier point.  I'm hoping to get a genuinely almost readable
<x>commented grammar...

<p>

<x>later 12/20  starting the process of commenting and editing the grammar, starting
<x>at basic sentence structures.  Notably rewrote the class [keksent] more compactly,
<x>one hopes with no actual effect on parses.

<p>

<x>12/20/2017  Do not require expression of pause after finally stressed cmapua before
<x>vowel initial predicate as a comma, since the initial vowel signals the pause anyway.  
<x>Allow final stress in names.  Fixed bug in CVVHiddenStress.  Prevented
<x>broken monosyllables in finally stressed CVV djifoa.  refinement of caprule

<p>

<x>12/19/2017 seem to have had a versioning failure and lost the fix which requires
<x>CVVy djifoa to be followed by complete complexes.  Restored.

<p>

<x>12/18/2017 fixed a bug in treatment of stressed syllables in recognizing predicate starts.  Also
<x>narrowed the generalized VCCV rule to allow more of the quite unlikely space of predicates with lots
<x>of vowels before the CC pair.  Probably they should be banned (and none have ever been proposed with
<x>more than three) but that rule is not the context in which to arbitrarily ban half of them.  Some cleanup
<x>of the display of parses, for which updated version of logicpreamble.py should also be uploaded. A refinement
<x>to class "connective" checking that apparent logical connectives are not initial segments of predicates.
<x>This has the effect of delaying the declaration of "connective" until after the declaration of
<x>"predstart".

<p>

<x>12/17/2017 further refinement of the 12/16 version:  a couple of bugs spotted.

<p>

<x>12/16/2017 There should be no change in parsing behavior, but the predstart ruleset is shorter
<x>and more intelligible, and I realized that Complex doesnt need a check for the anti-slinkui test
<x>(the requirement that certain initial CVC cmapua be y hypenated which replaces the slinkui test))
<x>at all:  the way predstart works already ensures that initial CV cmapua fall off in the excluded
<x>cases, the idea being that we test the front of a predicate without lookahead in all cases.  Also
<x>addressed the subtle point that one wasn't forced to pause after a predicate before following y
<x>(not likely to arise as a problem).

<p>


<x>12/14/2017  Corrected vowel grouping to avoid paradoxical vowel triples which are default
<x>grouped in a way which becomes illegal if made explicit.  SyllableA really should contain a final
<x>consonant:  the previous form was messing up vowel grouping.  Serious bug where end of djifoa
<x>and syllable resolution of a predicate may fail to agree.  I think I blocked this by ensuring that
<x>final djifoa are not followed by vowels.  Other fine tuning of the complex algorithm.  Also had
<x>to repair the check for CVCCCV and CVCCVV predicates.

<p>


<x>12/13/2017:  added kie ( utterance ) kiu to class LiQuote.  Did fine tuning to ensure
<x>that cmapua streams stop before [li] or [kie], that names can stop at double quotes or close
<x>parentheses, and that the capitalization rule ignores opening parentheses as well as double
<x>quotes.  One can now adorn li lu with quotes (on the inside) in a reasonable way
<x>and adorn kie kiu with parentheses (on the inside) in a reasonable way.  One cannot
<x>*replace* these words (or any words) with punctuation in my model of Loglan.  Also,
<x>updates to comments, and <x>(end of utterance) added as a marker of terminal punctuation.

<p>

<H2>Comments on the initial release of this grammar</H2>

<x>This is now done, in a first pass.  That is, the grammar is adapted and appears to work, more or less.
<x>What is needed is comments on the lexicography and the grammar...Phonetics has now pretty clearly been sorted
<x>from the grammar (there are some places where the phonetics accept grammar information with regard to punctuation).
<p>
<x>Alien text is now handled somewhat differently.  Some issues to do with quoting names are not finalized and have not been tested.
<p>
<x>I added -iy and -uy as VV forms allowed in general in cmapua but not in other words;  they are always monosyllabic.  What this
<x>immediately allows me to do is to give Y a name which is not phonetically irregular!  [ziy] is supported:  [yfi] is too, now.
<p>
<x>capitalization is roughly back to where it was in the original, but all-caps are allowed.
<p>
<x>acronyms are liable to be horrible.
<p>
<x>Fixed the recursion problem in a way which will not be visible in ordinary parses.  Streams of cmapua will always
<x>be broken at name or alien text markers (instead of using lookahead to check that we do not stand at the beginning
<x>of a name word  or alien text word).  The next cycle will then check for a name or alien text, and also check for
<x>badnamemarkers;  no lookahead is happening while a stream of cmapua is being read except checking for
<x>the markers of names and alien text.  This will change the way phonetic parses look (streams of cmapua will
<x>break (and sometimes resume) at name markers or alien text markers, but it will not change any grammatical
<x>parses.
<p>
<H2>Part I Phonetics</H2>

<x>Mod bugs, I have implemented all of Loglan phonetics as described in my proposal.  Borrowing djifoa are pretty tricky.
<p>
<x>I have now parsed all the words in the dictionary, and all single words of appropriate classes parse successfully.
<x>I have added alien text and quotation constructions which do not conform to these rules; so actually
<x>all Loglan text should parse,  mod some punctuation and capitalization issues.  The conventions for
<x>alien text here are not the same as those in the current provisional parser.
<p>
<x>I believe the conventions for forcing comma pauses before vowel initial cmapua and after names
<x>except in special contexts have been enforced.  In a full grammar, one probably would want
<x>to disable pauses before vowel initial letterals (done).  This grammar also does not support the lingering
<x>irregularities in acronyms (and won't).
<p>
<x>This grammar (in Part I) is entirely about phonetics:  all it does is parse text into names (with associated initial
<x>pauses or name markers), cmapua (qua unanalyzed streams of cmapua units), 
<x>borrowings and complexes, along with interspersed comma pauses and marks
<x>of terminal punctuation.  It does support conventions about where commas are required
<x>and a simple capitalization rule.  Streams of cmapua break when markers initial
<x>in other forms are encountered (and may in some cases resume when the markers
<x>are a deception).
<p>
<x>a likely locus for odd bugs is the group of predstartX rules which detect apparent cmapua which
<x>are actually preambles to predicates.  These are tricky! (and I did indeed find some lingering
<x>problems when I parsed the dictionary).  Another reason to watch this rule predstart
<x>is that it carries a lot of weight:  !predstart is used as a lightweight test
<x>that what follows is a cmapua (a point discussed in more detail later).
<p>
<x>In reviewing this, I think that very little is different from 1990's Loglan (the borrowing djifoa
<x>are post-1989 L1, but not my creation).  Some things add precision without making anything in 1990's Loglan incorrect.
<x>The requirement that syllabic consonants be doubled is new, and makes some 1990's Loglan names incorrect.
<x>The requirement that names resolve into syllables is new, and makes some 1990's Loglan names incorrect,
<x> usually because they end in three consonants.
<x>The rule restricting final consonant pairs from being noncontinuant/continuant is new, but
<x>  does not affect any actual predicate ever proposed.
<x>Enhancing the VccV rule to also forbid CVVV...ccV caused one predicate to be changed
<x> ([haiukre] became [haiukrre], and haiukre was a novelty anyway, using a new name for X in X-ray)
<x>The exact definition of syllables and use of syllable breaks and stress marks is new (the close comma
<x> was replaced with the hyphen, so Lo,is becomes Lo-is); but this does not make anything in 1990's Loglan
<x> incorrect, it merely increases precision and makes phonetic transcript possible.
<x>Forbidding doubled vowels in borrowings was new, was already approved, and caused us to change
<x> [alkooli] to [alkoholi].
<x>Formally allowing the CVccVV and CVcccV predicates without y-hyphens took a proposal in 2013 because
<x> Appendix H was careless in describing their abandonment of the slinkui test, but the dictionary
<x> makes it evident that this was their intent all along.  The slinkui test had already been
<x> abandoned in the 1990s.
<x>Formally abandoning qwx was already something that the dictionary workers in the 1990's were working
<x> on; we completed it.
<x>Allowing glottal stop in vowel pairs and forbidding it as an allophone of pause is a new phonetic
<x> feature in the proposal but not reflected in the parser, of course.   Alternative pronunciations of
<x> y and h and allowing h in final position are invisible or do not make any 1990's Loglan incorrect.
<x>Permitting false name markers in names was already afoot in the 1990's and the basic outlines of our
<x> approach were already in place.  The rule requiring explicit pauses between a name marker not starting
<x> a name word and the beginning of the next name word is new, but reflects something which was already
<x> a fact about 1990's Loglan pronunciation:  those pauses had to be made in speech
<x>(and in the 1990's they had no tools to do relevant computer tests)!  The requirement
<x> that names resolve into syllables restricts which literal occurrences of name markers are actually
<x> false name markers (the tail they induce in the name must itself resolve into syllables).
<x>Working out the full details of borrowing djifoa was interesting:  I'm not sure that I've done anything
<x> *new* there;  explicitly noting the stress shift in borrowing djifoa might be viewed as something
<x> new but it is a logical consequence of JCB's permission to pause after a borrowing djifoa, which contains
<x> explicit language about how it is to be stressed, and the
<x> final definition of a borrowing djifoa as simply a borrowing followed by -y.  The shift strikes
<x> me as a really good idea anyway, because it marks djifoa with a pause after it as phonetically different
<x> in an additional way other than ending with the very indistinct vowel y.  My rules as given here do not
<x> directly enforce the rule that a borrowing djifoa must be preceded by y but I think they indirectly
<x> enforce it in all or almost all cases:  the parser tries to read a borrowing djifoa before reading
<x> any other kind of djifoa, so it is hard to see how to deploy a short djifoa in such a way that it would
<x> fall off the head of a borrowing without using y.
<x>These phonetics do not support certain irregularities in acronyms.  We note that
<x>it is now allowed to insert [, mue] into an acronym, which would be necessary for example
<x>between a Ceo letteral and a following VCV letteral.
<p>
<H3>Sounds</H3>

<H4>Vowels</H4>
<p>
#all vowels
<p>
V1 <- [aeiouyAEIOUY]
<p>
#regular vowels
<p>
V2 <- [aeiouAEIOU]

<H3>Consonants</H3>
<p>
#consonants
<p>
C1 <- [bcdfghjklmnprstvzBCDFGHJKLMNPRSTVZ]
<p>
#consonants in voiced/unvoiced pairs
<p>
Cvoiced <- [bdgjvzBDGJVZ]
<p>
Cunvoiced <- [ptkcfsPTKCFS]
<p>
<x>bad voice pair (or pair second term of which is h)
<x>forbidden as pairs of final consonants
<p>
Badvoice <- (Cvoiced (Cunvoiced/[Hh])/Cunvoiced (Cvoiced/[Hh]))
<p>

<H4>Letters and capitalization</H4>
<x>letters
<p>
letter <- (![qwxQWX] [a-zA-Z])
<p>
<x>a capitalization convention which allows what our current one allows and also allows all-caps.
<x>if case goes down from upper case to lower case, it can only go back up in certain cases.  This
<x>does allow capitalization of initial segments of words.  There is a forward reference to the grammar
<x>in that free capitalization of embedded literals is permitted, and capitalization of vowels
<x>guarded with z in literals as in DaiNaizA.
<p>
lowercase <- (![qwx] [a-z])
<p>
uppercase <- (![QWX] [A-Z])
<p>
caprule <- [\"(]? &([z] V1 (!uppercase/&TAI0)/lowercase TAI0 (!uppercase/&TAI0)/!(lowercase uppercase).) letter (&([z] V1 (!uppercase/&TAI0)/lowercase TAI0 (!uppercase/&TAI0)/!(lowercase uppercase).) (letter/juncture))* !(letter/juncture)
<p>
<H4>Junctures:  syllable breaks and stresses</H4>

<x>syllable markers:  the hyphen is always medial so must be followed by a letter.
<x>the stress marks can be syllable final and word final.  A juncture is never followed
<x>by another juncture.
<p>
juncture <- (([-] &letter)/[\'*]) !juncture
<p>
stress <- ['*] !juncture

<H4>Terminal punctuations and general characters</H4>

<x>terminal punctuation

terminal <- ([.:?!;#])

<p>

<x>characters which can occur in words

<p>

character <- (letter/juncture)

<p>

<H3>Alien text</H3>

<x>to really get all Loglan text, we should add the alien text constructions and the markers of alien text,
<x>[lie], [lao], [sao], [sue] and certain quotations which violate the phonetic rules.

<p>

<x>we adopt the convention that all alien text may be but does not have to be enclosed in quotes.
<x>it needs to be understood that in quoted alien text, whitespace is understood as [, y,]; in the unquoted
<x>version this is shown explicitly.  This handling of alien text is taken from the final 1990's treatment
<x>of Linnaeans = foreign names, and extended by us to replace the impossible treatment of strong
<x>quotation in 1989 Loglan.

<p>

<x>this is a little different from what is allowed in the previous provisional parser, but similar.
<x>A difference is that all the alien text markers are allowed to be followed by the same sorts of alien text.

<p>

<x>the forms with [hoi] and [hue] are required to have following quotes in written form to avoid
<x>unintended parses, which otherwise become likely in case of typos in non-alien text cases.

<p>

AlienText <- ([,]? [ ]+ [\"] (![\"].)+ [\"]/ [,]? [ ]+ (![, ]!terminal .)+ ([,]? [ ]+ [y] [,]? [ ]+ (![, ]!terminal .)+)*)

<p>

AlienWord <- &caprule ([Hh] [Oo] [Ii] juncture? &([,]? [ ]+ [\"])/[Hh][Uu] juncture? [Ee] juncture? &([,]? [ ]+ [\"]) / [Ll] [Ii] juncture? [Ee]juncture? /[Ll] [Aa] [Oo]juncture? /[Ll] [Ii] juncture? [Oo] juncture? /[Ss] [Aa] [Oo]juncture?/[Ss] [Uu] juncture? [Ee]juncture?) AlienText

<p>

<x>while reading streams of cmapua, the parser will watch for the markers of alien text.

<p>

alienmarker <- ([Hh] [Oo] [Ii] juncture? &([,]? [ ]+ [\"])/[Hh][Uu] juncture? [Ee] juncture? &([,]? [ ]+ [\"]) / [Ll] [Ii] juncture? [Ee] juncture? /[Ll] [Aa] [Oo] juncture? /[Ll] [Ii] juncture? [Oo] juncture?  /[Ss] [Aa] [Oo] juncture?/[Ss] [Uu] juncture? [Ee] juncture?) !V1

<p>

<x>5/11/18 added [lio] as an alien text marker, to support numerals.

<p>

<x>the continuant consonants and the syllabic pairs they can form

<H3>Complex Vowel Forms</H3>

continuant <- [mnlrMNLR]

<p>

syllabic <- (([mM] [mM] !(juncture? [mM]))/([nN] [nN] !(juncture? [nN]))/([rR] [rR] !(juncture? [rR]))/([lL] [lL] !(juncture? [lL])))
<p>
<x>the obligatory monosyllables, and these syllables when broken by a usually bad syllable juncture.
<x>The i-final forms are not obligatory mono when followed by another i.

<p>

MustMono <- (([aeoAEO] [iI] ![iI]) /([aA] [oO]))

<p>

BrokenMono <- (([aeoAEO] juncture [iI] ![iI])/([aA] juncture [oO]))

<p>

<x>the obligatory and optional monosyllables.  Sequences of three of the same letter
<x>are averted.  Avoid formation of doubled i or u after ui or ui.

<p>

Mono <- (MustMono/([iI] !([uU] [uU]) V2)/([uU] !([iI] [iI]) V2))

<p>

<x>vowel pairs of the form found in cmapua and djifoa.
<x>(other than the special IY, UY covered in the cmapua rules)

<p>

<x>The mysterious prohibition controls a permitted phonetic exception in djifoa gluing.
<x>compua are never followed directly by vocalic continuants in any case.

<p>

VV <- !(!MustMono V2 juncture? V2 juncture? [Rr] [Rr]) (!BrokenMono V2 juncture? V2)

<p>

<x>the next vocalic unit to be chosen from a stream of vowels
<x>in a predicate or name.  This is different than in our Sources
<x>and formally described in the proposal.

<p>

NextVowels <- (MustMono/(V2 &MustMono)/Mono/!([Ii] juncture [Ii] V1) !([Uu] juncture [Uu] V1) V2)

<p>

<x>5/11/18 forbidding consonantal vowels to follow the same vowel.

<p>

<x>the doubled vowels that trigger the rule that one of them must be stressed

<p>

DoubleVowel <- (([aA] juncture? [aA])/([eE] juncture? [eE])/([oO] juncture? [oO])/([iI] juncture [iI])/([uU] juncture [uU])/[iI] [Ii] &[iI]/[Uu] [uU] &[uU])

<p>

<x>the mandatory "vowel" component of a syllable

<p>

Vocalic <- (NextVowels/syllabic/[Yy])

<p>

<H3>Complex Consonant Forms</H3>

<p>

<x>the permissible initial pairs of consonants, and the same pairs possibly
<x>broken by syllable junctures.

<p>

Initial <- (([Bb] [Ll])/([Bb] [Rr])/([Cc] [Kk])/([Cc] [Ll])/([Cc] [Mm])/([Cc] [Nn])/([Cc] [Pp])/([Cc] [Rr])/([Cc] [Tt])/([Dd] [Jj])/([Dd] [Rr])/([Dd] [Zz])/([Ff] [Ll])/([Ff] [Rr])/([Gg] [Ll])/([Gg] [Rr])/([Jj] [Mm])/([Kk] [Ll])/([Kk] [Rr])/([Mm] [Rr])/([Pp] [Ll])/([Pp] [Rr])/([Ss] [Kk])/([Ss] [Ll])/([Ss] [Mm]) /[Ss] [Nn]/([Ss] [Pp])/([Ss] [Rr])/([Ss] [Tt])/([Ss] [Vv])/([Tt] [Cc])/([Tt] [Rr])/([Tt] [Ss])/([Vv] [Ll])/([Vv] [Rr])/([Zz] [Bb])/([Zz] [Ll])/([Zz] [Vv]))

<p>

MaybeInitial <- (([Bb] juncture? [Ll])/([Bb]juncture?  [Rr])/([Cc]juncture?  [Kk])/([Cc] juncture? [Ll])/([Cc]juncture?  [Mm])/([Cc]juncture?  [Nn])/([Cc]juncture?  [Pp])/([Cc]juncture?  [Rr])/([Cc]juncture?  [Tt])/([Dd]juncture?  [Jj])/([Dd]juncture?  [Rr])/([Dd]juncture?  [Zz])/([Ff]juncture?  [Ll])/([Ff]juncture?  [Rr])/([Gg]juncture?  [Ll])/([Gg]juncture?  [Rr])/([Jj]juncture?  [Mm])/([Kk]juncture?  [Ll])/([Kk] juncture? [Rr])/([Mm]juncture?  [Rr])/([Pp]juncture?  [Ll])/([Pp]juncture?  [Rr])/([Ss]juncture?  [Kk])/([Ss]juncture?  [Ll])/([Ss] juncture? [Mm]) /[Ss] juncture? [Nn]/([Ss]juncture?  [Pp])/([Ss]juncture?  [Rr])/([Ss]juncture?  [Tt])/([Ss]juncture?  [Vv])/([Tt]juncture?  [Cc])/([Tt]juncture?  [Rr])/([Tt] juncture? [Ss])/([Vv]juncture?  [Ll])/([Vv]juncture?  [Rr])/([Zz]juncture?  [Bb])/([Zz] juncture? [Ll])/([Zz] juncture? [Vv]))

<p>

<x>the permissible initial consonant groups in a syllable.  Adjacent consonants should be initial pairs.
<x>The group should not overlap a syllabic pair.  Such a group is of course followed by a vocalic unit.

<p>

<x>this rule for initial consonant groups is stated in NB3.

<p>

<x>I forbid a three-consonant initial group to be followed by a syllabic pair.  This seems obvious.

<p>

InitialConsonants <- ((!syllabic C1 &Vocalic)/(!(C1 syllabic) Initial &Vocalic)/(&Initial C1 !(C1 syllabic) Initial !syllabic &Vocalic))

<p>

<x>the forbidden medial pairs and triples.  These are forbidden regardless of placement
<x>of syllable breaks.

<p>

<x>each of these is actually a single consonant followed by an initial, and the idea was to identify CVC-CCV junctions which
<x>would be hard to pronounce.  But the placement of the syllable break is not relevant to the exclusion of the sequence.
<x>Notice that the continuant syllabic pairs are excluded:  this prevents final consonants from being included in such pairs.

<p>

NoMedial2 <- (([Bb] juncture? [Bb])/([Cc] juncture? [Cc])/([Dd] juncture? [Dd])/([Ff] juncture? [Ff])/([Gg] juncture? [Gg])/([Hh] juncture? C1)/([Jj] juncture? [Jj])/([Kk] juncture? [Kk])/([Ll] juncture? [Ll])/([Mm] juncture? [Mm])/([Nn] juncture? [Nn])/([Pp] juncture? [Pp])/([Rr] juncture? [Rr])/([Ss] juncture? [Ss])/([Tt] juncture? [Tt])/([Vv] juncture? [Vv])/([Zz] juncture? [Zz])/([CJSZcjsz] juncture? [CJSZcjsz])/([Ff] juncture? [Vv])/([Kk] juncture? [Gg])/([Pp] juncture? [Bb])/([Tt] juncture? [Dd])/([FKPTfkpt] juncture? [JZjz])/([Bb] juncture? [Jj])/([Ss] juncture? [Bb]))

<p>

NoMedial3 <- (([Cc] juncture? [Dd] juncture? [Zz])/([Cc] juncture? [Vv] juncture? [Ll])/([Nn] juncture? [Dd] juncture? [Jj])/([Nn] juncture? [Dd] juncture? [Zz])/([Dd] juncture? [Cc] juncture? [Mm])/([Dd] juncture? [Cc] juncture? [Tt])/([Dd] juncture? [Tt] juncture? [Ss])/([Pp] juncture? [Dd] juncture? [Zz])/([Gg] juncture? [Tt] juncture? [Ss])/([Gg] juncture? [Zz] juncture? [Bb])/([Ss] juncture? [Vv] juncture? [Ll])/([Jj] juncture? [Dd] juncture? [Jj])/([Jj] juncture? [Tt] juncture? [Cc])/([Jj] juncture? [Tt] juncture? [Ss])/([Jj] juncture? [Vv] juncture? [Rr])/([Tt] juncture? [Vv] juncture? [Ll])/([Kk] juncture? [Dd] juncture? [Zz])/([Vv] juncture? [Tt] juncture? [Ss])/([Mm] juncture? [Zz] juncture? [Bb]))

<p>

<H3>The Syllable</H3>

<x>there are no formal rules about syllables as such in our Sources, which is odd since
<x>the definition of predicates depends on the placement of stresses on syllables.

<p>

<x>The first rule enforces the special point needed in complexes that
<x>a CVC syllable is preferred to a CV syllable where possible; we economically apply
<x>the same rule for default placement of syllable breaks everywhere, which is, with
<x>that exception, that the break comes as soon as possible.

<p>

<x>the SyllableB approach is taken if the following syllable would otherwise start with a syllabic pair.

<p>

<x>the reason for this approach is that if one syllabizes a well formed complex in this way...
<x>the syllable breaks magically fall on the djifoa boundaries.  This does mean that the
<x>default break in [cabro] is [cab-ro], which feels funny but is harmless.  Explicitly breaking
<x>it [ca-bro] will also parse correctly.

<p>

SyllableA <- (C1 V2 FinalConsonant (!Syllable FinalConsonant)?)

<p>

SyllableB <- (InitialConsonants? Vocalic (!Syllable FinalConsonant)? (!Syllable FinalConsonant)?)

<p>

Syllable <- ((SyllableA/SyllableB) juncture?)

<p>

<x>The final consonant in a syllable.  There may be one or two final consonants.  A pair of final
<x>consonants may not be a non-continuant followed by a continuant.  A final consonant may not
<x>start a forbidden medial pair or triple.

<p>

<x>The rule that a final consonant pair may not be a non-continuant followed by a continuant
<x>is natural and obvious but not in our Sources.  Such a pair of consonants would seem to 
<x>naturally form another syllable.

<p>


<x>a pair of final consonants cannot be differently voiced

<p>

FinalConsonant <- !syllabic !(&Badvoice C1 !Syllable) (!(!continuant C1 !Syllable continuant) !NoMedial2 !NoMedial3 C1 !(juncture? (V2/syllabic)))

<p>

#!((!MaybeInitial)C1 juncture? !syllabic C1 juncture? !syllabic C1) !(&MaybeInitial C1 juncture C1 !(juncture? C1))

<H4>Varieties of Syllable</H4>

<x>Here are various flavors of syllable we may need.

<p>

<x>this is a portmanteau definition of a bad syllable (the sort not allowed in a borrowing).

SyllableD <- &(InitialConsonants? ([Yy]/DoubleVowel/BrokenMono/&Mono V2 DoubleVowel/!MustMono &Mono V2 BrokenMono)) Syllable

<p>

<x>this (below) is the kind of syllable which can exist in a borrowed predicate:
<x>it cannot start with a continuant pair, it cannot have a y as vocalic unit,
<x>and its vocalic unit (whether it has one or two regular vowels) 
<x>cannot be involved in a double vowel or an explicitly broken 
<x>mandatory monosyllable.

<p>

BorrowingSyllable <- !syllabic (!SyllableD) Syllable

<p>

<x>this is the final syllable of a predicate.  It cannot be followed
<x>without pause by a regular vowel.

<p>

VowelFinal <- InitialConsonants? Vocalic juncture? !V2

<p>

<x>syllables with syllabic consonant vocalic units
<x>this class is only used in borrowings, and we *could* reasonably
<x>require it to be followed by a vowel.  But I won't for now.
<x>for gluing this restriction would work, but we might literally borrow predicates
<x>with syllabic continuant pronunciations.

<p>

SyllableC <- (&(InitialConsonants? syllabic) Syllable)

<p>

<x>syllables with y

<p>

SyllableY <- (&(InitialConsonants? [Yy]) Syllable)

<p>

<x>an explicitly stressed syllable.

<p>

StressedSyllable <- ((SyllableA/SyllableB) [\'*])

<p>

<H3>Name Words</H3>

<x>a final syllable in a word, ending in a consonant.

<p>

NameEndSyllable <- (InitialConsonants? (syllabic/Vocalic &FinalConsonant) FinalConsonant? FinalConsonant? stress? !letter)

<p>

<H4>The Pause</H4>

<x>the pause classes actually hang on the letter before the pause.

<p>

<x>whitespace which might or might not be a pause.

<p>

maybepause <- (V1 [\'*]? [ ]+ C1)

<p>

<x>explicit pauses:  these are whitespace before a vowel or after a consonant, or comma marked pauses.
<p>

pause <- ((C1 [\'*]? [ ]+ &letter)/(letter [\'*]? [ ]+ &V1)/(letter [\'*]? [,] [ ]+ &letter))

<p>

<H4>The full analysis of names</H4>

<x>these are final syllables in words followed by whitespace which might not be a pause.
<x>the definition actually doesnt mention the maybepause class.

<p>

MaybePauseSyllable <- InitialConsonants? Vocalic ['*]? &([ ]+ &C1)

<p>

<x>a name word (without initial marking) is resolvable into syllables and ends with a consonant.

<p>

PreName <- ((Syllable &Syllable)* NameEndSyllable)

<p>

<x>this is a busted name word with whitespace in it -- but not whitespace at which one has to pause.

<p>

BadPreName <- (MaybePauseSyllable [ ]+/Syllable &Syllable)* NameEndSyllable

<p>

<x>This is a name marker followed by a consonant initial name word without pause.

<p>

<x>I deployed a minimal set of name marker words; I can add the others whenever.
<x>I have decided (see below) to retain the social lubrication words as vocative markers
<x>*without* making them name markers, so one must pause [Loi, Djan].  By not allowing
<x>freemods right after vocative markers in the vocative rule, I make [Loi hoi Djan] work as well,
<x>without pause.

<p>

<x>MarkedName <- &caprule ((([Ll] !pause [Aa] juncture?)/ ([Hh] [Oo] !pause [Ii] juncture?) /  ([Hh] [Uu] juncture? !pause [Ee] juncture?) / ([Cc] !pause [Ii] juncture?)/([Ll] [Ii] juncture? !pause [Uu] juncture?)/[Gg][Aa] !pause [Oo] juncture?/[Mm][Uu] juncture? !pause [Ee] juncture?) [ ]* &C1 &caprule PreName)

<p>

MarkedName <- &caprule ((([Ll] !pause [Aa] juncture?)/ ([Hh] [Oo] !pause [Ii] juncture?) /  ([Hh] [Uu] juncture? !pause [Ee] juncture?) /([Ll] [Ii] juncture? !pause [Uu] juncture?)/[Gg][Aa] !pause [Oo] juncture?/[Mm][Uu] juncture? !pause [Ee] juncture?) [ ]* &C1 &caprule PreName)

<p>


<x>This is an unmarked name word with a false name marker in it.

<p>

FalseMarked <- (&PreName (!MarkedName character)* MarkedName)

<p>

<x>This is the full definition of name words.  These are either marked consonant initial names without pause defined above,
<x>names without false name markers beginning with explicit pauses (either comma marked or vowel-initial) 
<x>and name markers followed, with or without pause, by name words.  In the latter case there must be at least
<x>whitespace before a vowel initial name.

<p>

<x>a series of names without false name markers and names marked with ci, separated by spaces, may be appended.

<p>

<x>there is a look ahead at the grammar: a NameWord can be followed without explicit pause (there is whitespace and 
<x>a pause in speech!) by another
<x>kind of utterance only in a serial name when what follows is of the form [ci] predunit, to be included
<x>in the name.

<p>

NameWord <- (&caprule MarkedName/([,] [ ]+ !FalseMarked &caprule PreName)/(&V1 !FalseMarked &caprule PreName)/&caprule ((([Ll] [Aa] juncture?)/([Hh] [Oo] [Ii] juncture?)/([Cc] &pause [Ii] juncture?)/([Ll] [Ii] juncture? [Uu] juncture?)/[Mm] [Uu] juncture? [Ee] juncture?/[Gg] [Aa] [Oo] juncture?) !V1 [,]? [ ]* &caprule PreName))([,]?[ ]+ !FalseMarked &caprule PreName/[,]?[ ]+ &([Cc] &pause [Ii]) NameWord)* &([ ]* [Cc] [Ii] predunit/&([,] [ ]+/terminal/[\")]/!.)./!.)

<p>

<x>this is the minimal set of name marker words we are using.  We may add more.

<p>

<x>I am contemplating adding the words of social lubrication as name markers, but in a more restricted
<x>way that in the last provisional parser, in which I made them full-fledged vocative markers.  [Actually,
<x>I preserved their status as vocative markers without restoring their status as name markers, in the latest version].

<p>

<x>adding [mue] as a name marker

<p>

namemarker <- ([Ll] [Aa] juncture?/[Hh][Oo][Ii] juncture?/([Hh] [Uu] juncture? [Ee] juncture?)/[Cc] &pause [Ii] juncture?/[Ll][Ii] juncture? [Uu] juncture?/[Gg][Aa][Oo] juncture?/[Mm] [Uu] juncture? [Ee] juncture?) !V1

<p>

<x>this is the bad name marker phenomenon that needs to be excluded.  This captures the idea
<x>that what follows the name could be pronounced without pause as a name word according to the
<x>orthography, but the fact that whitespace is present shows that this is not the intention.

<p>

<x>it is worth noting that name markers at heads of name words pass this test
<x>(because I omitted the test that what follows is not a PreName in the interests
<x>of minimizing lookahead);
<x>but this test is only applied to strings that have already been determined not to
<x>be of class NameWord.

<p>

badnamemarker <- namemarker !V1 [, ]? [ ]* BadPreName

<x>we test for the bad name marker condition at the beginning of each stream of cmapua,
<x>and streams of cmapua stop before name markers (and may resume at a name marker
<x>if neither a NameWord nor the bad marker condition is found).

<p>

<x>We have at any rate completely solved the phonetic problem of names and their markers.

<p>

<H3>Predicate Start Test</H3>

<x>predicate start tests:  the idea is the same as class "connective" below, to recognize
<x>the start of a predicate without recursive appeals to the whole nasty definition of predicate.
<x>The reason to do it is to recognize when CV^n followed by CC cannot be a cmapua unit.
<p>
<x>New implementation 4/28/2019.  This allows only (C)V(V)(V) before the pair of vowels, for much less
<x>potential lookahead.
<p>

Vthree <- (V2 juncture?) (V2 juncture?) (V2 juncture?)

<p>

Vfour <- (V2 juncture?) (V2 juncture?) (V2 juncture?) (V2 juncture?)

<p>

<x>predicate starting with two or three consonants:  rules out CC(C)V(V) forms.  Junctures in
<x>the initial consonant group ignored.

<p>

predstartA1 <- (&MaybeInitial C1 juncture? MaybeInitial/MaybeInitial) &V2 !(V2 stress !Mono V2) !(V2 juncture? V2 !character) !(V2 juncture? !character)

<p>

<x>an apparent cmapua unit followed by a consonant group which cannot start a predicate -- CV(V) case

<p>

predstartA2 <- C1 V2 juncture? (V2 juncture?)? !predstartA1 C1 juncture? C1

<p>

<x>a stressed CV^n before a consonant group (CV(V) case)

<p>

predstartA3 <- C1 !Vthree (!StressedSyllable V2 juncture?)? &StressedSyllable V2 V2? juncture? C1 juncture? C1

<p>

<x>other (C)V^n followed by nonpredicate 

<p>

predstartA4 <- C1? V2 juncture? (V2 juncture?)?  (V2 juncture?)? !predstartA1 !(MaybeInitial V2) C1 juncture? C1

<p>

<x>other stressed (C)V^n followed by consonant group

<p>

predstartA5 <- C1? !Vfour (!StressedSyllable V2 juncture?)? (!StressedSyllable V2 juncture?)? &StressedSyllable V2 V2? juncture? !(MaybeInitial V2) C1 juncture? C1

<p>

<x>forms with y; implemented CVVhy alternative for CVV cmapua

<p>

predstartA6 <- C1 (V2 juncture?) (V2 juncture? [Hh]?/C1 juncture? (C1 juncture?)?) [Yy]

<p>

predstart <- predstartA1/predstartA2/predstartA3/predstartA4/predstartA5/predstartA6

<p>

<x>it is worth noting that in the sequel we have systematically replaced tests &Cmapua
<x>with !predstart.  The former involves lots of lookahead and was causing recursion crashes
<x>in Python.  The phonetics and the grammar are both structured so that any string
<x>starting with a name marker is tested for NameWord-hood before it is tested for 
<x>cmapua-hood; the only thing it is tested for later is predicate-hood, and predstart
<x>is a rough and ready test that something might be a predicate (and at any rate
<x>cannot be a cmapua).

<p>

<H3>Structure Word Phonetics</H3>

<x>this class requires pauses before it, after all the phonetic word classes.
<x>what is being recognized is the beginning of a logical connective.

<p>

<x>To avoid horrible recursion problems, giving this a concrete phonetic definition
<x>without much lookahead.  This can go right up in the phonetics section if it works
<x>(and here it is!).

<p>

<x>single vowel cmapua syllables early for connectives

<p>

a <- ([Aa] !badstress juncture? !V1)

<p>

e <- ([Ee] !badstress juncture? !V1)

<p>

i <- ([Ii] !badstress juncture? !V1)

<p>

o <- ([Oo] !badstress juncture? !V1)

<p>

u <- ([Uu] !badstress juncture? !V1)

<p>


Hearly <- (!predstart [Hh])

<p>

Nearly <- (!predstart [Nn])

<p>


<x>these appear here for historical reasons and could be moved later

<p>


connective <- [ ]* !predstart ([Nn] [Oo] juncture? !i)? (a/e/i/o/u/Hearly a/Nearly UU) juncture? !V2 !(!predstart [Ff] [Ii]) !(!predstart [Mm] [Aa]) !(!predstart [Zz] [Ii])

<p>


<x>cmapua units starting with consonants.  This is the exact description from NB3.  The fancy tail in each of the 
<x>three cases is enforcing the rule about pausing before a following predicate if stressed.

<p>

<x>consonant initial cmapua units may not be followed by vowels without pause.

<p>

<x>I am adding [iy] and [uy] (always monosyllable, yuh and wuh) as vowel pairs permitted in VV and CVV cmapua units.
<x>it is worth noting that the "yuh" and "wuh" pronunciations of these diphthongs
<x>are surprising to the English-reading eye.
<x>The use for this envisaged is that the name [ziy] of Y becomes easy to introduce.  Adding word space
<x>is always nice, and these words seem pronounceable.  I also made [yfi] possible:  Y now has phonetically
<x>regular names.
<p>

CmapuaUnit <- (C1 Mono juncture? V2 !(['*] [ ]* &C1 predstart) juncture? !V1/C1 (VV/[Ii][Yy]/[Uu][Yy]) !(['*] [ ]* &C1 predstart) juncture? !V1/C1 V2 !(['*] [ ]* &C1 predstart) juncture? !V1) 

<p>

<x>A stream of cmapua is read until the start of a predicate or a name marker word or an alien text marker word or a quote or parenthesis marker word is encountered.
<x>the stream might resume with a name marker word if it does not in fact start a name word and does not potentially start a name
<x>word due to inexplicit whitespace (doesn't satisfy the bad name marker condition).

<p>

<x>we force explicit comma pauses before logical connectives, but not before vowel initial cmapua in general;
<x>other conditions force at least whitespace, which does stand for a pause, before such words.

<p>

<x>detect starts of quotes or parentheses with li or [kie]

<p>

likie <- ([Ll] [Ii] juncture? !V1/[Ki] [Ii] juncture? [Ee] juncture? !V1)

<p>

<x>a special provision is made for NO UI forms as single words.  [yfi] is supported.

<p>

Cmapua <- &caprule !badnamemarker (!predstart (VV/[Ii][Yy]/[Uu][Yy]) !(['*] [ ]* &C1 predstart) juncture? NOI/!predstart [Nn] [Oo] juncture? !predstart (VV/[Ii][Yy]/[Uu][Yy]) !(['*] [ ]* &C1 predstart) juncture?/((!predstart (VV/[Ii][Yy]/[Uu][Yy]) !(['*] [ ]* &C1 predstart) juncture?)+ / ((!predstart V1 !(['*] [ ]* &C1 predstart) juncture?)/ !predstart CmapuaUnit) (!namemarker !alienmarker !likie !predstart CmapuaUnit)*)/!predstart V2 !(['*] [ ]* &C1 predstart) juncture?) !V1 !(C1+ juncture) !([ ]* connective)

<p>

<x>I have apparently now completely solved the problem of parsing cmapua as well as name words.

<p>

<H3>Predicate Phonetics</H3>

<x>Now for predicates.

<H4>Djifoa ("affixes")</H4>

<p>

<x>the elementary djifoa (not borrowings)

<p>

<x>various special flavors of these djifoa will be needed.
<x>These are the general definitions.

<p>

<x>The NOY and Bad forms are for use for testing candidate borrowings for resolution
<x>with bad syllable break placements.  Borrowings do not contain Y...

<p>

<x>CVV djifoa with phonetic hyphens.

<p>

<x>added checks to all cmapua classes:  the vowel final ones, when not phonetically hyphenated, cannot
<x>be followed by a regular vowel.  This is crucial for getting the syllable analysis and the djifoa
<x>analysis to end at the same point.

<p>

<x>allowing h to be inserted before y in CVVy djifoa for a CVVhy form.

<p>

<x>allowing -r glue to be expressed as -rr

<p>

CVV <- C1 VV (juncture? [Hh]? [Yy] [-]? &(Complex) /juncture? [Rr] [Rr]? juncture? &C1/[Nn] juncture? &[Rr]/juncture? !V2)

<p>

CVVNoHyphen <- C1 VV juncture? !V2

<p>

CVVHiddenStress <- C1 &DoubleVowel V1 [-]? V1 ([-]? [Hh]? [Yy] [-]? &Complex /[Rr] [-]? &C1/[Nn] [-]? &[Rr]/[-]? !V2)

<p>

CVVFinalStress <- C1 VV (['*] [Hh]? [Yy] [-]? &Complex /[Rr] ['*] &C1/['*] [Rr] [Rr] juncture? &C1/[Nn] ['*] &[Rr]/['*] !V2)

<p>

CVVNOY <- C1 VV (juncture? [Rr] [Rr]? juncture? &C1/[Nn] juncture? &[Rr]/juncture? !V2) 

<p>

CVVNOYFinalStress <- C1 VV ([Rr] ['*] &C1/['*] [Rr] [Rr] juncture? &C1/[Nn] ['*] &[Rr]/['*] !V2)

<p>

CVVNOYMedialStress <- C1 !BrokenMono V2 ['*] V2 [-]? !V2

<p>

<x>CCV djifoa with phonetic hyphens.

<p>

CCV <- Initial V2 (juncture? [Yy] [-]? &letter/juncture? !V2)

<p>

CCVStressed <- Initial V2 (['*] [Yy] [-]? &letter/['*] !V2)

<p>

CCVNOY <- Initial V2 juncture? !V2
<p>

CCVBad <- MaybeInitial V2 juncture? !V2

CCVBadStressed <- MaybeInitial V2 ['*] !V2

<p>


<x>CVC djifoa with phonetic hyphens.  These cannot be final and are always followed by a consonant (well, the
<x>-y form may be followed by a vowel...
<x>an eccentric syllable break is supported if the CVC is y-hyphenated:
<x>[me-ky-kiu] and [mek-y-kiu] are both legal.  The default is the latter.

<p>

CVC <- (C1 V2 !NoMedial2 !NoMedial3 C1 (juncture? [Yy] [-]? &letter/juncture? &C1)/C1 V2 juncture C1 [Yy] [-]? &letter)

<p>

CVCStressed <- (C1 V2 !NoMedial2 !NoMedial3 C1 (['*] [Yy] [-]? &letter/['*] &letter)/C1 V2 ['*] C1 [Yy] [-]? &letter)

<p>

CVCNOY <- C1 V2 !NoMedial2 !NoMedial3 C1 juncture? &C1

<p>

CVCBad <- C1 V2 !NoMedial2 !NoMedial3 juncture? C1 &C1

<p>

CVCNOYStressed <- C1 V2 !NoMedial2 !NoMedial3 C1 ['*] &C1

<p>

CVCBadStressed <- C1 V2 !NoMedial2 !NoMedial3 ['*] C1 &C1

<p>

<x>the five letter forms (always final in complexes)

CCVCV <- Initial V2 juncture? C1 V2 [-]? !V2

<p>

CCVCVStressed <- Initial V2 ['*] C1 V2 [-]? !V2

<p>

CCVCVBad <- MaybeInitial V2 juncture? C1 V2 [-]? !V2

<p>

CCVCVBadStressed <- MaybeInitial V2 ['*] C1 V2 [-]? !V2

<p>

CVCCV <- (C1 V2 juncture? Initial V2 [-]? !V2/C1 V2 !NoMedial2 C1 juncture? C1 V2 [-]? !V2)

<p>

CVCCVStressed <- (C1 V2 ['*] Initial V2 [-]? !V2/C1 V2 !NoMedial2 C1 ['*] C1 V2 [-]? !V2)

<p>

<x>the medial five letter djifoa

<p>

CCVCY <- Initial V2 juncture? C1 [Yy] [-]?

<p>

CVCCY <- (C1 V2 juncture? Initial [Yy] [-]?/C1 V2 !NoMedial2 C1 juncture? C1 [Yy] [-]?)

<p>

CCVCYStressed <- Initial V2 ['*] C1 [Yy] [-]?

<p>

CVCCYStressed <- (C1 V2 ['*] Initial [Yy] [-]?/C1 V2 !NoMedial2 C1 ['*] C1 [Yy] [-]?)

<p>

<H4>Borrowed Predicates</H4>

<x>to reason about resolution of borrowings into both syllables and djifoa (we want to exclude the latter
<x>but we need to define it adequately) we need to recognize where to stop.  A predicate word ends either
<x>at a non-character (not a letter or syllable mark: whitespace, comma or terminal punctuation) or it
<x>has an explicit or deducible penultimate stress.  Borrowings do not contain doubled vowels, so they
<x>have to have explicit stress in the latter case.

<p>

<x>analysis:  the stressed tail consists of a stressed syllable followed by an unstressed syllable.
<x>identifying an unstressed final syllable is complicated by recognizing which CVV combinations can
<x>be one syllable.  This will either be an explicitly stressed syllable followed by a single syllable
<x>or a syllable suitable to be stressed followed by an explicitly final syllable.  CVV djifoa can
<x>contain both syllables in a tail and of course the five letter djifoa have to be tails.  A never stressed
<x>SyllableC (with a continuant) may intervene.

<p>

<x>tail of a borrowing with an explicit stress

<p>

BorrowingTail1 <- !SyllableC &StressedSyllable BorrowingSyllable (!StressedSyllable &SyllableC BorrowingSyllable)? !StressedSyllable &BorrowingSyllable VowelFinal

<p>

<x>tail of a borrowing or borrowing djifoa with no explicit stress

<p>

BorrowingTail2 <- !SyllableC BorrowingSyllable (!StressedSyllable &SyllableC BorrowingSyllable)? !StressedSyllable &BorrowingSyllable VowelFinal (&[Yy]/!character)

<p>

<x>tail of a stressed borrowing djifoa, different because stress is shifted to the end

<p>

BorrowingTail3 <- !SyllableC !StressedSyllable BorrowingSyllable (!StressedSyllable &SyllableC BorrowingSyllable)? &BorrowingSyllable InitialConsonants? Vocalic ['*] &[Yy]

<p>

BorrowingTail <- BorrowingTail1 / BorrowingTail2

<p>

<x>short forms that are ruled out:  CCVV and CCCVV forms.

<p>

CCVV <- (InitialConsonants V2 juncture? V2 juncture? !character / InitialConsonants V2 ['*] !Mono V2 juncture?)

<p>

<x>VCCV and some related forms are ruled out (rule predstartF above is about this)

<p>

<x>a continuant syllable cannot be initial in a borrowing and there cannot be successive continuant
<x>syllables.  There really ought to be no more than one!

<p>

<x>borrowing, before checking that it doesnt resolve into djifoa

<p>

PreBorrowing <- &predstart!CCVV!Cmapua!SyllableC(!BorrowingTail!(StressedSyllable)!(SyllableC SyllableC)BorrowingSyllable)* BorrowingTail

<p>

<x>ditto for an explicitly stressed borrowing

<p>

StressedPreBorrowing <- &predstart!CCVV!Cmapua!SyllableC(!BorrowingTail!(StressedSyllable)!(SyllableC SyllableC)BorrowingSyllable)* BorrowingTail1

<p>

<x>borrowing djifoa without explicit stress (before resolution check)

<p>

PreBorrowing2 <- &predstart!CCVV!Cmapua!SyllableC(!BorrowingTail!(StressedSyllable)!(SyllableC SyllableC)BorrowingSyllable)* BorrowingTail2

<p>

<x>stressed borrowing djifoa (before resolution check).

<p>

PreBorrowing3 <- &predstart!CCVV!Cmapua!SyllableC(!BorrowingTail3!(StressedSyllable)!(SyllableC SyllableC)BorrowingSyllable)* BorrowingTail3

<x>Now comes the problem of trying to say that a preborrowing cannot resolve into cmapua.  The difficulty is with
<x>recognizing the tail, so making sure that the two resolutions stop in the same place.

<p>

<x>we know because it is a borrowing that there is at most one explicit stress, and it has to fall
<x>in one of the cmapua!  This should make it doable.

<p>

<x>borrowing djifoa are terminated with y, so the final djifoa needs to take this into account

<p>

<x>the idea behind both djifoa analyses is the same.  If we end with a final djifoa followed by
<x>a non-character, we improve our chances of ending the syllable analysis at the same point.  We control
<x>this by identifying djifoa with stresses in them:  a medially stressed djifoa must be the last one
<x>(and the syllable analysis will find its stressed syllable and end at its final syllable, the fact
<x>that djifoa cannot be followed by vowels ensuring that the syllable analysis cannot overrun its end.
<x>When the djifoa is finally stressed, the complex analysis ends with a further djifoa guaranteed to have
<x>just one syllable, and the syllable analysis again will stop in the same place.  The medial five letter forms
<x>and borrowing djifoa of course are finally stressed mod an additional unstressed syllable which is skipped
<x>by the syllable analysis, because it allows one to ignore an actually penultimate syllable with y or 
<x>a syllabic consonant.  In the case where we never find a stress and end up at a final djifoa, the syllable
<x>analysis will carry right through to the same final point.
<p>

<x>in the attempted resolution of borrowings, our life is easier because we do not have
<x>borrowing djifoa or medial five letter forms to consider, or any forms with y-hyphens.

<p>

RFinalDjifoa <- (CCVCVBad/CVCCV/CVVNoHyphen/CCVBad/CVCBad) (&[Yy]/!character)

<p>

RMediallyStressed <- (CCVCVBadStressed/CVCCVStressed/CVVNOYMedialStress)

<p>

RFinallyStressed <- (CVVNOYFinalStress/CCVBadStressed/CVCBadStressed/CVCNOYStressed)

<p>

BorrowingComplexTail <- (RMediallyStressed/RFinallyStressed (&(C1 Mono) CVVNoHyphen/CCVBad)/RFinalDjifoa)

<p>

ResolvedBorrowing <- (!BorrowingComplexTail(CVVNOY/CCVBad/CVCBad))* BorrowingComplexTail

<p>

<x>borrowed predicates

Borrowing <- !ResolvedBorrowing &caprule PreBorrowing !([ ]* (connective))

<p>

<x>explicitly stressed borrowed predicates

<p>

StressedBorrowing <- !ResolvedBorrowing &caprule StressedPreBorrowing !([ ]* &V1 Cmapua)

<p>

#This is the shape of non-final borrowing djifoa.  Notice that a final stress is allowed.
#The curious provision for explicitly stressing a borrowing djifoa and pausing is supported.

<p>

<x>borrowing djifoa without explicit stress (stressed ones are not of this class!)
<x>Note that one can pause after these (explicitly, with a comma, in which case the stress must be explicit too)

<p>

BorrowingDjifoa <- !ResolvedBorrowing &caprule PreBorrowing2 (['*] [y] [,] [ ]+/juncture? [y] [-]?)

<p>

<x>stressed borrowing djifoa finally implemented!

<p>

StressedBorrowingDjifoa <- !ResolvedBorrowing &caprule PreBorrowing3 [y] [-]? ([,] [ ]+)?

<p>

<H4>Complex Predicates</H4>

<x>We resolve complexes twice, once into syllables and once into djifoa.  We again have to ensure that
<x>we end up in the same place!  The syllable resolution is very similar to that of borrowings;
<x>the unstressed middle syllable of the tail can be a SyllableY, and can also be a
<x>SyllableC if the final djifoa is a borrowing.

<p>

<x>A stressed borrowing djifoa with the property that the tail is still a phonetic complex is
<x>a unit for this analysis.

<p>

<x>note here that I specifically rule out a complex being followed without pause by y.  I do not rule
<x>this out for the vowel final djifoa because they can be followed by y at the end of a borrowing
<x>djifoa.

<p>

DefaultStressedSyllable <- Syllable

<p>


PhoneticComplexTail1 <- !SyllableC !SyllableY &StressedSyllable DefaultStressedSyllable (!StressedSyllable &(SyllableC/SyllableY) Syllable)? !StressedSyllable !SyllableY VowelFinal !V1

<p>

PhoneticComplexTail2 <- !SyllableC !SyllableY DefaultStressedSyllable (!StressedSyllable &(SyllableC/SyllableY) Syllable)? !StressedSyllable !SyllableY VowelFinal !character

<p>

PhoneticComplexTail <- PhoneticComplexTail1 / PhoneticComplexTail2

<p>

<x>note the explicit predstart test here.

<p>

PhoneticComplex <- &predstart!CCVV!Cmapua!SyllableC(StressedBorrowingDjifoa &PhoneticComplex/!PhoneticComplexTail!(StressedSyllable)!(SyllableC SyllableC) Syllable)* PhoneticComplexTail

<p>

<x>the analysis of final djifoa and stressed djifoa differs only in details from
<x>what is above for resolution of borrowings.  The issues about CVV djifoa with doubled
<x>vowels are rather exciting.

<p>

<x>a stressed borrowing djifoa with the tail still a phonetic complex is a black box unit for
<x>this construction.

<p>

<x>My approach imposes the restriction on JCB's "pause after a borrowing djifoa" idea that what follows
<x>the pause must itself contain a penultimate stress:  [igllu'ymao] is a predicate but [igllu'y, mao] is not.
<x>while [iglluy', gudmao] is a predicate.

<p>

<x>the analysis of the djifoa resolution process is the same as above, with additional remarks
<x>about doubled vowel syllables:  notice that where the complex tail involved a doubled vowel syllable
<x>without explicit stress, we insist on that djifoa or the single-syllable next djifoa ending in
<x>a non-character:  in the absence of explicit stress, we always rely on whitespace or punctuation
<x>to indicate the end of the predicate.

<p>

<x>all sorts of subtleties about borrowings and borrowing djifoa are finessed by always looking for
<x>them first.  There are no restrictions re fronts of borrowings or borrowing djifoa looking like regular
<x>djifoa;  the fact that borrowing djifoa end in y and borrowings do not contain y makes it always
<x>possible to tell when one is looking at the head of a borrowing djifoa.  Regular djifoa just before a borrowing
<x>djifoa need to be y-hyphenated so as not to be absorbed into the front of the borrowing (I don't believe
<x>that I actually need to impose a formal rule to this effect, though I am not absolutely certain;  it would
<x>be difficult to formulate [and does appear in the previous version, where it is a truly unintelligible piece
<x>of PEG code]).

<p>

FinalDjifoa <- (Borrowing/CCVCV/CVCCV/CVVNoHyphen/CCVNOY) !character

<p>

MediallyStressed <- (StressedBorrowing/CCVCVStressed/CVCCVStressed/CVVNOYMedialStress)
<p>

FinallyStressed <-(StressedBorrowingDjifoa/CCVCYStressed/CVCCYStressed/CVVFinalStress/CCVStressed/CVCStressed)

<p>

ComplexTail <- (CVVHiddenStress (&(C1 Mono) CVVNoHyphen/CCVNOY) !character/FinallyStressed (&(C1 Mono) CVVNoHyphen/CCVNOY)/MediallyStressed/FinalDjifoa)

<p>

PreComplex <-  (!CVVHiddenStress (!ComplexTail)(StressedBorrowingDjifoa &PhoneticComplex/BorrowingDjifoa/CVCCY/CCVCY/CVV/CCV/CVC))* ComplexTail

<p>

<x>originally I had complicated tests here for the conditions under which an initial
<x>CVC cmapua has to be y-hyphenated:  I was being wrong headed, the predstart rules
<x>already enforce this (in the bad cases, the initial CV- falls off).  The user will
<x>simply find that they cannot put the word together otherwise.  The previous version
<x>did need this test because it actually used full lookahead to check for the start of a predicate.

<p>

Complex <- &caprule &PreComplex PhoneticComplex !([ ]* (connective))

<p>

<H3>Quotation and Parenthesis of well-formed Loglan utterances; word classes</H3>

<x>format for the LI quote and KIE parenthesis

<p>

LiQuote <- (&caprule [Ll][Ii]juncture? comma2? [\"] phoneticutterance [\"] comma2? &caprule [Ll][Uu]juncture? !([ ]* connective)/(&caprule [Kk][Ii]juncture?[Ee]juncture? comma2? [(] phoneticutterance [)] comma2? &caprule [Kk][Ii]juncture?[Uu]juncture? !([ ]* connective)))

<p>

<x>the condition on Word that a Cmapua is not followed by another Cmapua
<x>with mere whitespace between was used by [liu] quotation, but is now redundant,
<x>because I have required that [liu] quotations be closed with explicit pauses in all cases.

<p>

Word <- (NameWord / Cmapua / Complex/CCVNOY)

<p>

<x>it is an odd point that all borrowings parse as complexes -- so when I parsed all the words the first time they all
<x>parsed as complexes.  A borrowing is a complex consisting of a single final borrowing djifoa!
<x>I did redesign this so that borrowings are parsed as borrowings.  (This is the class
<x>I used to parse the dictionary).

<p>

<x>Yes, CVC djifoa do get parsed as names in the dictionary, so the CVC case here is redundant.  I actually
<x>think that only the CCV djifoa actually get parsed as such.

<p>

SingleWord <- (Borrowing !./Complex !./ Word !./PreName !. /CCVNOY) !.

<p>

<x>name word appearing initially without leading spaces is important, because one type of NameWord includes a leading comma.

<H3>The full phonetic utterance classes</H3>

<p>

phoneticutterance1 <- (NameWord /[ ]* LiQuote/[ ]* NameWord/[ ]* AlienWord/[ ]*Cmapua/[ ]* '--'/[ ]* '...'/[ ]* Borrowing![y]/[ ]* Complex/[ ]* (CCVNOY))+

<p>

phoneticutterance <- (phoneticutterance1/[,][ ]+/terminal)+

<p>

<H2>Interlude:  Phonemes and Pauses</H2>

<H3>Consonants and vowel groups in cmapua</H3>

<x>as noted above, !predstart stands in for the computationally disastrous &Cmapua

<p>

badstress <- ['*] [ ]* &C1 predstart
<p>
B <- (!predstart [Bb])
<p>
C <- (!predstart [Cc])
<p>
D <- (!predstart [Dd])
<p>
F <- (!predstart [Ff])
<p>
G <- (!predstart [Gg])
<p>
H <- (!predstart [Hh])
<p>
J <- (!predstart [Jj])
<p>
K <- (!predstart [Kk])
<p>
L <- (!predstart [Ll])
<p>
M <- (!predstart [Mm])
<p>
N <- (!predstart [Nn])
<p>
P <- (!predstart [Pp])
<p>
R <- (!predstart [Rr])
<p>
S <- (!predstart [Ss])
<p>
T <- (!predstart [Tt])
<p>
V <- (!predstart [Vv])
<p>
Z <- (!predstart [Zz])
<p>
<x>the monosyllabic classes may be followed by one vowel
<x>if they start a Cvv-V cmapua unit;  the others may never
<x>be followed by vowels.  Classes ending in -b are
<x>used in Cvv-V cmapua units.
<p>
<x>the single vowel classes were moved before the class
<x>connective in the phonetics section.
<p>

V3 <- juncture? V2 !badstress
<p>
AA <- ([Aa] juncture? [Aa] !badstress juncture? !V1)  
<p>
AE <- ([Aa] juncture? [Ee]  !badstress juncture? !V1)  
<p>
AI <- ([Aa] [Ii]  !badstress juncture? !(V1))  
<p>
AO <- ([Aa] [Oo]  !badstress juncture? !(V1)) 
<p>
AIb <- ([Aa] [Ii]  !badstress juncture? &(V2 juncture? !V1))  
<p>
AOb <- ([Aa] [Oo]  !badstress juncture? &(V2 juncture? !V1))  
<p> 
AU <- ([Aa] juncture? [Uu]  !badstress juncture? !V1)  
<p>
EA <- ([Ee] juncture? [Aa]  !badstress juncture? !V1)  
<p>
EE <- ([Ee] juncture? [Ee]  !badstress juncture? !V1)  
<p>
EI <- ([Ee] [Ii]  !badstress juncture? !(V1)) 
<p>
EIb <- ([Ee] [Ii]  !badstress juncture? &(V2 juncture? !V1))  
<p>
EO <- ([Ee] juncture? [Oo]  !badstress juncture? !V1)  
<p>
EU <- ([Ee] juncture? [Uu]  !badstress juncture? !V1)  
<p>
IA <- ([Ii] juncture? [Aa]   !badstress juncture? !(V1))  
<p>
IE <- ([Ii] juncture? [Ee]  !badstress juncture? !(V1))  
<p>
II <- ([Ii] juncture? [Ii]  !badstress juncture? !(V1))  
<p>
IO <- ([Ii] juncture? [Oo]  !badstress juncture? !(V1))  
<p>
IU <- ([Ii] juncture? [Uu]   !badstress juncture? !(V1)) 
<p>
IAb <- ([Ii] juncture? [Aa]   !badstress juncture? &(V2 juncture? !V1))  
<p>
IEb <- ([Ii] juncture? [Ee]  !badstress juncture? &(V2 juncture? !V1))  
<p>
IIb <- ([Ii] juncture? [Ii]  !badstress juncture? &(V2 juncture? !V1))  
<p>
IOb <- ([Ii] juncture? [Oo]  !badstress juncture? &(V2 juncture? !V1))  
<p>
IUb <- ([Ii] juncture? [Uu]   !badstress juncture? &(V2 juncture? !V1))   
<p>
OA <- ([Oo] juncture? [Aa]  !badstress juncture? !V1)  
<p>
OE <- ([Oo] juncture? [Ee]  !badstress juncture? !V1)  
<p>
OI <- ([Oo] [Ii]  !badstress juncture? !(V1)) 
<p>
OIb <- ([Oo] [Ii]  !badstress juncture? &(V2 juncture? !V1)) 
<p>
OO <- ([Oo] juncture? [Oo]  !badstress juncture? !V1)  
<p>
OU <- ([Oo] juncture? [Uu]   !badstress juncture? !V1)  
<p>
UA <- ([Uu] juncture? [Aa]   !badstress juncture? !(V1))  
<p>
UE <- ([Uu] juncture? [Ee]  !badstress juncture? !(V1))  
<p>
UI <- ([Uu] juncture? [Ii]   !badstress juncture? !(V1))  
<p>
UO <- ([Uu] juncture? [Oo]  !badstress juncture? !(V1))  
<p>
UU <- ([Uu] juncture? [Uu]  !badstress juncture? !(V1)) 
<p>
UAb <- ([Uu] juncture? [Aa]   !badstress juncture? &(V2 juncture? !V1))  
<p>
UEb <- ([Uu] juncture? [Ee]  !badstress juncture? &(V2 juncture? !V1))  
<p>
UIb <- ([Uu] juncture? [Ii]   !badstress juncture? &(V2 juncture? !V1))  
<p>
UOb <- ([Uu] juncture? [Oo]  !badstress juncture? &(V2 juncture? !V1))  
<p>
UUb <- ([Uu] juncture? [Uu]  !badstress juncture? &(V2 juncture? !V1))   
<p>
<x>adding the new IY and UY, which might see use some time.
<x>they are mandatory monosyllables but do not take a possible additional
<x>following vowel as the regular ones do.  So far only used in [ziy].
<p>
IY <- [Ii] [Yy] !badstress juncture? !V1
<p>
UY <- [Uu] [Yy] !badstress juncture? !V1
<p>
<H3>The optional pause and commas</H3>
<p>
<x>this is a pause not required by the phonetics.  This is the only
<x>sort of pause which could in principle carry semantic freight (the
<x>pause/GU equivalence beloved of our Founder) but we have abandoned
<x>this.  There is one place, after initial no in an utterance, where
<x>a pause can have effect on the parse (but not on the meaning, I believe, 
<x>unless a word break is involved).

<p>

<x>this class should NEVER be used in a context which might follow
<x>a name word.  In previous versions, pauses after name words were included
<x>in the name word;  this is not the case here, so a PAUSE
<x>after a name word would not be recognized as a mandatory pause.

<p>

<x>in any event, as long as we stay away from pause/GU equivalence, this
<x>is not a serious issue!

<p>

<x>this class does do some work in the handling of issues surrounding the legacy
<x>shape of APA connectives, concerning which the less said, the better.

<p>

PAUSE <- [,] [ ]+ !(V1/connective) &caprule

<p>

<x>more punctuation
<p>
comma <- [,] [ ]+ &caprule
<p>
comma2 <- [,]? [ ]+ &caprule
<p>
<H2>Part II: Lexicography</H2>
<x>In this section I develop the grammar of words in Loglan.  I'll work by editing the original provisional PEG grammar.

<p>

<x>I place the start of this section exactly here, just before two final items of
<x>punctuation, because these items of punctuation look forward not only to lexicography
<x>but to the full grammar!

<H3>Period and end of utterance</H3>

<p>

<x>the end of utterance symbol [#] should be added in the phonetics
<x>section as a species of terminal marker. Done.  We do *not* actually
<x>endorse use of this marker, but we can notionally support it and it is in 
<x>our sources.

<p>

end <- (([ ]* '#' [ ]+ utterance)/([ ]+ !.)/!.)

<p>

<x>this rule allows terminal punctuation to be followed by an inverse vocative,
<x>a frequent occurrence in Leith's novel, and something which makes sense.

<p>

period <- (([!.:;?] (&end/([ ]+ &caprule))) (invvoc period?)?)

<p>

<x>Letters with y will be special cases
<x>idea:  allow IY and UY (always monosyllables) as vowel combinations in cmapua only.
<x>done:  Y has a name now.  [yfi] is also added.

<p>

<H3>The cmapua word classes</H3>

<x>the classes in this section after this point are the cmapua word classes of Loglan (if they begin with [ ]* or a word class).
<x>I suppose the alien text classes are not really word classes, but they are lexicographic items, as it were.
<x>Paradoxically, the PA and NI classes admit internal explicit pauses.  So of course do predicate words!

<p>

<x>Loglan does admit true multisyllable cmapua:  there are words made of cmapua units which have joints between
<x>units at which one cannot pause without breaking the word.  Lojban, I am told, does not.

<p>

<x>this version has the general feature that the quotation and alien text constructions are not hacked:
<x>they are supported by the phonetic rules (as dire exceptions, of course) and the grammatical constructions
<x>conform with the phonetic layer.  Alien text and utterances quoted with [li]...[lu] can be enclosed in double quotes.
<x>LI only supports full utterances, for the moment.  All alien text constructors take the same class as argument:
<x>the vocative and inverse vocative *require* quotes to avoid misreading ungrammatical expressions with typos
<x>as correct (inverse) vocatives.

<p>

<H4>Letterals (first approximation) </H4>

<x>the names [yfi], [ziy] for Y are supported.  The Ceo names are left as they are.  I decided that a second short series
<x>of letteral pronouns is actually a reasonable use of short words, and the Ceio words are there for other uses.

<p>

TAI0 <- (V1 juncture? M a/V1 juncture? F i/V1 juncture? Z i/!predstart C1 AI/!predstart C1 EI/!predstart C1 AIb u/!predstart C1 EIb (u)/!predstart C1 EO/ Z [Ii] V1 !badstress juncture? !V1 (M a)?)

<p>

<H4>Logical and causal connectives</H4>

<x>a negative suffix used in various contexts.  Always a suffix:  its use as a prefix in tenses was a mistake in NB3 and I 
<x>think still supported in LIP.  Ambiguities demonstrably followed from this usage (an example of how the demonstration
<x>of non-ambiguity of 1989 Loglan was compromised by the opaque lexicography).

<p>

NOI <- (N OI)

<p>

<x>the logical connectives.  [A0] is the class of core logical connectives.  [A] is the fully decorated logical connective with
<x>possible nu- (always in nuno- or nuu) and no- prefixes, possible -noi suffix, and possible (problematic) PA suffix, closed
<x>with -fi (our new proposal) or an explicit pause.

<p>

A0 <- &Cmapua (a/e/o/u/H a/N UU)
<p>
A <- [ ]* !predstart !TAI0 (N [o])? A0 NOI? !([ ]+ PANOPAUSES PAUSE) !(PANOPAUSES !PAUSE [ ,]) (PANOPAUSES ((F i)/&PAUSE))?
<p>
<x>4/18 in connected sentpreds, fi must be used to close, not a pause.
<p>
<x>A2 <- [ ]* !predstart !TAI0 (N [o])? A0 NOI? !([ ]+ PANOPAUSES PAUSE) !(PANOPAUSES !PAUSE [ ,]) (PANOPAUSES (F i))?
<p>


<x>A not closed with -fi or a pause
<p>
ANOFI <- [ ]* (!predstart !TAI0 ( (N [o])? A0 NOI? PANOPAUSES?))
<p>
A1 <- A
<p>
<x>versions of A with different binding strength
<p>
ACI <- (ANOFI C i)
<p>
AGE <- (ANOFI G e)
<p>
<x>a tightly binding series of logical connectives used to link predicates
<x>this also includes the fusion connective [ze] when used between predicates.
<p>
CA0 <- (( (N o)? ((C a)/(C e)/(C o)/(C u)/(Z e)/(C i H a)/N u C u)) NOI?)
<p>
CA1 <- (CA0 !([ ]+ PANOPAUSES PAUSE) !(PANOPAUSES !PAUSE [ ,]) (PANOPAUSES ((F i)/&PAUSE))?)
<p>
CA1NOFI <- (CA0 PANOPAUSES?)
<p>
CA <- ([ ]* CA1)
<p>
<x>the fusion connective when used in arguments
<p>
ZE2 <- ([ ]* (Z e))
<p>
<x>sentence connectives.  [I] is the class of utterance initiators (no logical definition).
<x>the subsequent classes are inhabited by sentence logical connectives with various binding
<x>strengths.
<p>
I <- ([ ]* !predstart !TAI0 i !([ ]+ PANOPAUSES PAUSE) !(PANOPAUSES !PAUSE [ ,]) (PANOPAUSES ((F i)/&PAUSE))?)
<p>
ICA <- ([ ]* i ((H a)/CA1))
<p>
ICI <- ([ ]* i CA1NOFI? C i)
<p>
IGE <- ([ ]* i CA1NOFI? G e)
<p>
<x>forethought logical connectives
<p>
KA0 <- ((K a)/(K e)/(K o)/(K u)/(K i H a)/(N u K u))
<p>
<x>causal and comparative modifiers
<p>
KOU <- ((K OU)/(M OI)/(R AU)/(S OA)/(M OU)/(C IU))
<p>
<x>negative and converse forms
<p>
KOU1 <- (((N u N o)/(N u)/(N o)) KOU)
<p>
<x>the full type of forethought connectives, adding the causal and comparative connectives
<p>
KA <- ([ ]* ((KA0)/((KOU1/KOU) K i)) NOI?)
<p>
<x>the last component of the KA...KI... structure of forethought connections
<p>
KI <- ([ ]* (K i) NOI?)
<p>
<x>causal and comparative modifiers which are *not* forethought connectives

KOU2 <- (KOU1 !KI)
<p>
<H4>Quantity words</H4>
<p>
<x>a test used to at least partially enforce the penultimate stress rule on quantifier predicates
<p>
BadNIStress <- ((C1 V2 V2? stress (M a)? (M OA)? NI RA)/(C1 V2 stress V2 (M a)? (M OA)? NI RA))
<p>
<x>root quantity words, including the numerals
<p>
NI0 <- (!BadNIStress ((K UA)/(G IE)/(G IU)/(H IE)/(H IU)/(K UE)/(N EA)/(N IO)/(P EA)/(P IO)/(S UU)/(S UA)/(T IA)/(Z OA)/(Z OO)/(H o)/(N i)/(N e)/(T o)/(T e)/(F o)/(F e)/(V o)/(V e)/(P i)/(R e)/(R u)/(S e)/(S o)/(H i)))
<p>
<x>the class of SA roots, which modify quantifiers
<p>
SA <- (!BadNIStress ((S a)/(S i)/(S u)/(IE (comma2? !IE SA)?)) NOI?)
<p>
<x>the family of quantifiers which double as suffixes for the quantifier predicates
<x>this class perhaps should also include some other quantifier words. [re] for example ought to be handled in the same way as [ra,ri,ro].
<x>No action here, just a remark.
<p>
RA <- (!BadNIStress ((R a)/(R i)/(R o)/R e/R u))
<p>
<x>re and ru added to class RA 5/11/18
<p>
<x>quantifier units consisting of a NI or RA root with [ma] 00 or [moa] 000 appended; to [moa] one can further
<x>append a digit to iterate [moa]:  [fomoate] is four billion, for example.  [rimoa], a few thousand.
<p>
<x>a NI1 or RA1 may be followed by a pause before another NI word other than a numerical predicate;
<x>one is allowed to breathe in the middle of long numerals.  I question whether the pause
<x>provision makes sense in RA1.
<p>
NI1 <- ((NI0 (!BadNIStress M a)? (!BadNIStress M OA NI0*)?) (comma2 !(NI RA) &NI)?)
<p>
RA1 <- ((RA (!BadNIStress M a)? (!BadNIStress M OA NI0*)?) (comma2 !(NI RA) &NI)?)
<p>
<x>a composite NI word, optional SA prefix before a sequence of NI words or a RA word,
<x>or a single SA word [which will modify a default quantifier not expressed], 
<x>possibly negated, connected with CA0 roots to other such constructs.
<p>
NI2 <- (( (SA? (NI1+/RA1))/SA) NOI? (CA0 ((SA? (NI1+/RA1))/SA) NOI?)*)
<p>
<x>a full NI word with an acronymic dimension (starting with [mue], ending with a pause) or [cu] appended.  I need to look up [cu]
<x>and figure out its semantics.  An arbitrary name word may now be used as a dimension, as well.
<p>
NI <- ([ ]* NI2 (&(M UE) Acronym (comma/&end/&period) !(C u)/comma2? M UE comma2? PreName !(C u))? (C u)?)
<p>
<x>mex is now identical with NI, but it's in use in later rules.
<p>
mex <- ([ ]* NI)

<p>

<H4> The overused CI</H4>

<x>a word used for various tightly binding constructions:  a sort of verbal hyphen.
<x>also a name marker, which means phonetic care is needed (pause after constructions with [ci]).
<p>
CI <- ([ ]* (C i))

<H4>Acronyms</H4>

<x>Acronyms, which are names (not predicates as in 1989 Loglan) or dimensions (in NI above).
<x>units in acronym are TAI0 letterals, zV short forms for vowels, the dummy unit [mue], and NI1
<x>quantity units.  NI1 quantity units may not be initial. [mue] units may be preceded by pauses.
<x>An acronym has at least two units.
<p>


<x>it is worth noting that acronyms, once viewed as names, could be entirely suppressed as a feature of the
<x>grammar by really making them names (terminate them with -n).  I suppose a similar approach would work
<x>for dimensions, allowing any name word to serve as a dimension.  [mue] would be a name marker for use
<x>with dimensions in this case.  [temuedain], three dollars.  Now supported.

<p>

Acronym <- ([ ]* &caprule ((M UE)/TAI0/(Z V2 !V2)) ((comma &Acronym M UE)/NI1/TAI0/(Z V2 (!V2/(Z &V2))))+)

<p>

<H4>Letterals and other pronouns</H4>

<x>the full class of letterals, including the [gao] construction whose details I should look at.

<p>

TAI <- ([ ]* (TAI0/((G AO) !V2 [ ]* (PreName/Predicate/CmapuaUnit))))
<p>
<x>atomic non-letteral pronouns.
<p>
#4/15/2019 reserved [koo] for a Lojban style imperative pronoun, though not officially adopting it.  Also adding [dao] for a default, don't care argument, another Lojban feature.
<p>
DA0 <- ((T AO)/(T IO)/(T UA)/(M IO)/(M IU)/(M UO)/(M UU)/(T OA)/(T OI)/(T OO)/(T OU)/(T UO)/(T UU)/(S UO)/(H u)/(B a)/(B e)/(B o)/(B u)/(D a)/(D e)/(D i)/(D o)/(D u)/(M i)/(T u)/(M u)/(T i)/(T a)/(M o)/(K OO)/(D AO))
<p>
<x>letterals (not including [gao] constructions and atomic pronouns optionally suffixed with a digit.  One should pause after the
<x>suffixed forms, because [ci] is a name marker.
<p>
DA1 <- ((TAI0/DA0) (C i ![ ] NI0)?)
<p>
<x>general pronoun words.

DA <- ([ ]* DA1)
<p>

<H4>Tenses, locatives and modals</H4>

<x>roots for PA words:  tense and location words, prepositions building relative modifiers.  All can optionally be negated with -noi.  They may also be quantified.  They may also be closed with ZI class affixes.  PA cores.
<p>
PA0 <- (NI2? (N u !KOU)? ((G IA)/(G UA)/(P AU)/(P IA)/(P UA)/(N IA)/(N UA)/(B IU)/(F EA)/(F IA)/(F UA)/(V IA)/(V II)/(V IU)/(C OI)/(D AU)/(D II)/(D UO)/(F OI)/(F UI)/(G AU)/(H EA)/(K AU)/(K II)/(K UI)/(L IA)/(L UI)/(M IA)/(N UI)/(P EU)/(R OI)/(R UI)/(S EA)/(S IO)/(T IE)/ (V IE)/(V a)/(V i)/(V u)/(P a)/(N a)/(F a)/(V a)/(KOU !(N OI) !KI)) (N OI)? ZI?)
<p>
<x>the form used for actual prepositions and suffixes to A words, with minimal pauses allowed.
<x>these are built by concatenating KOU2 and PA0 units, then linking these with CA0 roots (which can take
<x>no- prefixes and -noi suffixes, and next to which one *can* pause), optionally suffixed with a class ZI suffix.
<p>
PANOPAUSES <- ((KOU2/PA0)+ ((comma2? CA0 comma2?) (KOU2/PA0)+)*)
<p>
<x>prepositional words
<p>
PA3 <- ([ ]* PANOPAUSES)
<p>
<x>class PA can appear as tense markers or as relative modifiers without arguments; here pauses
<x>are allowed not only next to CA0 units but between KOU2/PA units.  Like NI words, PA
<x>words are a class of arbitrary length constructions, and we think breaths within them
<x>(especially complex ones) are natural.
<p>
PA <- ((KOU2/PA0)+ (((comma2? CA0 comma2?)/(comma2 !mod1a)) (KOU2/PA0)+)*) !modifier
<p>
PA2 <- ([ ]* PA)
<p>
GA <- ([ ]* (G a))
<p>
<x>the class of tense markers which can appear before predicates.
<p>
PA1 <- ((PA2/GA))
<p>
<x>suffixes which indicate extent or remoteness/proximity of the action of prepositions.

ZI <- ((Z i)/(Z a)/(Z u))

<p>
<H4> Articles and other descriptors</H4>
<x>the primitive description building "articles".  These include [la] which requires special
<x>care in its use because it is a name marker.
<p>
LE <- ([ ]* ((L EA)/(L EU)/(L OE)/(L EE)/(L AA)/(L e)/(L o)/(L a)))
<p>
<x>articles which can be used with abstract descriptions:  these include some quantity words.
<x>this means that some abstract descriptions are semantically indefinites:  I wonder if this
<x>could be improved by having a separate abstract indefinite construction.
<p>
LEFORPO <- ([ ]* ((L e)/(L o)/NI2))
<p>
<x>the numerical/quantity article.
<p>
LIO <- ([ ]* (L IO))
<p>
<x>structure words for the ordered and unordered list constructions.
<p>
LAU <- ([ ]* (L AU))
<p>
LOU <- ([ ]* (L OU))
<p>
LUA <- ([ ]* (L UA))
<p>
LUO <- ([ ]* (L UO))
<p>
ZEIA <- ([ ]* Z EIb a)
<p>
ZEIO <- ([ ]* Z EIb o)
<p>
<x>initial and final words for quoting Loglan utterances.
<p>
LI1 <- (L i)
<p>
LU1 <- (L u)
<p>

<H4>Quotations and other alien text constructions</H4>
<x>quoting Loglan utterances, with or without explicit double quotes (if they appear, they must
<x>appear on both sides).  The previous version allowed quotation of names;  likely this should
<x>be restored.
<p>
LI <- ([ ]* LI1 comma2? utterance0 comma2? LU1/[ ]* LI1 comma2? [\"] utterance0 [\"] comma2? LU1)
<p>
<x>the foreign name construction.  This is an alien text construction
<p>
LAO <- ([ ]* &([Ll] [Aa] [Oo]juncture?) AlienWord)
<p>
<x>the strong quotation construction.  This is an alien text construction.
<p>
LIE <- ([ ]* &([Ll] [Ii] juncture? [Ee]juncture?) AlienWord)
<p>
LIO1 <- ([ ]* &([Ll] [Ii] juncture? [Oo]juncture?) AlienWord)
<p>


<x>I am not sure this class is used at all.
<p>
LW <- Cmapua
<p>
<x>articles for quotation of words
<p>
LIU0 <- ((L IU)/(N IU))
<p>
<x>this now imposes the condition that an explicit comma pause (or terminal punctuation, or end) must appear at the end of the
<x>Word or PreName quoted with [liu].  This seems like a good idea, anyway.
<p>
<x>this class appeals to the phonetics.  Words and PreNames can be quoted.  The ability to quote names
<x>here may remove the need to quote them with [li]...[lu].  Of course, some Words are in fact phrases rather
<x>than single words:  we will see whether the privileges afforded are used.  The final clause allows
<x>use of letterals as actual names of letters.
<p>
<x>added [niu]:  didn't make it a name marker.
<p>
LIU1 <- ([ ]* ([Ll]/[Nn])[iI] juncture? [Uu] juncture? !V1 comma2? (PreName/Word) &(comma/terminal/end) /[ ]*(L II TAI ))
<p>
<x>the construction of foreign and onomatopoeic predicates.  These are alien text constructions.

SUE <- ([ ]* &([Ss] [Uu] juncture? [Ee] juncture?/[Ss] [Aa] [Oo] juncture?) AlienWord)
<p>

<H4>Assorted left and right closers</H4>
<x>left marker in a predicate metaphor construction
<p>
CUI <- ([ ]* (C UI) )
<p>
<x>other uses of GA
<p>
GA2 <- ([ ]* (G a) )
<p>
<x>ge/geu act as "parentheses" to make an atomic predicate from a complex metaphorically
<x>and logically connected predicates;  [ge] has other left marking uses.
<p>
GE <- ([ ]* (G e) )
<p>
GEU <- ([ ]* ((C UE)/(G EU)) )
<p>
<x>final marker of a list of head terms
<p>
GI <- ([ ]* ((G i)/(G OI)) )
<p>
<x>used to move a normally prefixed metaphorical modifier after what it modifies.
<p>
GO <- ([ ]* (G o) )
<p>
<x>marker for second and subsequent arguments before the predicate; NEW
<p>
GIO <- ([ ]* (G IO) )
<p>
<x>the generic right marker of many constructions.
<p>
GU <- ([ ]* (G u) )

<x>various flavors of right markers.

<x>It should be noted that at one point I executed a program of simplifying these to
<x>reduce the likelihood that multiple [gu]'s would ever be needed to close an utterance.
<x>first of all, I made the closures leaner, moving them out of the classes closed
<x>to their clients so that they generally can be used only when needed. 
<x>Notably, the grammar of [guu] is quite different.   Second,
<x>I introduced some new flavors of right marker.  All can be realized with [gu],
<x>but if one knows the right flavor one can close the right structure with a single
<x>right closure.

<x>right markers of subordinate clauses (argument modifiers).
<x>[gui] closes a different class than in the trial.85 grammar, with
<x>similar but on the whole better results.
<p>
GUIZA <- ([ ]* (G UI) (Z a) )
<p>
GUIZI <- ([ ]* (G UI) (Z i) )
<p>
GUIZU <- ([ ]* (G UI) (Z u) )
<p>
GUI <- (!GUIZA !GUIZI !GUIZU ([ ]* (G UI) ))
<p>
<x>right markers of abstract predicates and descriptions.
<x>probably the forms with z are to be preferred (and the other
<x>two are not needed) but I preserve all five classes for now. 
<p>
GUO <- ([ ]* (G UO) )
<p>
GUOA <- ([ ]* (G UOb a/G UO Z a) )
<p>
GUOE <- ([ ]* (G UOb e) )
<p>
GUOI <- ([ ]* (G UOb i/G UO Z i) )
<p>
GUOO <- ([ ]* (G UOb o) )
<p>
GUOU <- ([ ]* (G UOb u/G UO Z u) )
<p>
<x>right marker used to close term (argument/predicate modifier) lists.
<x>it is important to note that in our grammar GUU is not a component of
<x>the class termset, nor is it a null termset:  it appears in other classes
<x>which include termsets as an option to close them.  The effects are similar
<x>to those in the trial.85 grammar, but there is less of a danger that
<x>extra unexpected closures will be needed.
<p>
GUU <- ([ ]* (G UU) )
<p>
<x>a new closure for arguments in various contexts
<p>
GUUA <- ([ ]* (G UUb a) )
<p>
<x>a new closure for sentences.  In particular, it
<x>may have real use in closing up the scope of a list of
<x>fronted terms before a series of logically connected sentences.
<p>
GIUO <- ([ ]* (G IUb o) )
<p>
<x>right marker used to close arguments tightly linked with JE/JUE.

GUE <- ([ ]* (G UE) )
<p>
<x>a new closure for descpreds

GUEA <- ([ ]* (G UEb a) )
<p>

<H4>Miscellaneous clause constructors</H4>

<x>used to build tightly linked term lists.
<p>
JE <- ([ ]* (J e) )
<p>
JUE <- ([ ]* (J UE) )
<p>
<x>used to build subordinate clauses (argument modifiers).
<p>
JIZA <- ([ ]* ((J IE)/(J AE)/(P e)/(J i)/(J a)/(N u J i)) (Z a) )
<p>
JIOZA <- ([ ]* ((J IO)/(J AO)) (Z a) )
<p>
JIZI <- ([ ]* ((J IE)/(J AE)/(P e)/(J i)/(J a)/(N u J i)) (Z i) )
<p>
JIOZI <- ([ ]* ((J IO)/(J AO)) (Z i) )
<p>
JIZU <- ([ ]* ((J IE)/(J AE)/(P e)/(J i)/(J a)/(N u J i)) (Z u) )
<p>
JIOZU <- ([ ]* ((J IO)/(J AO)) (Z u) )
<p>
JI <- (!JIZA !JIZI !JIZU ([ ]* ((J IE)/(J AE)/(P e)/(J i)/(J a)/(N u J i)) ))
<p>
JIO <- (!JIOZA !JIOZI !JIOZU ([ ]* ((J IO)/(J AO)) ))
<p>

<H4>Case tags, semantic and positional</H4>
<x>case tags, both numerical position tags and the optional semantic case tags.
<p>
DIO <- ([ ]* ((B EU)/(C AU)/(D IO)/(F OA)/(K AO)/(J UI)/(N EU)/(P OU)/(G OA)/(S AU)/(V EU)/(Z UA)/(Z UE)/(Z UI)/(Z UO)/(Z UU)) ) (C i ![ ] NI0/ZI)?
<p>
<x>markers of indirect reference.  Originally these had the same grammar as case tags,
<x>but they are now different.
<p>
LAE <- ([ ]* ((L AE)/(L UE)) )
<p>

<H4> The predicate constructor me</H4>
<x>[me] turns arguments into predicates, [meu] closes this construction.
<p>
ME <- ([ ]* ((M EA)/(M e)) )
<p>
MEU <- ([ ]* M EU )
<p>
<H4> Reflexive and conversion operators</H4>
<p>
<x>reflexive and conversion operators:  first the root forms, then those with
<x>optional numerical suffixes.
<p>
NU0 <- ((N UO)/(F UO)/(J UO)/(N u)/(F u)/(J u))
<p>
NU <- [ ]* (((N u/N UO) !([ ]+ (NI0/RA)) (NI0/RA)?)/NU0)+ freemod?
<p>

<H4>Abstract predicate constructors</H4>

<x>I do *not* think
<x>that [poia] will really be confused with [po ia], particularly
<x>since we do require an explicit pause before [ia] in the latter case,
<x>but I record this concern:  the forms with z might be preferable.
<p>
#constructions from sentences

<p>
PO1 <- ([ ]* ((P o)/(P u)/(Z o)))
<p>
PO1A <- ([ ]* ((P OIb a)/(P UIb a)/(Z OIb a)/(P o Z a)/(P u Z a)/(Z o Z a)))
<p>
PO1E <- ([ ]* ((P OIb e)/(P UIb e)/(Z OIb e)))
<p>
PO1I <- ([ ]* ((P OIb i)/(P UIb i)/(Z OIb i)/(P o Z i)/(P u Z i)/(Z o Z i)))
<p>
PO1O <- ([ ]* ((P OIb o)/(P UIb o)/(Z OIb o)))
<p>
PO1U <- ([ ]* ((P OIb u)/(P UIb u)/(Z OIb u)/(P o Z u)/(P u Z u)/(Z o Z u)))
<p>
<x>abstract predicate constructor from simple predicates
<p>
POSHORT1 <- ([ ]* ((P OI)/(P UI)/(Z OI)))
<p>
<x>word forms associated with the above abstract predicate root forms
<p>
PO <- ([ ]* PO1 )
<p>
POA <- ([ ]* PO1A )
<p>
POE <- ([ ]* PO1E )
<p>
POI <- ([ ]* PO1E )
<p>
POO <- ([ ]* PO1O )
<p>
POU <- ([ ]* PO1U )
<p>
POSHORT <- ([ ]* POSHORT1 )
<p>


<H4> register markers </H4>
<p>
DIE <- ([ ]* ((D IE)/(F IE)/(K AE)/(N UE)/(R IE)) )
<p>
<H4> freemods and freemod builders </H4>
<p>
<x>vocative forms:  I still have the words of social lubrication as 
<x>vocative markers.
<p>
HOI <- ([ ]* ((H OI)/(L OI)/(L OA)/(S IA)/(S IE)/(S IU)) )
<p>
<x>the verbal scare quote.  The quantifier suffix indicates how many preceding words are affected;
<x>this is an odd mechanism.
<p>
JO <- ([ ]* (NI0/RA/SA)? (J o) )
<p>
<x>markers for forming parenthetical utterances as free modifiers.
<p>
KIE <- ([ ]* (K IE) )
<p>
KIU <- ([ ]* (K IU) )
<p>
KIE2 <- [ ]* K IE comma2? [(]
<p>
KIU2 <- [ ]* [)] comma2? K IU
<p>
<x>marker for forming smilies.
<p>
SOI <- ([ ]* (S OI) )
<p>
<x>a grab bag of attitudinal words, including but not restricted to the VV forms.
<p>
UI0 <- (!predstart (!([Ii] juncture? [Ee]) VV juncture?/(B EA)/(B UO)/(C EA)/(C IA)/(C OA)/(D OU)/(F AE)/(F AO)/(F EU)/(G EA)/(K UO)/(K UU)/(R EA)/(N AO)/(N IE)/(P AE)/(P IU)/(S AA)/(S UI)/(T AA)/(T OE)/(V OI)/(Z OU)/((L OI))/((L OA))/((S IA))/(S II)/(T OE)/((S IU))/(C AO)/(C EU)/((S IE))/(S EU)/(S IEb i)))
<p>
<x>negative forms of the attitudinals.  The ones with [no] before the two vowel forms are a phonetic exception.  The others
<x>should also be (though they present no pronunciation problem) so that they are resolved as single words.
<p>
NOUI <- (([ ]* UI0 NOI)/([ ]* N [o] juncture? comma? [ ]* UI0 ))
<p>
<x>all attitudinals (adding the discursives nefi, tofi... etc)
<x>there is a technical problem with mixing UI0 roots of VV and CVV shapes.
<p>
UI1 <- ([ ]* (UI0+/(NI F i)) )
<p>
<x>the inverse vocative marker
<p>
HUE <- ([ ]* (H UE))
<p>
<H4>Negation</H4>

<x>occurrences of [no] as a word rather than an affix.
<p>
NO1 <- ([ ]* !KOU1 !NOUI (N o) !(comma2? Z AO comma2? Predicate) !([ ]* KOU) !([ ]* (JIO/JI/JIZA/JIOZA/JIZI/JIOZI/JIZU/JIOZU)) )
<p>
<H4> gaa, the large subject marker in the alternative parser </H4>

<x>a technical closure for the alternative parser approach:  the "large subject marker"
<p>
GAA <- (NO1 freemod?)* ([ ]* (G AA))
<p>
<H3> The large word classes (names and predicates)</H3>
<x>Names, acronyms and PreNames from above.
<p>
AcronymicName <- Acronym &(comma/period/end)
<p>
DJAN <- (PreName/AcronymicName)
<p>
<x>predicate words which are phonetically cmapua
<p>
<x>"identity predicates".  Converses are provided as a new proposal.
<p>
BI <- ([ ]* (N u)? ((B IA)/(B IE)/(C IE)/(C IO)/(B IA)/(B [i])) )
<p>
<x>interrogative and pronoun predicates
<p>
LWPREDA <- ((H e)/(D UA)/(D UI)/(B UA)/(B UI))
<p>
<x>here I should reinstall the [zao] proposal.
<p>
<x>the predicate words defined above in the phonetics section
<p>
Predicate <- (CmapuaUnit comma2?  Z AO comma2?)* Complex (comma2? Z AO comma2? Predicate)?
<p>
<x>predicate words, other than the "identity predicates" of class [BI]
<x>these include the numerical predicates (NI RA), also cmapua phonetically.
<p>
<x>we are installing John Cowan's [zao] proposal here, experimentally, 4/15/2019
<p>
PREDA <- ([ ]* &caprule (Predicate/LWPREDA/(![ ] NI RA)) )
<p>
<H2>Part 3:  The Grammar Proper</H2>

<H3>Right markers turned into classes</H3>

guoa <- (PAUSE? (GUOA/GU) freemod?)
<p>
guoe <- (PAUSE? (GUOE/GU) freemod?)
<p>
guoi <- (PAUSE? (GUOI/GU) freemod?)
<p>
guoo <- (PAUSE? (GUOO/GU) freemod?)
<p>
guou <- (PAUSE? (GUOU/GU) freemod?)
<p>
guo <- (!guoa !guoe !guoi !guoo !guou (PAUSE? (GUO/GU) freemod?))
<p>
guiza <- (PAUSE? (GUIZA/GU) freemod?)
<p>
guizi <- (PAUSE? (GUIZI/GU) freemod?)
<p>
guizu <- (PAUSE? (GUIZU/GU) freemod?)
<p>
gui <- (PAUSE? (GUI/GU) freemod?)
<p>
gue <- (PAUSE? (GUE/GU) freemod?)
<p>
guea <- (PAUSE? (GUEA/GU) freemod?)
<p>
guu <- (PAUSE? (GUU/GU) freemod?)
<p>
guua <- (PAUSE? (GUUA/GU) freemod?)
<p>
giuo <- (PAUSE? (GIUO/GU) freemod?)
<p>
meu <- (PAUSE? (MEU/GU) freemod?)
<p>
geu <- GEU
<p>
<x>Here note the absence of pause/GU equivalence.
<p>
gap <- (PAUSE? GU freemod?)
<p>

<H3>The vocative and inverse vocative</H3>
<x>this is the vocative construction.  It can appear early because all of its components are marked.
<p>
<x>the intention is to indicate who is being addressed.  This can be handled via a name, a descriptive argument, a predicate or an
<x>alien text name (the last must be quoted).  The complexities of these grammatical constructions can be deferred until they are
<x>introduced.
<p>
<x>HOI0 <- [ ]* [Hh] [Oo] [Ii] juncture?  
<p>
<x>restore words of social lubrication as vocative markers but not as name markers:  [loi, Djan]  
<p>
<x>I do not allow a freemod to intervene between a vocative marker and the associated
<x>utterance, to avoid unintended grabbing of subjects by the words of social lubrication when they are used
<x>as vocative markers.  This lets [Loi, Djan] and [Loi hoi Djan] be equivalent.  The comma needed in the
<x>first because the social lubrication words are in this version not name markers.
<p>    
HOI0 <- ([ ]* ((([Hh] OI)/([Ll] OI)/([Ll] OA)/([Ss] IA)/([Ss] IE)/([Ss] IU)))) juncture? !V1
<p>
voc <- (HOI0 comma2? name /(HOI comma2? descpred guea? namesuffix?)/(HOI comma2? argument1 guua?)/[ ]* &([Hh] [Oo] [Ii] juncture?) AlienWord)
<p>
<x>this is the inverse vocative.  It can appear early because all of its components are marked.
<p>
<x>the intention is to indicate who is speaking.  The range of ways this can be handled is similar to the range of ways it can be
<x>handled for the vocative;  there is the further option of a sentence (the [statement] class) and there is a strong closure option
<x>for the case where an argument is used (to avoid it inadvertantly expanding to a sentence).
<p>
HUE0 <- [ ]* &caprule [Hh] [Uu] juncture? [Ee] juncture? !V1
<p>
invvoc <- (HUE0 comma2? name/HUE freemod? descpred guea? namesuffix?/(HUE freemod? statement giuo?)/(HUE freemod? argument1 guu?)/[ ]* &([Hh] [Uu] juncture? [Ee] juncture?) AlienWord)
<p>
<H3>Free modifiers</H3>
<x>this is the class of free modifiers.  Most of its components are head marked (those that aren't appear just above),
<x>and it is useful for it to appear early because these things appear everywhere in subsequent constructions.  A free modifier,
<x>of whatever sort, is a freely insertable gadget which modifies the immediately preceding construction, or the entire utterance
<x>if it is initial.

<p>

<x>NOUI is a negated attitudinal word.  UI1 is an attitudinal word:  these express an emotional attitude toward the 
<x>assertion (noting that EI marks questions (yes or no answer expected) and SEU marks utterances as answers).
<p>
<x>SOI creates smilies in a general sense:  [soi crano] indicates that the listener should imagine the speaker smiling;
<x>similarly for other predicates.
<p>
<x>DIE and NO DIE are register markers, communicating the social attitude of the speaker toward the one addressed:  [die] for
<x>example is "dear"
<p>
<x>KIE...KIU constructs a full parenthetical utterance as a comment, which can be enclosed in actual parentheses inside
<x>the marker words.
<p>
<x>JO is a scare quote device.
<p>
<x>deletion of a previous word or wordlike unit (or more than one) using K IA
<p>
kiamod <- comma2? !(!PreName !predstart K IA) ((PreName/LIU1/AlienWord/Cmapua ([ ]* (!(K IA)) !PreName !predstart Cmapua)*/Word) kiamod* comma2? !PreName !predstart K IA) comma2?
<p>
<x>the comma is a freemod with no semantic content:  this is a device for discarding phonetically required pauses
<x>and the speaker's optional pauses alike.   The pause before a non-pause marked prename is part of the NameWord and so
<x>is excluded.  Ellipses and dashes are fancy pauses supported as freemods.
<p>
freemod <- ((kiamod/NOUI/(SOI freemod? descpred guea?)/DIE/(NO1 DIE)/(KIE comma? utterance0 comma? KIU)/(KIE2 comma? utterance0 comma? KIU2)/invvoc/voc/(comma !(!FalseMarked PreName))/JO/UI1/([ ]* '...' ([ ]* &letter)?)/([ ]* '--' ([ ]* &letter)?)) freemod?)
<p>
<H3>Tightly bound arguments and lists thereof</H3>

<x>the classes juelink to linkargs describe very tightly bound arguments which can be firmly attached to predicates in 
<x>the context of metaphorical modifications and the use of predicates in descriptive arguments.
<p>
<x>note that we allow predicate modifiers (prepositional phrases) to be bound with [je/jue] which is not
<x>allowed in 1989 Loglan, but which we believe is supported in Lojban.
<p>
juelink <- (JUE freemod? (term/(PA2 freemod? gap?)))
<p>
links1 <- (juelink (freemod? juelink)* gue?)
<p>
links <- ((links1/(KA freemod? links freemod? KI freemod? links1)) (freemod? A1 freemod? links1)*)
<p>
jelink <- (JE freemod? (term/(PA2 freemod? gap?)))
<p>
linkargs1 <- (jelink freemod? (links/gue)?)
<p>
linkargs <- ((linkargs1/(KA freemod? linkargs freemod? KI freemod? linkargs1)) (freemod? A1 freemod? linkargs1)*)
<p>

<H3>Abstract argument constructions</H3>
<x>class abstractpred supports the construction of event, property, and quantity predicates from sentences.  These are
<x>closable with [guo] if introduced with [po,pu,zo] and closable with suffixed variants of [guo] if introduced with suffixed
<x>variants of [po,pu,zo] (a NEW idea but it is clear that closure of these predicates (and of the more commonly
<x>used associated descriptions) is an important issue).

abstractpred <- ((POA freemod? uttAx guoa?)/(POA freemod? sentence guoa?)/(POE freemod? uttAx guoe?)/(POE freemod? sentence guoe?)/(POI freemod? uttAx guoi?)/(POI freemod? sentence guoi?)/(POO freemod? uttAx guoo?)/(POO freemod? sentence guoo?)/(POU freemod? uttAx guou?)/(POU freemod? sentence guou?)/(PO freemod? uttAx guo?)/(PO freemod? sentence guo?))
<H3>Atomic predicates (predunit)</H3>
<x>predunit1 describes the truly atomic forms of predicate.
<p>
<x>PREDA is the class of predicate words (the phonetic predicate words along with the special phonetic cmapua which are predicates, listed
<x>above under the PREDA rule.  NU PREDA handles permutations and identifications of arguments of PREDAs.
<p>
<x>SUE contains the alien text constructions with [sao] and [sue], semantically quite different but syntactically handled
<x>in the same way.
<p>
<x>[ge]...[geu/cue] (the closing optional) can parenthesize a fairly complex predicate phrase and turn it into an atomic form.  These
<x>forms can have conversion or reflexive operators (NU) applied.  I should look into why the class handled in the conversion case
<x>is different.  An important use of this is in metaphor constructions, but it has other potential uses.
<p>
<x>abstractpred is the class of abstraction predicates just introduced above.  These are treated as atomic in this grammar:  it should
<x>be noted that their privileges in the trial.85 grammar are (absurdly) limited.
<p>
<x>[me]...[meu] (the closing optional, but important to have available) forms predicates from arguments, the predicate being true of the
<x>objects to which the argument refers.  [Ti me le mrenu] :  this is one of the men we are talking about.
<p>
predunit1 <- ((SUE/(NU freemod? GE freemod? despredE (freemod? geu comma?)?)/(NU freemod? PREDA)/(comma? GE freemod? descpred (freemod? geu comma?)?)/abstractpred/(ME freemod? argument1 meu?)/PREDA) freemod?)
<p>
<x>[no] binds very tightly to predunit1:  a possibly multiply negated predunit1 (or an unadorned predunit1) is a predunit2.
<p>
predunit2 <- ((NO1 freemod?)* predunit1)
<p>

<x>an instance of NO2 is one not absorbed by a predunit.  Example:  [Da no kukra prano]  X is a slow (not-fast) runner vs
<x>[Da no ga kukra prano]  (X is not a fast runner, and in fact may not run at all).
<p>
NO2 <- (!predunit2 NO1)
<p>
<x>a predunit3 is a predunit2 with tightly attached arguments.
<p>
predunit3 <- ((predunit2 freemod? linkargs)/predunit2)
<p>
<x>a predunit is a predunit3 or a predunit3 converted by the short-scope abstraction operators
<x>[poi/pui/zoi] to an abstraction predicate.  This is the kind of predicate which can appear as
<x>a component in a serial name.
<p>
predunit <- ((POSHORT freemod?)? predunit3)
<p>
<x>a further "atomic" (because tightly packaged) form is a forethought connected pair
<x>of predicates (this being the full predicate class defined at the end of the process)
<x>possibly closed with [guu], possibly multiply negated as well.
<p>
<x>the closure with guu eliminated the historic rule against kekked heads of metaphors.
<p>
kekpredunit <- ((NO1 freemod?)* KA freemod? predicate freemod? KI freemod? predicate guu?)
<p>

<H4>The construction of metaphors</H4>
<x>there follows the construction of metaphorically modified predicates, 
<x>along with tightly logically linked predicates.

<p>

<x>CI and simple juxtaposition of predicates both represent modification of the second
<x>predicate by the first.  We impose no semantic conditions on this modification,
<x>except in the case of modification by predicates logically linked with CA,
<x>which do distribute logically in the expected way both as modifiers and as modified.
<x>We do not regard [preda1 preda2] as necessarily implying preda2:  we do regard
<x>it as having the same place structure as preda2.  It is very often but not always
<x>a qualification or kind of preda2;  in any case it is a relation analogous to preda2.

<p>

<x>modification with CI binds most tightly.

<p>

<x>we eliminated the distinction between the series of sentence and description
<x>predicate preliminary classes:  there seems to be no need for it even in the 
<x>trial.85 grammar.

<p>

despredA <- ((predunit/kekpredunit) (freemod? CI freemod? (predunit/kekpredunit))*)

<p>

<x>this is logical connection of predicates with the tightly binding CA
<x>series of logical connectives.  CUI can be used to expand the scope of
<x>a CA connective over a metaphor on the left.  [ge]...[geu] is used to expand
<x>scope on the right (and could also be used on the left, it should be noted).
<x>descpredC is an internal of despredB assisting the function of CUI.
<x>the !PREDA in front of CUI is probably not needed.

<p>

despredB <- ((!PREDA CUI freemod? despredC freemod? CA freemod? despredB)/despredA)
<p>
despredC <- (despredB (freemod? despredB)*)
<p>
<x>tight logical linkage of despredB's

<p>

despredD <- (despredB (freemod? CA freemod? despredB)*)

<p>

<x>chain of modifications of despredD's (grouping to the left)

<p>

despredE <- (despredD (freemod? despredD)*)

<p>

<x>the GO construction allows inverse modification:  [preda1 GO preda2] is [preda2 preda1] as it were.
<x> there are profound effects on grouping.

<p>

descpred <- ((despredE freemod? GO freemod? descpred)/despredE)

<p>

<x>this version which appears in sentence predicates as opposed to descriptions differs
<x>in allowing loosely linked arguments (termsets) instead of those linked with [je/jue] for the predicate
<x>moved to the end by GO.

<p>

sentpred <- ((despredE freemod? GO freemod? barepred)/despredE)

<p>

<H3>Construction of sentence modifiers</H3>

<x>the construction of predicate modifiers (prepositional phrases usable as terms along with arguments).

<p>

mod1a <- (PA3 freemod? argument1 guua?)

<p>

<x>note special treatment of predicate modifiers without actual arguments.
<x>the !barepred serves to distinguish these predicate modifiers from actual
<x>"tenses" (predicate markers).

<p>

mod1 <- ((PA3 freemod? argument1 guua?)/(PA2 freemod? !barepred gap?))

<p>

<x>forethought connection of modifiers.  There is some subtlety in
<x>how this is handled.

<p>

kekmod <- ((NO1 freemod?)* (KA freemod? modifier freemod? KI freemod? mod))

<p>

mod <- (mod1/((NO1 freemod?)* mod1)/kekmod)

<p>

<x>afterthought connection of modifiers

<p>

modifier <- (mod (A1 freemod? mod)*)

<p>

<H3>Serial names (a flash point)</H3>

<x>the serial name is a horrid heterogenous construction!  It can involve
<x>components of all three of the major phonetic classes essentially!

<x>However, I believe I have the definition right, with all the components
<x>correctly guarded :-)

<p>

name <- (PreName/AcronymicName) (comma2? !FalseMarked PreName/comma2? &([Cc] [Ii]) NameWord/comma2? CI predunit !(comma2? (!FalseMarked PreName))/comma2? CI AcronymicName)* freemod? 

<p>

LA0 <- [ ]* [Ll] [Aa] juncture?  

<p>

LANAME <- (LA0 comma2? name)

<p>

<H3>General construction of descriptive arguments</H3>

<x>general constructions of arguments with "articles".

<p>

<x>the rules here have the "possessive" construction as in [lemi hasfa; le la Djan, hasfa] embedded.  These are not the same
<x>construction in 1989 Loglan, though speakers might think they are.  Here they are indeed the same.  The "possessor" cannot
<x>be "indefinite" (cannot start with a quantifier word);  the possessor can be followed by a tense, as in 
<x>[le la Djan, na hasfa], "John's present house", by analogy with [lemina hasfa], which is accepted by LIP (because
<x>LIP accepts [lemina] as a word).

<p>

<x>there are other subtleties to be reviewed.

<p>

descriptn <- (!LANAME ((LAU wordset1)/(LOU wordset2)/(LE freemod? ((!mex arg1a freemod?)? (PA2 freemod?)?)? (mex freemod? arg1a/mex freemod? descpred/descpred))/(GE freemod? mex freemod? descpred)))

<p>

<x>abstract descriptions.  Note that abstract descriptions are closed with [guo] entirely independently of abstract predicates:
<x>[le po preda guo] does not have a grammatical component [po preda guo].  This avoids the double closure often apparently necessary
<x>in Lojban.

<p>

abstractn <- ((LEFORPO freemod? POA freemod? uttAx guoa?)/(LEFORPO freemod? POA freemod? sentence guoa?)/(LEFORPO freemod? POE freemod? uttAx guoe?)/(LEFORPO freemod? POE freemod? sentence guoe?)/(LEFORPO freemod? POI freemod? uttAx guoi?)/(LEFORPO freemod? POI freemod? sentence guoi?)/(LEFORPO freemod? POO freemod? uttAx guoo?)/(LEFORPO freemod? POO freemod? sentence guoo?)/(LEFORPO freemod? POU freemod? uttAx guou?)/(LEFORPO freemod? POU freemod? sentence guou?)/(LEFORPO freemod? PO freemod? uttAx guo?)/(LEFORPO freemod? PO freemod? sentence guo?))

<p>

<x>a wider class of basic argument constructions.  Notice that LANAME is always read by preference to descriptn.

<p>

namesuffix <- (&(comma2 !FalseMarked PreName/[ ]* [Cc][Ii] juncture? comma2? (PreName/AcronymicName)) ([ ]* [Cc][Ii] juncture? comma2?/comma2)? name)

<p>

arg1 <- (abstractn/(LIO freemod? descpred guea?)/(LIO freemod? argument1 guua?)/(LIO freemod? mex gap?)/LIO1/LAO/LANAME/(descriptn guua? namesuffix?)/LIU1/LIE/LI)

<p>

<x>this adds pronouns (incl. the fancy [gao] letterals) and the option of left marking an argument with [ge]
<p>
arg1a <- ((DA/TAI/arg1/(GE freemod? arg1a)) freemod?)

<p>

<H4>Argument modifiers (subordinate clauses)</H4>

argmod1 <- ((([ ]* (N o) [ ]*)? ((JI freemod? predicate)/(JIO freemod? sentence)/(JIO freemod? uttAx)/(JI freemod? modifier)/(JI freemod? argument1)))/(([ ]* (N o) [ ]*)? (((JIZA freemod? predicate) guiza?)/((JIOZA freemod? sentence) guiza?)/((JIOZA freemod? uttAx) guiza?)/((JIZA freemod? modifier) guiza?)/(JIZA freemod? argument1 guiza?)))/(([ ]* (N o) [ ]*)? ((JIZI freemod? predicate guizi?)/(JIOZI freemod? sentence guizi?)/(JIOZI freemod? uttAx guizi?)/(JIZI freemod? modifier guizi?)/(JIZI freemod? argument1 guizi?)))/(([ ]* (N o) [ ]*)? ((JIZU freemod? predicate guizu?)/(JIOZU freemod? sentence guizu?)/(JIOZU freemod? uttAx guizu?)/(JIZU freemod? modifier guizu?)/(JIZU freemod? argument1 guizu?))))
<p>
<x>we improved the trial.85 grammar by closing not argmod1 but argmod with [gui].  But the labelled argument modifier constructors
<x>when building an argmod1 have the argmod1 construction closed with the corresponding labelled right marker, of course.  Thus
<x>gui and guiza actually have different grammar.
<p>
<x>trial.85 did not provide forethought connected argument modifiers, and we also see no need for them,
<x>though they could readily be added.
<p>
argmod <- (argmod1 (A1 freemod? argmod1)* gui?)

<p>

<H4>Arguments resume</H4>

<x>affix argument modifiers to a definite argument

<p>

arg2 <- (arg1a freemod? argmod*)

<p>

<x>build a possibly indefinite argument from an argument:  to le mrenu

<p>

arg3 <- (arg2/(mex freemod? arg2))

<p>

<x>build an indefinite argument from a predicate

<p>

indef1 <- (mex freemod? descpred)

<x>affix an argument modifier to an indefinite argument

<p>

indef2 <- (indef1 guua? argmod*)

<p>

indefinite <- indef2

<p>

<x>link arguments with the fusion connective [ze]

<p>

arg4 <- ((arg3/indefinite) (ZE2 freemod? (arg3/indefinite))*)

<p>

<x>forethought connection of arguments.  Note use of argx

<p>

arg5 <- (arg4/(KA freemod? argument1 freemod? KI freemod? argx))

<p>

<x>arguments with possible negations followed by possible indirect reference constructions.

<p>

argx <- ((NO1 freemod?)* (LAE freemod?)* arg5)

<p>

<x>afterthought connection with the tightly binding ACI connectives

<p>

arg7 <- (argx freemod? (ACI freemod? argx)?)

<p>

<x>afterthought connection with the usual A connectives.  Can't start with GE
<x>to avoid an ambiguity (to which 1989 Loglan is vulnerable) involving AGE connectives.

<p>

arg8 <- (!GE (arg7 freemod? (A1 freemod? arg7)*))

<p>

<x>afterthought connection (now right grouping, instead of the left grouping above)
<x>using the AGE connectives.  GUU can be used to affix an argument modifier at this top level.

<p>

argument1 <- (((arg8 freemod? AGE freemod? argument1)/arg8) (GUU freemod? argmod)*)

<p>

<x>possibly negated and case tagged arguments.  We (unlike 1989 Loglan) are careful
<x>to use argument only where case tags are appropriate.

<p>

argument <- ((NO1 freemod?)* (DIO freemod?)* argument1)

<p>

<x>an argument which is actually case tagged.

<p>

argxx <- (&((NO1 freemod?)* DIO) argument)

<p>

<H3>Term lists</H3>

<x>arguments and predicate modifiers actually associated with predicates.

term <- (argument/modifier)

<p>

<x>a term list consisting entirely of modifiers.

<p>

modifiers <- (modifier (freemod? modifier)*)

<p>

<x>a term list consisting entirely of modifiers and tagged arguments.

<p>

modifiersx <- ((modifier/argxx) (freemod? (modifier/argxx))*)

<p>

<x>the subject class is a list of terms (arguments and predicate modifiers) in which all but possibly one
<x>of the arguments are tagged, and there is at least one argument, tagged or otherwise.

<p>

subject <- ((modifiers freemod?)? ((argxx subject)/(argument (modifiersx freemod?)?)))

<p>

<x>this case is identified as an aid to experimental termination of argument lists

statement1 <- (subject freemod? (GIO freemod? terms1)? predicate)

<p>

<x>change this to something you wont encounter to turn off the alternative parser or to statement1 to turn it on

<p>

statement1x <- 'xxx'

<p>

<x>these classes are exactly argument, but are used to signal
<x>which argument position after the predicate an argument occupies.
<x>I think the grammar is set up so that these will actually
<x>never be case tagged, though the grammar does not expressly forbid it.

<p>

<x>I am trying a simple version of the "alternative parser" approach:
<x>a term list will refuse to digest an argument which starts a new
<x>SVO sentence (statement1).

<p>

argumentA <- !statement1x argument 

<p>

<x>argumentA <- argument

<p>

argumentB <- !statement1x argument 

<p>

<x> argumentB <- argument

<p>

argumentC <- !statement1x argument 

<p>

<x> argumentC <- argument

<p>

argumentD <- !statement1x argument 

<p>

<x> argumentD <- argument

<p>

<x>for argument lists not guarded against absorbing a following subject

<p>

argumentA1 <- argument

<p>

argumentB1 <- argument

<p>

argumentC1 <- argument

<p>

argumentD1 <- argument

<p>

<x>a general term list.  It cannot contain more than four untagged arguments (they will be labelled
<x>with the lettered subclasses given above).

<p>

terms <- ((modifiersx? argumentA (freemod? modifiersx)? argumentB? (freemod? modifiersx)? argumentC? (freemod? modifiersx)? argumentD?)/modifiersx)

<p>

<x>terms list not guarded against absorbing a following subject

<p>

terms1 <- ((modifiersx? argumentA1 (freemod? modifiersx)? argumentB1? (freemod? modifiersx)? argumentC1? (freemod? modifiersx)? argumentD1?)/modifiersx)

<p>

<x>innards of ordered and unordered list constructions.  These are something I totally rebuilt, as they were in a totally
<x>unsatisfactory state in trial.85.  Note the use of comma words to separate items in lists.
<p>
word <- (arg1a/indef2)
<p>

words1 <- (word (ZEIA? word)*)
<p>
words2 <- (word (ZEIO? word)*)
<p>
wordset1 <- (words1? LUA)

<p>

wordset2 <- (words2? LUO)

<p>

<x>the full term set type to be affixed to predicates.

<p>

<x>forethought connection of term lists

<p>

termset1 <- (terms/(KA freemod? termset2 freemod? guu? KI freemod? termset1))

<p>

<x>afterthought connection of term lists.  There are cunning things going on here getting [guu]
<x>to work correctly.  Note that [guu] is NOT a null term list as it was in trial.85.

<p>

termset2 <- (termset1 (guu &A1)? (A1 freemod? termset1 (guu &A1)?)*)

<p>

<x>there is an interesting option here of a list of terms followed by [go] followed by a predicate
<x>intended to metaphorically modify the predicate to which the terms are affixed.  Is there a reason
<x>why we cannot have a more complex construction in place of terms?

<p>

termset <- ((terms freemod? GO freemod? barepred)/termset2)

<p>

<H3>The general verb phrase construction</H3>

<x>this is the untensed predicate with arguments attached.  Here is the principal locus
<x>of closure with [guu], but it is deceptive to say that [guu] merely closes barepred,
<x>as we have seen above, for example in [termset2].

<p>

barepred <- (sentpred freemod? ((termset guu?)/(guu (&termset)))?)

<p>

<x>tensed predicates
<p>
markpred <- (PA1 freemod? barepred)
<p>
<x>there follows an area in which my grammar looks different from trial.85.  Distinct parallel forms for
<x>marked and unmarked predicates are demonstrably not needed even in trial.85.  The behavior of the ACI
<x>connectives is plain weird in trial.85; here we treat ACI connectives in the same way as A connectives, but
<x>binding more tightly.
<p>
<x>units for the ACI construction following -- possibly multiply negated bare or marked predicates.
<p>
<x>adding shared termsets to logically connected predicates are handled differently here than in trial.85,
<x>which uses a very elegant but dreadfully left-grouping rule which a PEG cannot handle.  Any realistic situation
<x>should be manageable.
<p>
backpred1 <- ((NO2 freemod?)* (barepred/markpred))
<p>

<x>ACI connected predicates.  Shared termsets are added.  Notice how we first group backpred1's then recursively
<x>group backpreds.
<p>
backpred <- (((backpred1 (ACI freemod? backpred1)+ freemod? ((termset guu?)/(guu &termset))?) ((ACI freemod? backpred)+ freemod? ((termset guu?)/(guu &termset))?)?)/backpred1)
<p>
<x>A connected predicates; same comments as just above.  Cannot start with GE to fix ambiguity with AGE connectives.
<p>
predicate2 <- (!GE (((backpred (A1 !GE freemod? backpred)+ freemod? ((termset guu?)/(guu &termset))?) ((A1 freemod? predicate2)+ freemod? ((termset guu?)/(guu &termset))?)?)/backpred))
<p>
<x>predicate2's linked with right grouping AGE connectives (A and ACI are left grouping).
<p>
predicate1 <- ((predicate2 AGE freemod? predicate1)/predicate2)
<p>
<x>identity predicates from above, possibly negated
<p>
identpred <- ((NO1 freemod?)* (BI freemod? argument1 guu?))
<p>
<x>predicates in general.  Note that identity predicates cannot be logically connected
<x>except by using forethought connection (see above).
<p>
predicate <- (predicate1/identpred)
<p>

<H3>The sentence</H3>

<x>The gasent is a basic form of the Loglan sentence in which the predicate leads.
<x>The basic structure is [PA word (usually a tense) or [ga]) followed optionally by terms followed optionally by
<x>[ga] followed by terms.  The list of terms after [ga] (if present) will either contain 
<x>at least one argument and no more than one untagged argument
<x>(a subject) [gasent1] or all the arguments of the predicate [gasent2].  We deprecate other arrangements possible in
<x>1989 Loglan because they would cause unexpected reorientation of the arguments already given before [ga] as second
<x>and further arguments were read after [ga].  [barepred] is an untensed predicate possibly with arguments; [sentpred]
<x>is "simply a verb", i.e., a predicate without arguments.
<p>
<x>there is a semantic change from 1989 Loglan reflected in a grammar change here:
<x>in [gasent1] the final (ga subject) is optional.  When it does not appear, the resulting
<x>sentence is an observative (a sentence with subject omitted), not an imperative.
<x>Imperatives for us are unmarked.
<p>
<x>In the alternative version, the use of the large subject marker GAA can prevent inadvertant absorption of a preceding trailing argument into a statement
<p>
<x>4/22 allowing general predicates in gasent.  Otherwise the spaces of observatives and imperatives become quite confused.
<p>

gasent1 <- ((NO1 freemod?)* (GAA? freemod? &markpred predicate (GA2 freemod? subject)?))

<p>

gasent2 <- ((NO1 freemod?)* (GAA? PA1 freemod? sentpred modifiers? (GA2 freemod? subject freemod? GIO? freemod? terms?)))

<p>

gasent <- (gasent2/gasent1)

<p>

<x>this is the simple Loglan sentence in various basic orders.  The form "gasent" is discoussed just above.  
<x>Predicate modifiers
<x>can be prefixed to the gasent.  The final form given here is the basic SVO sentence.  The "subject" class is a list of terms
#(arguments and predicate modifiers) containing at most one un-case-tagged argument.  The most general SVO form is subject, followed optionally
#by [gio] followed by a list of terms (1989 Loglan allowed more than one untagged argument before the predicate, but this leads to practical problems
#in which preceding constructions with errors in them may supply extra unintended arguments.  It should be noted in NB3 that JCB envisioned
#a single argument before the predicate, followed by the predicate, which may itself contain further arguments.  A gasent nay optionally be negated
#(even multiple times).

<p>

<x>re [gio] and some other changes, in his comments on the NB3 grammar  JCB often notes restrictions on appearances of term lists which he
<x>intends but which he thought were hard to implement in the machine grammar.  The appearance of just one argument before the "verb"
<x>in an SVO sentence was one of these (though later he takes it as a virtue that the actual machine grammar supports SOV:  we did not
<x>consider it a virtue to have unmarked SOV after observing unintended parses appearing in the Visit text).  Another example of this
<x>(which would not have been hard for JCB to implement, in fact) is our restriction of the form "terms gasent" to "modifiers gasent".
<x>His comments make it clear that he does not want arguments among those terms.
<p>
# statement <- (gasent/(modifiers freemod? gasent)/(subject freemod? GAA? freemod? (GIO freemod? terms1)? predicate))
<p>
statement <- (gasent/(modifiers freemod? gasent)/(subject freemod? GAA? freemod? (GIO? freemod? terms1)? predicate))
<p>
<x>this is a forethought connected basic sentence.  It is odd (and actual odd results can be exhibited) that the final segment in both
<x>of these rules is of the very general class uttA1, which includes some quite fragmentary utterances usually intended as answers.
<p>
<x>12/20/2017 I rewrote the rule in a more compact form.  This rule looks ahead to the class [sentence] which we now develop;
<x>for the moment notice that [sentence] will include [statement].
<p>
<x>4/14 tentatively allowing initial modifiers here and leaving this out of uttA0 which replaces uttA1 below.
<x>The intention is to eliminate weird sentence fragments.
<p>
keksent <- modifiers? freemod? (NO1 freemod?)* (KA freemod? headterms? freemod? sentence freemod? KI freemod? uttA0)
<p>
<x>sentence negation.  We allow this to be set off from the main sentence with a mere pause, because generally
<x>it does not differ in meaning from the result of negating the first argument or predicate modifier.
<p>
neghead <- ((NO1 freemod? gap)/(NO2 PAUSE))

<p>

<x>this class includes [statement], predicate modifiers preceding a predicate (which may contain arguments), a statement,
<x>a predicate, and a keksent.  Of these, the first and third are imperatives.
<p>
<x>in the alternative version, the large subject marker GAA can prevent inadvertant absorption of preceding trailing arguments into a statement
<p>
<x>4/23/2019 added actual rule for imperative sentences.  This should not
<x>affect the parse in any essential way.
<p>
imperative <- ((modifiers freemod?)? GAA? !gasent predicate)
<p>
sen1 <- (neghead freemod?)* (imperative/statement/keksent)
<p>
<x>sen1 <- ((neghead freemod?)* ((modifiers freemod? GAA? !gasent predicate)/statement/GAA? predicate/keksent))
<p>
<x>the class [sentence] consists of sen1's afterthought connected with A connectives
<p>
sentence <- (sen1 ([!.:;?]? ICA freemod? sen1)*)
<p>
<x>[headterms] is a list of terms (arguments and predicate modifiers) ending in [gi].  Preceding a [sen1] with these
<x>causes all predicates in the [sen1] to share these arguments.  We propose either that the headterms arguments be directly
<x>appended to the argument list of each component of the [sen1], or that there is an argument with a numbered case tag at the beginning
<x>of the headterms list, and the list is inserted at the appropriate position in each component sentence.  Neither of these is
<x>the condition described in Loglan I, which presupposes that we always know what the last argument of each predicate used is.
<p>
headterms <- (terms GI)+
<p>
<x>this is the previous class prefixed with a list of fronted terms.
<x>we think the [giuo] closure might prove useful.
<p>
uttAx <- (headterms freemod? sentence giuo?)
<p>

<H3>Utterances</H3>
<x>weird answer fragments
<p>
uttA <- ((A1/mex) freemod?)
<p>
<x>a broad class of utterances, including various things one would usually only say as answers.  Notice
<x>that this utterance class can take terminal punctuation.
<p>
uttA0 <- sen1/uttAx
<p>
uttA1 <- ((sen1/uttAx/links/linkargs/argmod/(modifiers freemod? keksent)/terms/uttA/NO1) freemod? period?)
<p>
<x>possibly negated utterances of the previous class.
<p>
uttC <- ((neghead freemod? uttC)/uttA1)
<p>
<x>utterances linked with more tightly binding ICI sentence connectives.  Single sentences are of this class
<x>if not linked with ICI or ICA.
<p>
uttD <- ((sentence period? !ICI !ICA)/(uttC (ICI freemod? uttD)*))
<p>
<x>utterances of the previous class linked with ICA.  I went to some trouble to ensure that a freestanding
<x>[sentence] is actually parsed as a sentence, not a composite uttD, which was a deficiency, if not an ambiguity of
<x>LIP and of the trial.85 grammar.
<p>
uttE <- (uttD (ICA freemod? uttD)*)
<p>
<x>utterances of the previous class linked with I sentence connectives.
<p>
uttF <- (uttE (I freemod? uttE)*)
<p>
<x>the utterance class for use in the context of parenthetical freemods or quotations, in which it does not go to end of text.
<p>
utterance0 <- (!GE ((ICA freemod? uttF)/(!PAUSE freemod period? utterance0)/(!PAUSE freemod period?)/(uttF IGE utterance0)/uttF/(I freemod? uttF?)/(I freemod? period?)) (&I utterance0)?)
<p>
<x>Notice that there are two passes here:  the parser first checks that the entire utterance
<x>is phonetically valid, then returns and checks for grammatical validity.
<p>
<x>the full utterance class.  This goes to end of text, and incorporates the phonetics check.  This incorporates the only situations
<x>in which a freemod is initial.   The IGE connectives bind even more loosely than the I connectives and right-group instead of 
<x>left grouping.
<p>
utterance <- &(phoneticutterance !.) (!GE ((ICA freemod? uttF (&I utterance)? end)/(!PAUSE freemod period? utterance)/(!PAUSE freemod period? (&I utterance)? end)/(uttF IGE utterance)/(I freemod? period? (&I utterance)? end)/(uttF (&I utterance)? end)/(I freemod? uttF (&I utterance)? end)))

</TT>
