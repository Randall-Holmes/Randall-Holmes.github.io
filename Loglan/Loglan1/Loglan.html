<H1>The Parsing Expression Grammar (PEG) for Loglan</H1>

This is the source for the PEG Loglan parser.<p>

NOTE (8/5/17):  the additional openers and closers for subordinate clauses (JIZA/GUIZA and kin) are enabled in both parser versions.<p>

(5/22):  the PEG this is built on (afresh) is that for the "alternative" parser.  Differences between
the alternative and the official parser are pointed out as necessary.  The "alternative" version works better
in parsing legacy Loglan text, because it handles fronted modifiers for which the ancients relied on pause/GU equivalence correctly (without needing any pauses).<p>

<H2> PEG notation </H2>

A PEG (Parsing Expression Grammar) is made up of lines of the form

<TT> class_name <- PEG  notation</TT>

Each PEG notation describes a set of strings with conditions on the context in which they occur.<p>

Concrete strings: <TT>'string'</TT> or <TT>"string"</TT> literally denotes the 6 character string given.<p>

Classes of characters: <TT>[aeiou]</TT> describes the set of one character strings which are either
a, e, i, o, or u.  Ranges can appear: <TT>[a-zA-z]</TT> describes the union of the sets of lower case letters and upper case letters, considered as one character strings.<p>

If <TT>A</TT> and <TT>B</TT> are PEG notations, <TT>(A B)</TT> denotes a string of class <TT>A</TT> followed by a string of class <TT>B</TT> (in which the string of class <TT>A</TT> is the preferred string of this class read from the beginning of the source string).<p>

If <TT>A</TT> and <TT>B</TT> are PEG notations, <TT>(A / B)</TT> denotes a string of either class <TT>A</TT> or a string of class <TT>B</TT>, with a string of class <TT>A</TT> being read by preference if possible.  The fact that a preference is indicated in alternative lists makes PEG reading deterministic (in a sense, there are no ambiguities for a PEG grammar).  The problem corresponding to ambiguity in a BNF  grammar is incorrectly ordered lists of alternatives.<p>

If <TT>A</TT> is a PEG notation, <TT>(A)?</TT> represents a string of class <TT>A</TT> (preferred) or an empty string if there is no string of class <TT>A</TT>:  this represents optional appearance of <TT>A</TT>.  <TT>(A)*</TT> represents zero or more consecutive strings of class <TT>A</TT> (as many as possible) and <TT>(A)+</TT> represents one or more consecutive such strings.<p>

If <TT>A</TT> is a PEG notation, <TT>&(A)</TT> represents a length 0 string which is followed by a string of class <TT>A</TT>, and <TT>!(A)</TT> represents a length 0 string which is <B>not</B> followed by a string of class <TT>A</TT>.  This gives us powerful lookahead features:  for example, <TT>((A)! B</TT> represents a string of class <TT>B</TT> whose beginning is not also the beginning of a string of class
<TT>A</TT>:  it is tempting but not accurate to say that it does not have an initial segment of class <TT>A</TT>, because detection of a string of class <TT>A</TT> longer than the string of class <TT>B</TT> read would cause reading of this class to fail.<p>

The period . represents the class of single characters (so !. is end of text).<p>

New notations are introduced by lines <p>

<TT> class_name <- PEG  notation</TT>:<p>

this is not just an abbreviation facility because such definitions may be mutually recursive.<p>

A PEG notation applied to a source string will give either failure or a uniquely determined initial string of the source (parsed suitably); in a sense PEG is unambiguous.  What corresponds as an issue to ambiguity for a BNF grammar is
inappropriate choice of order of alternatives in PEG disjunctions <TT>(A / B)</TT>:  what often represents a problem with a grammar is what I call "preemption", where an earlier alternative reads an initial segment of a string where a later alternative could have read more of it.<p>

It's possible to have a PEG go into an infinite loop and fail to produce a parse.  My PEG generator has a termination checker, so the Loglan grammar does not have these problems.  I have contemplated writing a preemption checker, but this is a rather difficult problem.<p>

<H2>Phonology</H2>

<H3>Letters and symbols</H3>

Letters (excluding q,w,x).<p>


<TT>
lowercase <- (!([qwx]) [a-z])</TT><P>
<TT>
uppercase <- (!([QWX]) [A-Z])</TT><P>
<TT>
letter <- (!([QWXqwx]) [A-Za-z])</TT><P>

Syllable breaks and stress markers.<p>

<TT>
juncture <- (([-] &(letter)) / ([\'*] !(juncture)))</TT><P>
<TT>
stress <- ([\'*] !(juncture))</TT><P>

The form of <TT>juncture2</TT> enforces the rule that one must pause after a stressed cmapua syllable before a consonant-initial predicate.  What happens is that the hyphen or stress marker cannot be followed immediately by a consonant-initial predicate, but it can be followed by an explicit comma pause (in this case parsed as part of the juncture!) which is followed by a consonant-initial predicate.  A pause is required before a vowel-initial predicate as well, but it does not have to be explicitly comma-marked (as a pause is obligatory before any vowel-initial word in any case).<p>


<TT>
juncture2 <- ((([-] &(letter)) / ([\'*] !((([ ])* &(C1) Predicate)) ((', ' ([ ])* &(C1) &(Predicate)))?)) !(juncture))</TT><P>

These are classes of characters which can appear in words (letters and junctures); the first
one excludes uppercase letters (except that it allows upper case letters after junctures, a subtle implementation of the capitalization rule).<p>

<TT>
Lowercase <- (lowercase / (juncture (letter)?))</TT><P>
<TT>
Letter <- (letter / juncture)</TT><P>

Pauses.  The first is the ordinary explicit pause.  The second is an internal pause allowed inside certain kinds of "words"; it may be expressed as a space or a comma pause, and the capitalization rule propagates through it.<p>

<TT>
comma <- ([,] ([ ])+ &(letter))</TT><P>
<TT>
comma2 <- (([,])? ([ ])+ &(letter) &(caprule))</TT><P>

End of utterance.  This includes the possibility of # followed by an entire new utterance.<p>


<TT>
end <- ((([ ])* '#' ([ ])+ utterance) / (([ ])+ !(.)) / !(.))</TT><P>

Terminal punctuation.  This may include an inverse vocative.<p>


<TT>
period <- (([!.:;?] (&(end) / (([ ])+ &(letter)))) ((invvoc (period)?))?)</TT><P>

<H3>Classification and sequencing of sounds</H3>

Vowels regular and irregular.<p>


<TT>
V1 <- [AEIOUYaeiouy]</TT><P>

Regular vowels.<p>


<TT>
V2 <- [AEIOUaeiou]</TT><P>

Consonants.<p>


<TT>
C1 <- (!(V1) letter)</TT><P>

Pairs of vowels which can be monosyllables.<p>


<TT>
Mono <- (([Aa] [o]) / ((V2 [i]) !([i])) / ([Ii] !([i]) V2) / ([Uu] V2))</TT><P>


Pairs of vowels which must be monosyllables -- note that these are not followed by instances of their final vowel, when the final vowel is <B>i</B>.  <B>ao-o</B> and <B>ao-u</B> are allowed, but for example <B>aii</B> breaks down <B>a-ii</B>.<p>


<TT>
EMono <- (([Aa] [o]) / (([AEOaeo] [i]) !([i])))</TT><P>

This is the rule which chooses the next vowel segment from a stream of vowels.<p>


<TT>
NextVowels <- (EMono / (V2 &(EMono)) / Mono / V2)</TT><P>

This is an obligatory monosyllable broken by a juncture (hyphen or stress marker).<p>

<TT>
BrokenMono <- (([a] juncture [o]) / ([aeo] juncture [i]))</TT><P>

This is a CVV single syllable.<p>

<TT>
CVVSyll <- (C1 Mono)</TT><P>

This is a phonetic component of a cmapua (other than VV components, which do not occur with these):  CvvV, CVV, and CV units.  Notice that the CVV units may be explicitly disyllables, but may not contain an obligatory monosyllable broken with a juncture.<p>

Cvv-V units did not exist in 1989 Loglan but were described as a possibility in the Notebook 3 description of compound cmapua, though they did occur accidentally in acronyms as a side effect of VCV letterals.<p>


<TT>
LWunit <- (((CVVSyll (juncture)? V2) / (C1 !(BrokenMono) V2 (juncture)? V2) / (C1 V2)) (juncture2)?)</TT><P>

This expresses the Loglan capitalization rule.  Only the first of a string of characters satisfying this rule can be capitalized, with certain exceptions:  a TAI0 letteral word may be capitalized, as may a vowel after a lower case z:  these allow implementation of capitalization conventions for acronyms and also for certain uses of letterals as pronouns attested in existing text.  The first letter after a juncture may again be capitalized.  The scope of the capitalization rule ends at the first non-letter other than a juncture immediately followed by a letter.<p>


<TT>
caprule <- ((uppercase / lowercase) ((('z' V1) / lowercase / (juncture (caprule)?) / TAI0))* !(letter))</TT><P>


The permissible initial pairs of consonants.<p>


<TT>
InitialCC <- ('bl' / 'br' / 'ck' / 'cl' / 'cm' / 'cn' / 'cp' / 'cr' / 'ct' / 'dj' / 'dr' / 'dz' / 'fl' / 'fr' / 'gl' / 'gr' / 'jm' / 'kl' / 'kr' / 'mr' / 'pl' / 'pr' / 'sk' / 'sl' / 'sm' / 'sn' / 'sp' / 'sr' / 'st' / 'tc' / 'tr' / 'ts' / 'vl' / 'vr' / 'zb' / 'zv' / 'zl' / 'sv' / 'Bl' / 'Br' / 'Ck' / 'Cl' / 'Cm' / 'Cn' / 'Cp' / 'Cr' / 'Ct' / 'Dj' / 'Dr' / 'Dz' / 'Fl' / 'Fr' / 'Gl' / 'Gr' / 'Jm' / 'Kl' / 'Kr' / 'Mr' / 'Pl' / 'Pr' / 'Sk' / 'Sl' / 'Sm' / 'Sn' / 'Sp' / 'Sr' / 'St' / 'Tc' / 'Tr' / 'Ts' / 'Vl' / 'Vr' / 'Zb' / 'Zv' / 'Zl' / 'Sv')</TT><P>

A permissible initial pair possibly broken by a juncture.  This class is needed to test various conditions in the phonology.<p>


<TT>
MaybeInitialCC <- (([Bb] (juncture)? [l]) / ([Bb] (juncture)? [r]) / ([Cc] (juncture)? [k]) / ([Cc] (juncture)? [l]) / ([Cc] (juncture)? [m]) / ([Cc] (juncture)? [n]) / ([Cc] (juncture)? [p]) / ([Cc] (juncture)? [r]) / ([Cc] (juncture)? [t]) / ([Dd] (juncture)? [j]) / ([Dd] (juncture)? [r]) / ([Dd] (juncture)? [z]) / ([Ff] (juncture)? [l]) / ([Ff] (juncture)? [r]) / ([Gg] (juncture)? [l]) / ([Gg] (juncture)? [r]) / ([Jj] (juncture)? [m]) / ([Kk] (juncture)? [l]) / ([Kk] (juncture)? [r]) / ([Mm] (juncture)? [r]) / ([Pp] (juncture)? [l]) / ([Pp] (juncture)? [r]) / ([Ss] (juncture)? [k]) / ([Ss] (juncture)? [l]) / ([Ss] (juncture)? [m]) / ([Ss] (juncture)? [n]) / ([Ss] (juncture)? [p]) / ([Ss] (juncture)? [r]) / ([Ss] (juncture)? [t]) / ([Tt] (juncture)? [c]) / ([Tt] (juncture)? [r]) / ([Tt] (juncture)? [s]) / ([Vv] (juncture)? [l]) / ([Vv] (juncture)? [r]) / ([Zz] (juncture)? [b]) / ([Zz] (juncture)? [v]) / ([Zz] (juncture)? [l]) / ([Ss] (juncture)? [v]))</TT><P>

The forbidden medial pairs of consonants.<p>


<TT>
NonmedialCC <- (([b] (juncture)? [b]) / ([c] (juncture)? [c]) / ([d] (juncture)? [d]) / ([f] (juncture)? [f]) / ([g] (juncture)? [g]) / ([h] (juncture)? [h]) / ([j] (juncture)? [j]) / ([k] (juncture)? [k]) / ([l] (juncture)? [l]) / ([m] (juncture)? [m]) / ([n] (juncture)? [n]) / ([p] (juncture)? [p]) / ([q] (juncture)? [q]) / ([r] (juncture)? [r]) / ([s] (juncture)? [s]) / ([t] (juncture)? [t]) / ([v] (juncture)? [v]) / ([z] (juncture)? [z]) / ([h] (juncture)? C1) / ([cjsz] (juncture)? [cjsz]) / ([f] (juncture)? [v]) / ([k] (juncture)? [g]) / ([p] (juncture)? [b]) / ([t] (juncture)? [d]) / ([fkpt] (juncture)? [jz]) / ([b] (juncture)? [j]) / ([s] (juncture)? [b]))</TT><P>

The forbidden medial triples of consonants.<p>


<TT>
NonjointCCC <- (([c] (juncture)? [d] (juncture)? [z]) / ([c] (juncture)? [v] (juncture)? [l]) / ([n] (juncture)? [d] (juncture)? [j]) / ([n] (juncture)? [d] (juncture)? [z]) / ([d] (juncture)? [c] (juncture)? [m]) / ([d] (juncture)? [c] (juncture)? [t]) / ([d] (juncture)? [t] (juncture)? [s]) / ([p] (juncture)? [d] (juncture)? [z]) / ([g] (juncture)? [t] (juncture)? [s]) / ([g] (juncture)? [z] (juncture)? [b]) / ([s] (juncture)? [v] (juncture)? [l]) / ([j] (juncture)? [d] (juncture)? [j]) / ([j] (juncture)? [t] (juncture)? [c]) / ([j] (juncture)? [t] (juncture)? [s]) / ([j] (juncture)? [v] (juncture)? [r]) / ([t] (juncture)? [v] (juncture)? [l]) / ([k] (juncture)? [d] (juncture)? [z]) / ([v] (juncture)? [t] (juncture)? [s]) / ([m] (juncture)? [z] (juncture)? [b]))</TT><P>

A sequence of vowels of odd length, needed for certain tests.<p>


<TT>
Oddvowel <- ((juncture)? (((V2 (juncture)? V2 (juncture)?))* V2) (juncture)?)</TT><P>

Repeated vowels which force a stress on one of the two syllables formed.  In the case of <B>i</B> and <B>u</B>, the stress rule is only triggered if an explicit juncture is present, as these are possibly monosyllabic pairs.<p>


<TT>
RepeatedVowel <- (([Aa] (juncture)? [a]) / ([Ee] (juncture)? [e]) / ([Oo] (juncture)? [o]) / ([Ii] juncture [i]) / ([Uu] juncture [u]))</TT><P>

Repeated continuants indicating syllabic ("vocalic") pronunciation.<p>


<TT>
RepeatedVocalic <- (([Mm] [m]) / ([Nn] [n]) / ([Ll] [l]) / ([Rr] [r]))</TT><P>


Single continuant consonants.<p>

<TT>
Syllabic <- [lmnr]</TT><P>


Single non-continuant consonants.<p>


<TT>
Nonsyllabic <- (!(Syllabic) C1)</TT><P>

A pair consisting of a non-continuant followed by a continuant:  this is forbidden to be a pair of final consonants at the end of a syllable.  There is some logic here to exclude pairs of consonants which cannot be pairs of final consonants at all:  the pair will not be followed by a vowel segment, and it will not overlap a doubled continuant or the permissible initial <B>mr</B>.<p>


<TT>
Badfinalpair <- (Nonsyllabic !('mr') !(RepeatedVocalic) Syllabic !((V2 / [y] / RepeatedVocalic)))</TT><P>

The initial consonants in a syllable.  The first version appears in borrowed predicates, the second in names.  This is a segment of one to three consonants, each adjacent pair being a permissible initial, not sharing a letter with a syllabic doubled continuant, and (in a predicate) not followed by <B>y</B>, and of course not followed by a juncture.<p>

<TT>
FirstConsonants <- (((!((C1 C1 RepeatedVocalic)) &(InitialCC) (C1 InitialCC)) / (!((C1 RepeatedVocalic)) InitialCC) / ((!(RepeatedVocalic) C1) !([y]))) !(juncture))</TT><P>
<TT>
FirstConsonants2 <- (((!((C1 C1 RepeatedVocalic)) &(InitialCC) (C1 InitialCC)) / (!((C1 RepeatedVocalic)) InitialCC) / (!(RepeatedVocalic) C1)) !(juncture))</TT><P>

The vowel segment in a syllable, the first version appearing in borrowed predicates and the second in names.  In a predicate, this is either an instance of <TT>NextVowels</TT> (the appropriate next vowel or pair of vowels chosen from a stream of regular vowels, not followed by a syllabic doubled continuant, or a syllabic doubled continuant not followed by the same continuant.  In a name, an instance of <TT>NextVowels</TT> may be followed by a syllabic doubled continuant.<p>


<TT>
VowelSegment <- ((NextVowels !(RepeatedVocalic)) / (!((C1 RepeatedVocalic)) RepeatedVocalic))</TT><P>
<TT>
VowelSegment2 <- (NextVowels / (!((C1 RepeatedVocalic)) RepeatedVocalic))</TT><P>

<H3>Borrowed Predicates and Name Words</H3>


The Loglan syllable, in the version found in borrowed predicates.  The distinction between <TT>SyllableA</TT> and <TT>SyllableB</TT> is a subtlety. <TT>SyllableA</TT> starts with CV followed by a consonant (in the same or the next syllable), and zero, one or two final consonants (not making up a bad final pair) with the second one forbidden to stand at the beginning of a legal syllable; <TT>SyllableB</TT> takes the general form of an (optional) initial group of consonants followed by a vowel segment (which does not overlap a doubled vowel forcing a stress) followed by zero, one or two final consonants, not forming a bad final pair, and neither of them standing at the beginning of a legal syllable.<p>

The general idea is that one starts a new syllable as soon as possible, in the absence of explicit junctures, with the exception that in the situation CVcc (cc being a permissible initial) one will by preference place the break thus:  CVc-c (and similarly if the cc is replaced by an initial triple).<p>


<TT>
SyllableA <- ((C1 V2 &(C1) !(Badfinalpair) (FinalConsonant)? ((!(Syllable) FinalConsonant))?) (juncture)?)</TT><P>
<TT>
SyllableB <- ((FirstConsonants)? !(RepeatedVowel) !((&(Mono) V2 RepeatedVowel)) VowelSegment !(Badfinalpair) ((!(Syllable) FinalConsonant))? ((!(Syllable) FinalConsonant))? (juncture)?)</TT><P>
<TT>
Syllable <- (SyllableA / SyllableB)</TT><P>

Here is a permissible initial actually broken by an explicit juncture.<p>

<TT>
BrokenInitialCC <- (&(MaybeInitialCC) C1 juncture C1 &(V2))</TT><P>

The class <TT>JunctureFix</TT> describes some configurations of explicit junctures between consonants which are forbidden.  They are mostly situations in which one is not allowed to break a permissible initial with an explicit syllable break, but one describes an impermissible way to avoid such a break.  The purpose is to make it impossible to construct a legal borrowing by maliciously moving a syllable break in an illegal complex predicate (or for that matter by moving a syllable break to an inappropriate place in a legal complex predicate).  Such a maneuver can be shown always to create one of these bad configurations.  Some of these configurations can occur in legal complexes.<p>


<TT>
JunctureFix <- ((InitialCC V2 BrokenInitialCC) / (((C1 V2))? V2 BrokenInitialCC) / (C1 V2 !(stress) juncture InitialCC V2 Letter) / (C1 BrokenInitialCC V2))</TT><P>

Here is a menagerie of syllables which are or may be final in a borrowed predicate or irregular djifoa.
All have regular vowel segments. The first is unstressed and followed by a consonant which starts a syllable, or by <B>y</B>, or by a character which is not a letter or juncture.  The second is as the first but definitely followed by <B>y</B> or a character which is not a letter or juncture.  The last two are definitely final in a borrowing djifoa, being followed by <B>y</B>, and being permitted to be stressed (the last one definitely is stressed).<p>

<TT>
SyllableFinal1 <- ((FirstConsonants)? !(RepeatedVocalic) VowelSegment !(stress) (juncture)? !(V2) (&(Syllable) / &([y]) / !(Letter)))</TT><P>
<TT>
SyllableFinal2 <- ((FirstConsonants)? !(RepeatedVocalic) VowelSegment !(stress) (juncture)? (&([y]) / !(Letter)))</TT><P>
<TT>
SyllableFinal2a <- ((FirstConsonants)? !(RepeatedVocalic) VowelSegment (juncture)? &([y]))</TT><P>
<TT>
SyllableFinal2b <- ((FirstConsonants)? !(RepeatedVocalic) VowelSegment stress &([y]))</TT><P>

This is an explicitly stressed syllable (with its vowel segment not intersecting a doubled vowel forcing a stress).<p>

Note that a final syllable cannot be followed by a regular vowel (mod intervening juncture).  This is part of the arrangements for having to pause before vowel-initial words.<p>


<TT>
StressedSyllable <- (((FirstConsonants)? !(RepeatedVowel) !((&(Mono) V2 RepeatedVowel)) VowelSegment !(Badfinalpair) (FinalConsonant)? (FinalConsonant)?) stress)</TT><P>

These are final consonants in a Loglan syllable.  This is a consonant not participating in a doubled continuant, not starting a forbidden medial pair or triple of consonants, and not followed by a vowel (with or without an intervening juncture).  Vowel-initial syllables, when not initial, are always preceded immediately by vowel-final syllables.<p>


<TT>
FinalConsonant <- (!(RepeatedVocalic) !(NonmedialCC) !(NonjointCCC) C1 !(((juncture)? V2)))</TT><P>

Here is the form of the syllable which can appear in names.  Note the absence of the strictures against the vowel segment overlapping a doubled vowel forcing a stress, and the possibility of <B>y</B> instead of a <TT>VowelSegment</TT>.  Also note that neither final consonant may stand at the head of a syllable in a name:  syllables end as soon as possible without exception.<p>


<TT>
Syllable2 <- (((FirstConsonants2)? (VowelSegment2 / [y]) !(Badfinalpair) ((!(Syllable2) FinalConsonant))? ((!(Syllable2) FinalConsonant))?) (juncture)?)</TT><P>

The usual consonant-final name words. A name must resolve into the form of syllable just given and it must end with a consonant.  It must be followed by (and parsed as including) an explicit pause unless it is followed by end of text, terminal punctuation, another name word, or the little word <B>ci</B>.  A final stress mark may appear between the final consonant and the comma pause.<p>

<TT>
Name <- (([ ])* &(((uppercase / lowercase) ((!((C1 (stress)? !(Letter))) Lowercase))* C1 (stress)? !(Letter) (&(end) / comma / &(period) / &(Name) / &(CI)))) ((Syllable2)+ (&(end) / comma / &(period) / &(Name) / &(CI))))</TT><P>

We commence the construction of borrowed predicates and irregular (borrowing) djifoa.  The next class
identifies syllables with a continuant vowel segment of the kind which can occur in borrowings or irregular djifoa.<p>

<TT>
CCSyllableB <- (((FirstConsonants)? RepeatedVocalic !(Badfinalpair) ((!(Syllable) FinalConsonant))? ((!(Syllable) FinalConsonant))?) (juncture)?)</TT><P>

This is the final pair or triple of syllables in a borrowing, starting with the stressed syllable, followed optionally by an unstressed continuant syllable, followed by one of the final syllable forms from above.  If the stressed syllable is not explicitly stressed, the syllable must be followed by
a character other than a letter or juncture (usually a space or punctuation), as in this case we must deduce the presence of the stressed syllable from the word break; if the stressed syllable is explicitly stressed, no such explicit word break is required.<p>

<TT>
BorrowingTail <- ((!(JunctureFix) !(CCSyllableB) StressedSyllable ((!(StressedSyllable) CCSyllableB))? !(StressedSyllable) SyllableFinal1) / (!(CCSyllableB) !(JunctureFix) Syllable ((!(StressedSyllable) CCSyllableB))? !(StressedSyllable) SyllableFinal2))</TT><P>

This is a first approximation to the borrowing class:  a sequence of syllables which are not stressed and not initial in a borrowing tail, with no two continuant syllables adjacent, followed by a borrowing tail.  Additional conditions must be imposed on this class to get a borrowing.<p>



<TT>
PreBorrowing <- (((!(BorrowingTail) !(StressedSyllable) !(JunctureFix) !((CCSyllableB CCSyllableB)) Syllable))* !(CCSyllableB) BorrowingTail)</TT><P>

This class encodes the condition that a borrowing predicate must contain a CC pair.  A borrowing may begin with a consonant followed by an indeterminate length stream of unstressed vowels (or just an indeterminate length stream of unstressed vowels); if it does, what follows will begin with CC (possibly broken by a juncture) and cannot be a well-formed borrowing by itself (so the initial (C)V<SUP>n</SUP> doesn't fall off) nor can it be a permissible initial broken by an explicit juncture which would start a borrowing if the juncture were dropped; if a borrowing does not begin with such a (C)V<SUP>n</SUP>  it begins CC.<p>


<TT>
HasCCPair <- ((((C1)? ((V2 ((!(stress) juncture))?))+ !(Borrowing) !((&(MaybeInitialCC) C1 (!(stress) juncture) !(CCVV) PreBorrowing)) (stress)?))? C1 (juncture)? C1)</TT><P>

A borrowing does not begin CVcc with the cc being a permissible initial (possibly broken with a juncture) and the second c starting a pre-complex or complex tail (something resolvable into djifoa);
the initial CV would fall off.  Such a form is resolvable into djifoa, but the initial CVc is required to be <B>y</B>-hyphenated; this is part of the elimination of the <B>slinkui</B> test effected in the 90's.<p>


<TT>
CVCBreak <- (C1 V2 (juncture)? &(MaybeInitialCC) C1 (juncture)? &((PreComplex / ComplexTail)))</TT><P>

CCVV and CCCVV predicates are forbidden.  They would cause various technical problems.<p>

<TT>
CCVV <- ((&(BorrowingTail) C1 C1 (C1)? V2 stress !(Mono) V2) / (&(BorrowingTail) C1 C1 (C1)? V2 (juncture)? V2 (!(Letter) / ((juncture)? [y]))))</TT><P>

And now the borrowing class can be defined.  A borrowing is a pre-borrowing which satisfies the CC pair condition as formalized above, is not a <TT>CVCbreak</TT> or CC(C)VV predicate, does not start with a continuant syllable, and does not begin ((C)V[V])VccV where cc is a permissible initial, even if the cc is broken by a juncture (there are predicates beginning with CVVccV).  The difficulty with ((C)V[V])VccV  is that the initial V or CV[V] would fall off an initial borrowing affix ((C)V[V])VccVy if this were the entire word (what would be left would be a ccVy djifoa); longer words of this shape would usually have the initial (C)V<SUP>n</SUP> fall off in any case.  A word of the shape CVVccV is a complex predicate; some longer words beginning with this are allowed.<p>


<TT>
Borrowing <- (&(HasCCPair) !(CVCBreak) !(CCVV) !(((((C1)? (V2 (juncture)?) ((V2 (juncture)? &(V2)))+))? V2 (juncture)? MaybeInitialCC V2)) !(CCSyllableB) (((!(BorrowingTail) !(StressedSyllable) !((CCSyllableB CCSyllableB)) !(JunctureFix) Syllable))* !(CCSyllableB) BorrowingTail))</TT><P>

The definition of a irregular (borrowing) djifoa follows.  The basic idea is that a borrowing djifoa is a borrowing with no explicit stresses present, with <B>y</B> appended, with, optionally, a stress marker preceding the <B>y</B> (thus stressing the last, normally unstressed, syllable of the original borrowing).  Note that a borrowing djifoa may be followed by a pause (in which case it is always stressed on the syllable preceding the <B>y</B>, whether this is explicitly indicated or not); the special class of stressed borrowing djifoa here is not followed by a pause.<p>


<TT>
PreBorrowingAffix <- ((((!(StressedSyllable) !(SyllableFinal2a) !((CCSyllableB CCSyllableB)) !(JunctureFix) Syllable))+ SyllableFinal2a) (juncture)? [y] !(stress) (juncture)? (([ ,] ([ ])*))?)</TT><P>
<TT>
BorrowingAffix <- (&(HasCCPair) !(CVCBreak) !(CCVV) !(((((C1)? (V2 (juncture)?) ((V2 (juncture)? &(V2)))+))? V2 (juncture)? MaybeInitialCC V2)) !(CCSyllableB) (((!(StressedSyllable) !(SyllableFinal2a) !((CCSyllableB CCSyllableB)) !(JunctureFix) Syllable))+ SyllableFinal2a) (juncture)? [y] !(stress) (juncture)? (comma)?)</TT><P>
<TT>
StressedBorrowingAffix <- (&(HasCCPair) !(CVCBreak) !(CCVV) !(((((C1)? (V2 (juncture)?) ((V2 (juncture)? &(V2)))+))? V2 (juncture)? MaybeInitialCC V2)) !(CCSyllableB) (((!(StressedSyllable) !(SyllableFinal2a) !((CCSyllableB CCSyllableB)) !(JunctureFix) Syllable))* SyllableFinal2b) (juncture)? [y] !(stress) (juncture)? !([,]))</TT><P>

<H3>Complex Predicates</H3>

Here is the <B>y</B>-hyphen to attach to djifoa to avoid phonetic problems.  A <B>y</B>-hyphen is
never stressed.  It is never final in a word (so it is followed by a letter with optional intervening juncture).  It is not followed by another <B>y</B>.<p>


<TT>
yhyphen <- ((juncture)? [y] !(stress) (juncture)? !([y]) &(letter))</TT><P>

This is an unstressed CV syllable suitable to be the final syllable of a five-letter djifoa:  it is not stressed and
it is not followed by a vowel (with or without intervening juncture), which is part of the arrangements for being forced to pause before vowel-initial words.<p>

<TT>
CV <- (C1 V2 !(stress) (juncture)? !(V2))</TT><P>

This is the final consonant in a CVC djifoa.  It may take the form C<B>y</B> (if the djifoa is "hyphenated").  Otherwise it is not initial in a forbidden pair or triple of consonants and it is not followed by a vowel (with or without intervening juncture).<p>

4/27 revised the grammar to add optional juncture at the beginning of Cfinal so that for example <B>mekykiu</B> can be
<B>me'kykiu</B> as well as <B>mek'ykiu</B>.  This is important relative to avoiding the allophone of
<B>h</B>.  We do want to prevent a juncture appearing both before and after the consonant!<p>


<TT>
Cfinal <- ((((juncture &((C1 !(juncture)))))? C1 yhyphen) / (!(NonmedialCC) !(NonjointCCC) C1 !(((juncture)? V2))))</TT><P>

This is the general form of a "hyphen" averting phonetic problems with a djifoa.  It is either
<B>r</B> (which may not be followed by <B>r</B>, with or without intervening juncture) or <B>n</B> (which will be followed by <B>r</B>, with or without intervening juncture, or <B>y</B>.  A "hyphen"
will be followed by a consonant, with or without an intervening juncture.<p>

A typical use of such a "hyphen" is to attach a CVV djifoa to the beginning of a predicate so that it will not "fall off".<p>

<TT>
hyphen <- (!(NonmedialCC) !(NonjointCCC) (([r] !(((juncture)? [r])) !(((juncture)? V2))) / ([n] (juncture)? &([r])) / ((juncture)? [y] !(stress))) ((juncture)? &(letter)) !(((juncture)? [y])))</TT><P>

This is a "hyphen" of the shape <B>n</B> or <B>r</B>.<p>


<TT>
noyhyphen <- (!(NonmedialCC) !(NonjointCCC) (([r] !(((juncture)? [r])) !(((juncture)? V2))) / ([n] (juncture)? &([r]))) &(((juncture)? &(letter))) !(((juncture)? [y])))</TT><P>

This is a class of stressed syllables suitable for complexes.<p>

<TT>
StressedSyllable2 <- (((FirstConsonants)? VowelSegment !(Badfinalpair) (FinalConsonant)? (FinalConsonant)?) stress (yhyphen)?)</TT><P>

Varieties of CVV djifoa follow.  <TT>CVVStressed</TT> is a CVV djifoa which is definitely stressed and can be stressed on the second syllable (the first case is that of a doubled vowel, where there is an option about how the stress could be placed).  <TT>CVVStressed2</TT> is a stressed monosyllabic CVV djifoa.  <TT>CVV</TT> is the general class of these djifoa.<p>


<TT>
CVVStressed <- (((C1 &(RepeatedVowel) V2 !(stress) (juncture)? !(RepeatedVowel) V2 (noyhyphen)?) (juncture)? (yhyphen)?) / (C1 !(BrokenMono) V2 !(stress) juncture V2 (noyhyphen)? stress (yhyphen)?) / (C1 !(Mono) V2 V2 (noyhyphen)? stress (yhyphen)?))</TT><P>
<TT>
CVVStressed2 <- (C1 Mono (noyhyphen)? stress (yhyphen)?)</TT><P>
<TT>
CVV <- (!((C1 V2 stress V2 (hyphen)? stress)) ((C1 !(BrokenMono) V2 (juncture)? !(RepeatedVowel) V2 (noyhyphen)?) (juncture)? !(V2) (yhyphen)?))</TT><P>

These are classes of CVV djifoa which are or can be final in a complex, except for the last one which has technical uses (it is followed by a <B>y</B>, which will not happen at the end of a complex).<p>

Note that none of these can be followed by a regular vowel (mod intervening juncture);  this is part of the arrangements for having to pause before vowel-initial words.<p>


<TT>
CVVFinal1 <- (C1 !(BrokenMono) V2 stress !(RepeatedVowel) V2 !(stress) (juncture)? !(V2))</TT><P>
<TT>
CVVFinal2 <- (((C1 !(Mono) V2 V2) / (C1 !(BrokenMono) V2 juncture !(RepeatedVowel) V2)) !(Letter))</TT><P>
<TT>
CVVFinal3 <- (C1 &(Mono) V2 V2 !(stress) (juncture)? !(V2))</TT><P>
<TT>
CVVFinal4 <- (C1 Mono !(Letter))</TT><P>
<TT>
CVVFinal5 <- (((C1 !(Mono) V2 V2) / (C1 !(BrokenMono) V2 juncture V2)) &(((juncture)? [y])))</TT><P>

Varieties of CVC djifoa.  The first is general; the second is stressed.<p>

NOTE:  the change made above in Cfinal motivated an additional form for CVCStressed.<p>

CVC djifoa cannot be final in a complex, so no final forms are given.<p>


<TT>
CVC <- ((C1 V2 Cfinal) (juncture)?)</TT><P>
<TT>
CVCStressed <- ((C1 V2 !(NonmedialCC) !(NonjointCCC) C1 stress !(V2) (yhyphen)?) / (C1 V2 stress C1 !(juncture) yhyphen))</TT><P>

Varieties of CCV djifoa.  A basic form and an explicitly stressed form are given.<p>



<TT>
CCV <- (InitialCC !(RepeatedVowel) V2 (juncture)? !(V2) (yhyphen)?)</TT><P>
<TT>
CCVStressed <- (InitialCC !(RepeatedVowel) V2 stress !(V2) (yhyphen)?)</TT><P>

Forms of CCV djifoa which are or can be final.  As above, note that none of these can be followed by a regular vowel.<p>


<TT>
CCVFinal1 <- (InitialCC !(RepeatedVowel) V2 !(stress) (juncture)? !(V2))</TT><P>
<TT>
CCVFinal2 <- (InitialCC V2 !(Letter))</TT><P>

Forms of CCVCV djifoa.<p>


<TT>
CCVCVMedial <- (InitialCC V2 (juncture)? C1 [y] !(stress) (juncture)? &(letter))</TT><P>
<TT>
CCVCVMedialStressed <- (CCV stress C1 [y] !(stress) (juncture)? &(letter))</TT><P>

Forms of CCVCV predicates final in a complex (and a form followed by <B>y</B>)<p>

<TT>
CCVCVFinal1 <- (InitialCC V2 stress CV)</TT><P>
<TT>
CCVCVFinal2 <- (InitialCC V2 (juncture)? CV !(Letter))</TT><P>
<TT>
CCVCVY <- (InitialCC V2 (juncture)? CV [y])</TT><P>

Forms of CVCCV djifoa.  The stressed form has two alternatives because the syllable break can be in different places.<p>


<TT>
CVCCVMedial <- (C1 V2 ((juncture &(InitialCC)))? !(NonmedialCC) C1 (juncture)? C1 [y] !(stress) (juncture)? &(letter))</TT><P>
<TT>
CVCCVMedialStressed <- ((C1 V2 (stress &(InitialCC)) !(NonmedialCC) C1 C1 [y] !(stress) (juncture)? &(letter)) / (C1 V2 !(NonmedialCC) C1 stress C1 [y] !(stress) (juncture)? &(letter)))</TT><P>

Forms of CVCCV predicates final in a complex, and forms with an appended <B>y</B>.  Note that none of the five letter predicate forms can be followed by a vowel, mod intervening juncture.<p>

<TT>
CVCCVFinal1a <- (C1 V2 stress InitialCC V2 !(stress) (juncture)? !(V2))</TT><P>
<TT>
CVCCVYa <- (C1 V2 (juncture)? InitialCC V2 !(stress) (juncture)? [y])</TT><P>
<TT>
CVCCVFinal1b <- (C1 V2 !(NonmedialCC) C1 stress CV)</TT><P>
<TT>
CVCCVYb <- (C1 V2 !(NonmedialCC) C1 (juncture)? CV [y])</TT><P>
<TT>
CVCCVFinal2 <- (C1 V2 ((juncture &(InitialCC)))? !(NonmedialCC) C1 (juncture)? CV !(Letter))</TT><P>

The five letter predicate forms with appended <B>y</B>.  This form and all of its subforms exist only to be excluded:  this is not a possible form for a borrowing djifoa.<p>


<TT>
FiveLetterY <- (CCVCVY / CVCCVYa / CVCCVYb)</TT><P>

Classes of final djifoa of interest.<p>

<TT>
GenericFinal <- (CVVFinal3 / CVVFinal4 / CCVFinal1 / CCVFinal2)</TT><P>
<TT>
FiveLetterFinal <- (CCVCVFinal1 / CCVCVFinal2 / CVCCVFinal1a / CVCCVFinal1b / CVCCVFinal2)</TT><P>
<TT>
GenericTerminalFinal <- (CVVFinal4 / CCVFinal2)</TT><P>

Regular djifoa.<p>

<TT>
Affix1 <- (CCVCVMedial / CVCCVMedial / CCV / CVV / CVC)</TT><P>

The classes <TT>Peelable</TT> and <TT>Peelable2</TT> are cunning pieces of PEG programming.  They represent fake regular djifoa which are actually initial segments of borrowing djifoa and borrowings proper, respectively.<p>


<TT>
Peelable <- (&(PreBorrowingAffix) !(CVVFinal1) !(CVVFinal5) Affix1 (!(Affix1) / &((&(PreBorrowingAffix) !(CVVFinal1) !(CVVFinal5) Affix1 !(PreBorrowingAffix) !(Affix1))) / Peelable))</TT><P>
<TT>
Peelable2 <- (&(PreBorrowing) !(CVVFinal1) !(CVVFinal2) !(CVVFinal5) !(FiveLetterFinal) Affix1 !(FiveLetterFinal) (!(Affix1) / &((&(PreBorrowing) !(FiveLetterFinal) !(CVVFinal1) !(CVVFinal2) !(CVVFinal5) Affix1 !(PreBorrowing) !(FiveLetterFinal) !(Affix1))) / Peelable2))</TT><P>

The general class of djifoa:  regular djifoa which are not fake in the sense just indicated, or
borrowing djifoa other than the illegal five letter forms.<p>


<TT>
Affix <- ((!(Peelable) !(Peelable2) Affix1) / (!(FiveLetterY) BorrowingAffix))</TT><P>

Djifoa which are either regular djifoa containing no stresses or borrowing djifoa.<p>


<TT>
Affix2 <- (!(StressedSyllable2) !(CVVStressed) Affix)</TT><P>

This is the final djifoa or two of a complex, containing the stress and long enough to be a complex itself.  The logic could bear extensive commentary.<p>

<TT>
ComplexTail <- ((Affix GenericTerminalFinal) / (!((!(Peelable) Affix1)) !(FiveLetterY) StressedBorrowingAffix GenericFinal) / (CCVCVMedialStressed GenericFinal) / (CVCCVMedialStressed GenericFinal) / (CCVStressed GenericFinal) / (CVCStressed GenericFinal) / (CVVStressed GenericFinal) / (CVVStressed2 GenericFinal) / (Affix2 CVVFinal1) / (Affix2 CVVFinal2) / CCVCVFinal1 / CCVCVFinal2 / CVCCVFinal1a / CVCCVFinal1b / CVCCVFinal2 / (!((CVVStressed / StressedSyllable2)) Affix !((!(Peelable2) Affix1)) Borrowing !(((juncture)? [y]))))</TT><P>

The primitive five-letter predicates.<p>

<TT>
Primitive <- (CCVCVFinal1 / CCVCVFinal2 / CVCCVFinal1a / CVCCVFinal1b / CVCCVFinal2)</TT><P>

An initial approximation to the class of complex predicates:  a possibly empty chain of affixes, none of them stressed or the start of a complex tail, followed by a complex tail.<p>

<TT>
PreComplex <- (ComplexTail / ((!((CVCStressed / CCVStressed / CVVStressed / ComplexTail / StressedSyllable2)) Affix) PreComplex))</TT><P>

The class of complex predicates.  This is a precomplex which does not begin with an unhyphenated CVV followed by another CVV, nor with any other CVV which would fall off the front, nor with CVcc (with or without a juncture between the cc's where cc is a permissible initial (mod possible juncture) and the second c starts a precomplex or complex tail:  a CVC djifoa followed by a djifoa which would make a permissible initial pair must be <B>y</B>-hyphenated (this is how the <B>slinkui</B> test was eliminated).<p>

<TT>
Complex <- (!((C1 V2 (juncture)? (V2)? (juncture)? CVV)) !((C1 V2 !(stress) (juncture)? (V2)? !(stress) (juncture)? (Primitive / PreComplex / Borrowing / CVV))) !((C1 V2 (juncture)? &(MaybeInitialCC) C1 (juncture)? &((PreComplex / ComplexTail)))) PreComplex)</TT><P>

A predicate is a primitive, complex or borrowing (notice that primitive is tried first, then complex, then borrowing);  in addition, such a word (or a consonant-initial unit cmapua) can be linked with <B>zao</B> to a predicate word to form a new predicate.  The <B>zao</B> construction means exactly the same thing as concatenation of djifoa (this construction is a proposal of John Cowan; it is an alternative to use of borrowing djifoa, for example).<p>


<TT>
Predicate <- (((&(caprule) ((Primitive / Complex / Borrowing) ((([ ])* Z AO (', ')? ([ ])* Predicate))?)) / (C1 V2 (V2)? ([ ])* Z AO (comma)? ([ ])* Predicate)) !(((juncture)? [y])))</TT><P>

<H3> Phonology of syllables in cmapua </H2>

A consonant followed by four vowels cannot occur in a cmapua.  This prevents a CVV cmapua from being followed by a VV cmapua without pause, part of the mechanism to force pauses before vowel initial words.<p>

<TT>
Fourvowels <- (C1 V2 (juncture)? V2 (juncture)? V2 (juncture)? V2)</TT><P>

Initial consonants in unit cmapua:  they do not start predicates, nor are they followed by four vowels.<p>

<TT>
B <- (!(Predicate) !(Fourvowels) [Bb])</TT><P>
<TT>
C <- (!(Predicate) !(Fourvowels) [Cc])</TT><P>
<TT>
D <- (!(Predicate) !(Fourvowels) [Dd])</TT><P>
<TT>
F <- (!(Predicate) !(Fourvowels) [Ff])</TT><P>
<TT>
G <- (!(Predicate) !(Fourvowels) [Gg])</TT><P>
<TT>
H <- (!(Predicate) !(Fourvowels) [Hh])</TT><P>
<TT>
J <- (!(Predicate) !(Fourvowels) [Jj])</TT><P>
<TT>
K <- (!(Predicate) !(Fourvowels) [Kk])</TT><P>
<TT>
L <- (!(Predicate) !(Fourvowels) [Ll])</TT><P>
<TT>
M <- (!(Predicate) !(Fourvowels) [Mm])</TT><P>
<TT>
N <- (!(Predicate) !(Fourvowels) [Nn])</TT><P>
<TT>
P <- (!(Predicate) !(Fourvowels) [Pp])</TT><P>
<TT>
R <- (!(Predicate) !(Fourvowels) [Rr])</TT><P>
<TT>
S <- (!(Predicate) !(Fourvowels) [Ss])</TT><P>
<TT>
T <- (!(Predicate) !(Fourvowels) [Tt])</TT><P>
<TT>
V <- (!(Predicate) !(Fourvowels) [Vv])</TT><P>
<TT>
Z <- (!(Predicate) !(Fourvowels) [Zz])</TT><P>

Lone vowels in cmapua syllables; note that the juncture following is
the <TT>juncture2</TT> class, guarded against a following predicate without a pause if it is a stress, and of course not followed by a vowel (with or without intervening juncture), which helps to prevent confusion with
CVV cmapua and force pauses before vowel-initial words.<p>


<TT>
a <- ([Aa] (juncture2)? !(V2))</TT><P>
<TT>
e <- (([Ee] (juncture2)?) !(V2))</TT><P>
<TT>
i <- ([Ii] (juncture2)? !(V2))</TT><P>
<TT>
o <- ([Oo] (juncture2)? !(V2))</TT><P>
<TT>
u <- ([Uu] (juncture2)? !(V2))</TT><P>

Pairs of vowels in cmapua; note the use of <TT>juncture2</TT>.  Such a pair of vowels is followed
either by a single vowel followed by a non-vowel (in a Cvv-V situation) or an even number of vowels
(nonzero only in a compound attitudinal).<p>

The V2 non V2 option is supported for all vowel pairs;  it could be restricted to monosyllables.  This has nontrivial effects:  it means that one does not have to pause before a legacy vowel name after a VV or CVV cmapua syllable.  4/27 the new rule V3 ensures that one must pause between a VV and a following vowel initial predicate.<p>

There are currently two (sort of) exceptions to being forced to pause before vowel initial words:  VV attitudinals
can be freely chained without pause, though one must pause before the first one.  One must pause before
a legacy vowel name of VCV form, except when it occurs as a unit in an acronym.  Neither of these are strictly an exception to the rule that one must pause before a vowel-initial <EM>word</EM>.  At this point we have completed the proof, interspersed through documentation of word forms in this section, that one must pause before a vowel-initial word, with the exceptions or near-exceptions noted.<p>


<TT>
V3 <- (!(Predicate) V2)</TT><P>
<TT>
AA <- ([Aa] (juncture)? [a] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
AE <- ([Aa] (juncture)? [e] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
AI <- ([Aa] [i] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
AO <- ([Aa] [o] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
AU <- ([Aa] (juncture)? [u] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
EA <- ([Ee] (juncture)? [a] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
EE <- ([Ee] (juncture)? [e] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
EI <- ([Ee] [i] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
EO <- ([Ee] (juncture)? [o] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
EU <- ([Ee] (juncture)? [u] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
IA <- ([Ii] (juncture)? [a] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
IE <- ([Ii] (juncture)? [e] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
II <- ([Ii] (juncture)? [i] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
IO <- ([Ii] (juncture)? [o] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
IU <- ([Ii] (juncture)? [u] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
OA <- ([Oo] (juncture)? [a] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
OE <- ([Oo] (juncture)? [e] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
OI <- ([Oo] [i] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
OO <- ([Oo] (juncture)? [o] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
OU <- ([Oo] (juncture)? [u] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
UA <- ([Uu] (juncture)? [a] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
UE <- ([Uu] (juncture)? [e] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
UI <- ([Uu] (juncture)? [i] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
UO <- ([Uu] (juncture)? [o] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>
<TT>
UU <- ([Uu] (juncture)? [u] (juncture2)? (&((V3 (juncture)? !(V2))) / !(Oddvowel)))</TT><P>

<H2>Lexicography</H2>

<H3>Conditions on cmapua words</H3>

Conditions which must hold at the start of a cmapua word.<p>



<TT>
__LWinit <- (([ ])* !(Predicate) &(caprule))</TT><P>

<H3>Pauses</H3>


Convert an explicit pause which might be significant to a form which will be ignored.<p>


<TT>
CANCELPAUSE <- (comma (('y' comma) / (C UU !(connective))))</TT><P>

A pause, of the sort which is recognized as a free modifier (<B>not</B> as an elided <B>gu</B>).  The phonetically required pauses
after name words or after stressed cmapua before consonant initial predicates are not of this form (they are part of the words they follow).<p>


<TT>
PAUSE <- (!(CANCELPAUSE) comma !(connective) !(V1))</TT><P>

<H3> Letter names </H3>

A simple letter name.  These appear early because they have to be mentioned in a variety of rules.<p>

These include both the traditional Vfi and Vma vowel names and the new ziV and ziVma vowel names.<p>

I have provided full support for the legacy vowel names, but they are phonetically quite exceptional in various ways.  Added the Greek legacy vowels in -zi.<p>


<TT>
TAI0 <- (!(Predicate) (((V1 (juncture)? !(Predicate) !(Name) M a (juncture2)?) / (V1 (juncture)? !(Predicate) !(Name) F i (juncture2)?) / (V1 (juncture)? !(Predicate) !(Name) Z i (juncture2)?) / (C1 AI (u)?) / (C1 EI (u)?) / (C1 EO) / (Z [i] (juncture)? V1 (juncture2)? ((M a))? (juncture2)?)) (!(Oddvowel) / (!([ ]) &(TAI0)))))</TT><P>

<H3> Logical connectives and utterance connectives </H3>

A general purpose negative suffix.<p>


<TT>
NOI <- (N OI)</TT><P>

An atomic logical connective, one of <B>a, e, o, u, ha</B>.  This cannot be followed by a vowel,
and falls under the final cmapua syllable before predicate pause rule if stressed.<p>


<TT>
A0 <- (!(Predicate) !((Mono / BrokenMono)) (([AEOUaeou] / (H a)) (juncture2)? !(V2)))</TT><P>

A more general class of logical connectives.  This is guarded against confusion with the initial vowel
in a legacy Vfi/Vma vowel name.  The connective <B>u</B> or <B>no</B>-initial forms may form converses with initial
<B>nu</B>.  Forms not starting with <B>no</B> or <B>nu</B> may be prefixed with <B>no</B> to indicate negation of what precedes them.  The <TT>A0</TT> core follows.  Optionally, this may be followed by <B>noi</B> to negate what follows.  Optionally, this may be followed by a <B>PA</B> word (a tense, location or modifier word) with no internal pauses, closed with <B>fi</B> or an explicit pause.  If a logical connective is followed by a PA word not intended as a suffix an intervening explicit comma pause is usually required.  The pause closure is provided for backward compatibility with legacy text:  <B>fi</B> is preferred going forward.<p>

The APA forms (and related IPA forms) are a phonetic problem in 1989 Loglan.  I have tried out a number of solutions:  the best one seems to be to force closure of the PA component.  It can be noted that JCB appears to have usually closed IPA words with an explicit comma pause in Notebook 3.  Getting legacy text to parse often requires addition of commas to disambiguate APA from A PA situations.<p>


<TT>
A <- (__LWinit !(TAI0) (((N [u]) &((u / (N [o])))))? ((N [o]))? A0 (NOI)? !((([ ])+ PANOPAUSES PAUSE)) !((PANOPAUSES !(PAUSE) [ ,])) ((PANOPAUSES ((F i) / &(PAUSE))))?)</TT><P>

Suffixed classes of logical connectives with different precedence, closed with <B>ci</B> or <B>ge</B>
(and so of course needing no closure in their internal copy of an element of the class above) use this class as a component.<p>

<TT>
ANOFI <- (__LWinit !(TAI0) (((N [u]) &((u / (N [o])))))? ((N [o]))? A0 (NOI)? (PANOPAUSES)?)</TT><P>

The <TT>A</TT> class packaged as a word.<p>


<TT>
A1 <- (A !(connective))</TT><P>


Suffixed classes of logical connectives with different precedence, closed with <B>ci</B> or <B>ge</B>.<p>


<TT>
ACI <- (ANOFI C i !(connective))</TT><P>
<TT>
AGE <- (ANOFI G e !(connective))</TT><P>

Tightly binding logical connectives used between predicates.  The penultimate form in this list is an internal component of a class of utterance logical connectives given below.<p>


<TT>
CA0 <- ((((N o))? ((C a) / (C e) / (C o) / (C u) / (Z e) / (C i H a))) (NOI)?)</TT><P>
<TT>
CA1 <- ((((N u) &(((C u) / (N o)))))? ((N o))? CA0 !((([ ])+ PANOPAUSES PAUSE)) !((PANOPAUSES !(PAUSE) [ ,])) ((PANOPAUSES ((F i) / &(PAUSE))))?)</TT><P>
<TT>
CA1NOFI <- ((((N u) &(((C u) / (N o)))))? ((N o))? CA0 (PANOPAUSES)?)</TT><P>
<TT>
CA <- (__LWinit &(caprule) CA1 !(connective))</TT><P>

The mixture connective <B>ze</B> used between predicates is included in the class just given; this is the mixture connective used between arguments.<p>


<TT>
ZE2 <- (__LWinit (Z e) !(connective))</TT><P>

Assorted utterance connectives.<p>



<TT>
I <- (__LWinit !(TAI0) i !((([ ])+ PANOPAUSES PAUSE)) !((PANOPAUSES !(PAUSE) [ ,])) ((PANOPAUSES ((F i) / &(PAUSE))))? !(connective))</TT><P>
<TT>
ICA <- (__LWinit !(Predicate) i ((H a) / CA1) !(connective))</TT><P>
<TT>
ICI <- (__LWinit i (CA1NOFI)? C i !(connective))</TT><P>
<TT>
IGE <- (__LWinit i (CA1NOFI)? G e !(connective))</TT><P>

The phonetic class of connective words, plus the vowel initial letterals (the legacy VCV vowel names).  These are used to enforce the rule that one must pause before certain words -- not all of the connectives are vowel-initial, so it is not just a consequence of that phonetic rule.<p>  

The standard use of these is that most word classes end with
<TT>!connective</TT> to force an explicit comma pause before these connectives.  This is not simply an instance of being forced to pause before vowel-initial words, as it also applies to consonant-initial elements of these classes.<p>


<TT>
connective <- (ACI / AGE / A1 / ICI / ICA / IGE / I / (&(V1) TAI0))</TT><P>

Basic forethought logical connectives.<p>


<TT>
KA0 <- ((K a) / (K e) / (K o) / (K u) / (K i H a))</TT><P>

The causal and comparative modifiers.  They appear here because they can be used to build causal and comparative forethought connectives.<p>

The addition of comparative connectives is a novelty, but an inevitable side effect of allowing converse and negative forms of the comparative modifiers described in one of the paradigms.<p>


<TT>
KOU <- ((K OU) / (M OI) / (R AU) / (S OA) / (M OU) / (C IU))</TT><P>
<TT>
KOU1 <- (((N u N o) / (N u) / (N o)) KOU)</TT><P>

The general initial forms in forethought connections.<p>


<TT>
KA <- (__LWinit &(caprule) (((((N u) &((K u))))? KA0) / ((KOU1 / KOU) K i)) (NOI)? !(connective))</TT><P>

The two medial forms allowed in forethought connections.<p>


<TT>
KI <- (__LWinit (K i) (NOI)? !(connective))</TT><P>

This identifies a causal or comparative modifier which is not the initial segment of a causal or comparative initial forethought connective.<p>

<TT>
KOU2 <- (KOU1 !(KI))</TT><P>

<H3> Numerals and quantifiers </H3>

A rule identifying a misplaced stress in a numerical predicate.<p>


<TT>
BadNIStress <- ((C1 V2 (V2)? stress ((M a))? ((M OA))? NI RA) / (C1 V2 stress V2 ((M a))? ((M OA))? NI RA))</TT><P>

Atomic quantity words, other than the quantifiers which double as suffixes.<p>


<TT>
NI0 <- (!(BadNIStress) ((K UA) / (G IE) / (G IU) / (H IE) / (H IU) / (K UE) / (N EA) / (N IO) / (P EA) / (P IO) / (S UU) / (S UA) / (T IA) / (Z OA) / (Z OO) / (H o) / (N i) / (N e) / (T o) / (T e) / (F o) / (F e) / (V o) / (V e) / (P i) / (R e) / (R u) / (S e) / (S o) / (H i)))</TT><P>


The quantifier prefixes.<p>

<B>ie</B> is the interrrogative "which".  Note that it is allowed to be followed by a pause (phonetics forbid it to be part of a "word" with the other components of a NI word).<p>


<TT>
SA <- (!(BadNIStress) ((S a) / (S i) / (S u) / (IE (((comma2)? !(IE) SA))?)) (NOI)?)</TT><P>

The quantifier words which double as predicate forming suffixes.<p>


<TT>
RA <- (!(BadNIStress) ((R a) / (R i) / (R o)))</TT><P>

<B>ma</B>, standing for 00 and <B>moa</B> (replacing 1989 Loglan <B>mo</B>) are removed from
the pool of atomic quantifier words and are used only as affixes.  Class <TT>NI1</TT> consists
of an atomic quantity word followed optionally by <B>ma</b> followed optionally by <B>moa</B> (where <B>moa</B> is optionally suffixed with a sequence of digits to tell you how many blocks 000 are to be appended).<p>

Further, such a unit may be followed by a space or comma which is to be ignored if it is further followed by a <TT>NI</TT> word which is not a numerical predicate.  One may pause explicitly or implicitly when uttering a long numeral.<p>


<TT>
NI1 <- ((NI0 ((!(BadNIStress) M a))? ((!(BadNIStress) M OA (NI0)*))?) ((comma2 !((NI RA)) &(NI)))?)</TT><P>


Words of class <TT>RA</TT> may similarly receive affixes.<p>


<TT>
RA1 <- ((RA ((!(BadNIStress) M a))? ((!(BadNIStress) M OA (NI0)*))?) ((comma2 !((NI RA)) &(NI)))?)</TT><P>

This is a class of complex quantifier words.  They may optionally start with a <TT>SA</TT>,
followed by a string of one or more <TT>NI1</TT>'s or a single <TT>RA1</TT>, or it may be a <TT>SA</TT> alone, further optionally suffixed with <B>noi</B>.  What I have described so far I call a block:  a <TT>NI2</TT> is either a block or a string of blocks linked with <TT>CA0</TT> logical connective units.<p>


<TT>
NI2 <- ((((SA)? ((NI1)+ / RA1)) / SA) (NOI)? ((CA0 (((SA)? ((NI1)+ / RA1)) / SA) (NOI)?))*)</TT><P>

A <TT>NI</TT> quantifier starts with a core <TT>NI2</TT>, followed either by <B>cu</B> or by <B>mue</B> followed by an acronym (standing for a dimension) ending with an explicit comma pause, terminal punctuation, or end of text.   The use of <B>mue</B> and the requirement of an explicit pause after the acronym address the usual phonetic problems with isolating acronyms.<p>

NOTE:  4/28 examination of this rule motivated moving <B>ie</B> into the class <B>SA</B> as shown above
and otherwise eliminating all special rules for handling this word.<p>

<TT>
NI <- (__LWinit NI2 ((&((M UE)) Acronym (comma / &(end) / &(period)) !((C u))))? ((C u))?)</TT><P>

This is the previous class encapsulated as a word.<p>

<TT>
mex <- (__LWinit NI !(connective))</TT><P>

<H3> the little word <B>ci</B> </H3>

This word has a number of independent uses as a very tightly binding verbal hyphen.  It is also a name marker due to its role in serial names.<p>



<TT>
CI <- (__LWinit (C i) !(connective))</TT><P>

<H3> Acronyms </H3>

This is the basic acronym construction, used to build acronyms as dimensions (seen above) and as names [not predicates as in 1989 Loglan]. <B>mue</B> is allowed as an initial component of an acronym.  An acronym starts with an atomic letter name or a form <B>z</B>V (never followed by a vowel) and continues with further units which may be atomic letter names, zV units (never followed by vowels), or <TT>NI1</TT> numeral units.  There are always at least two units (<B>mue</B> makes one-letter or numeral-initial acronyms possible).  The V units allowed in 1989 Loglan have been eliminated.<p>

NOTE:  I think the segment <TT>([Zz] V2 (!(V2) / ([Zz] &(V2))))))+)</TT> needs repair.<p>


<TT>
Acronym <- (([ ])* &(caprule) ((M UE) / TAI0 / ([Zz] V2 !(V2))) (((comma &(Acronym) M UE) / NI1 / TAI0 / ([Zz] V2 (!(V2) / ([Zz] &(V2))))))+)</TT><P>


<H3> Pronouns </H3>

The most general form of letter names.  There is an extra construction here allowing formation of foreign letter names by prefixing <TT>gao</TT> to words of quite general forms (including name words, so <TT>gao</TT> is a name marker).<p>


<TT>
TAI <- (__LWinit (TAI0 / ((G AO) !(badspaces) !(V2) ([ ])* (Name / Predicate / (C1 V2 V2 (!(Oddvowel) / &(TAI0))) / (C1 V2 (!(Oddvowel) / &(TAI0)))))) !(connective))</TT><P>

Atomic pronouns other than letters.<p>


<TT>
DA0 <- ((T AO) / (T IO) / (T UA) / (M IO) / (M IU) / (M UO) / (M UU) / (T OA) / (T OI) / (T OO) / (T OU) / (T UO) / (T UU) / (S UO) / (H u) / (B a) / (B e) / (B o) / (B u) / (D a) / (D e) / (D i) / (D o) / (D u) / (M i) / (T u) / (M u) / (T i) / (T a) / (M o))</TT><P>



Pronouns in general:  these are atomic letters or atomic pronouns, optionally suffixed with <B>ci</B> followed by a digit.  NOTE:  should general letters of class <TT>TAI</TT> be allowed?<p>


<TT>
DA1 <- ((TAI0 / DA0) ((C i !([ ]) NI0))?)</TT><P>

The previous class encapsulated as a word.<p>


<TT>
DA <- (__LWinit DA1 !(connective))</TT><P>

<H3> Tenses, locations and modifiers</H3>

Atomic tense, location, and modifier words (prepositions, as it were).  The causal and comparative words are included when not followed by <B>noi</B> or <B>ki</B>.<p>


<TT>
PA0 <- (((N u !(KOU)))? ((G IA) / (G UA) / (P AU) / (P IA) / (P UA) / (N IA) / (N UA) / (B IU) / (F EA) / (F IA) / (F UA) / (V IA) / (V II) / (V IU) / (C OI) / (D AU) / (D II) / (D UO) / (F OI) / (F UI) / (G AU) / (H EA) / (K AU) / (K II) / (K UI) / (L IA) / (L UI) / (M IA) / (N UI) / (P EU) / (R OI) / (R UI) / (S EA) / (S IO) / (T IE) / (V a) / (V i) / (V u) / (P a) / (N a) / (F a) / (V a) / (KOU !((N OI)) !(KI))) ((N OI))?)</TT><P>

A prepositional word without internal pauses except possibly next to internal logical connective units.
This consists of blocks of atomic prepositional words, possibly linked with <TT>CA0</TT> logical connective units, optionally closed with a class <TT>ZI</TT> affix.<p>


<TT>
PANOPAUSES <- (((!(PA0) NI))? ((KOU2 / PA0))+ ((((comma2)? CA0 (comma2)?) ((KOU2 / PA0))+))* (ZI)?)</TT><P>

The previous class encapsulated as a word.  Prepositional words used as prepositions take this form.<p>

<TT>
PA3 <- (__LWinit PANOPAUSES !(connective))</TT><P>

Compound prepositional words admitting pauses between prepositional units.  These can be used only as
tenses.<p>

<TT>
PA <- (((!(PA0) NI))? ((KOU2 / PA0))+ (((((comma2)? CA0 (comma2)?) / (comma2 !(mod1a))) ((KOU2 / PA0))+))* (ZI)?)</TT><P>

The previous class encapsulated as a word.


<TT>
PA2 <- (__LWinit PA !(connective))</TT><P>

The little word <B>ga</B> used as a null tense.<p>


<TT>
GA <- (__LWinit (G a) !(connective))</TT><P>

The class of tenses.<p>


<TT>
GAA <- (__LWinit (G AA) !(connective))</TT><P>

Marker for afterthought closure of complex subjects.  A feature of the alternative parser.<p>


<TT>
PA1 <- ((PA2 / GA) !(connective))</TT><P>

Affixes which can be used to terminate compound prepositional words.<p>


<TT>
ZI <- ((Z i) / (Z a) / (Z u))</TT><P>

<H3> Articles </H3>

These are the general-purpose articles.  <B>la</B> is also the standard name marker, but may be used as an article
with predicates as well.<p>


<TT>
LE <- (__LWinit ((L EA) / (L EU) / (L OE) / (L EE) / (L AA) / (L e) / (L o) / ((L a) !(badspaces))) !(connective))</TT><P>

The class of article for construction of abstract descriptions.  These include
quantifiers.<p>

NOTE:  should possessive and relative modification of these be allowed as for <TT>LE</TT>?

<TT>
LEFORPO <- (__LWinit ((L e) / (L o) / NI2) !(connective))</TT><P>

The article for numeric descriptions.<p>


<TT>
LIO <- (__LWinit (L IO) !(connective))</TT><P>

Constructors for explicit ordered and unordered sets.  The first two forms are initial (opening braces), the second two are final (closing braces) and the third two are medial (commas).  The commas are new.<p>


<TT>
LAU <- (__LWinit (L AU) !(connective))</TT><P>
<TT>
LOU <- (__LWinit (L OU) !(connective))</TT><P>
<TT>
LUA <- (__LWinit (L UA) !(connective))</TT><P>
<TT>
LUO <- (__LWinit (L UO) !(connective))</TT><P>
<TT>
ZEIA <- (__LWinit Z EI a !(connective))</TT><P>
<TT>
ZEIO <- (__LWinit Z EI o !(connective))</TT><P>

<H3> Alien text forms </H3>

The opening and closing markers for quoted Loglan text.<p>


<TT>
LI1 <- (L i)</TT><P>
<TT>
LU1 <- (L u)</TT><P>

The optional markers for textual or verbal quotation.  Some deprecate these.<p>


<TT>
Quotemod <- ((Z a) / (Z i))</TT><P>

The construction for quoted Loglan text.  Complete Loglan utterances or Loglan name words can be quoted.  A style in which commas appear bracketing the closing text, found in our sources, is supported but not required.<p>


<TT>
LI <- ((__LWinit LI1 !(V2) (Quotemod)? ((([,])? ([ ])+))? utterance0 (', ')? __LWinit LU1 !(connective)) / (__LWinit LI1 !(V2) (Quotemod)? comma name (comma)? __LWinit LU1 !(connective)))</TT><P>


The general construction for alien text to be included in Loglan text.  A block of such text may include any characters in its body except for spaces; commas or terminal punctuation in final position will not be read as part of the block.  It may begin or end with a comma pause (included in it by the parser).  It will be followed either by spaces followed by a letter or by end of text or terminal punctuation.  Alien text may include more than one block, separated by the little word <B>y</B>, only the last one possibly closed with a comma pause.  Phonetically, the pronunciation of alien text is not prescribed by Loglan, but each block must be preceded and followed by an actual pause, whether it is written or not, and there should be no pauses internal to blocks.<p>

This is based on a solution for handling Linnaean names with more than one block of text described in L1, except that we require that the <B>y</B> be written.<p>

<TT>
stringnospaces <- (([,])? (([ ])+ ((!((([,])? [ ])) !(period) .))+) ((([,])? ([ ])+ &(letter)) / &(period) / &(end)))</TT><P>
<TT>
stringnospacesclosed <- (([,])? (([ ])+ ((!((([,])? [ ])) !(period) .))+) (([,] ([ ])+) / &(period) / &(end)))</TT><P>
<TT>
stringnospacesclosedblock <- ((stringnospaces ((!(([y] stringnospacesclosed)) [y] stringnospaces))* ([y] stringnospacesclosed)) / stringnospacesclosed)</TT><P>

This is the construction for foreign names (originally Linnaean names from biology, but Steve Rice pointed out the more general usefulness of the construction):  the article <B>lao</B> is followed by alien text.<p>

Foreign names must be followed by pauses in speech (and at least whitespace in text), but the parser does not require a terminal comma on a foreign name.<p>


<TT>
LAO1 <- (L AO)</TT><P>
<TT>
LAO <- (([ ])* (LAO1 stringnospaces (([y] stringnospaces))*))</TT><P>

This is the strong quotation construction, completely different from the 1989 Loglan construction for strong quotation.  Instead, it is formally isomorphic to foreign names:  the article <B>lie</B> is followed by a block of alien text.  Notice that when quoting a text containing pauses, one must insert <B>y</B> between the pause-separated blocks of the quoted text.<p>


<TT>
LIE1 <- (L IE)</TT><P>
<TT>
LIE <- (([ ])* (LIE1 (Quotemod)? stringnospaces (([y] stringnospaces))*))</TT><P>

The arrangements for word quotation follow.  <TT>LW</TT> is the actual class of cmapua as defined
in Notebook 3.  It is telling that this is the only place that this class is actually needed by the parser
(in quoting cmapua).  In LIP it may not have been used at all, as LIP seems to allow <B>liu</B> to quote
only actual cmapua.<p>

Words are quoted using <B>liu</B> or <B>niu</B> (the latter may be used to signal that the word quoted is not actually a Loglan word).  The quoted items must be cmapua (which must often be closed by an explicit comma pause), name words, predicate words or djifoa.  Letter names can be quoted with <B>lii</B>.<p>


<TT>
LW <- (&(caprule) (((!(Predicate) V2 V2))+ / ((!(Predicate) (V2)? ((!(Predicate) LWunit))+) / V2)))</TT><P>
<TT>
LIU0 <- ((L IU) / (N IU))</TT><P>
<TT>
LIU1 <- (__LWinit ((LIU0 !(badspaces) !(V2) (Quotemod)? ((([,])? ([ ])+))? (Name / (Predicate (comma)?) / (CCV (comma)?) / (LW (([,] ([ ])+ !([,])) / &(period) / &(end) / &((([ ])* Predicate)))))) / (L II (Quotemod)? TAI !(connective))))</TT><P>

These are the imported foreign predicates (<B>sao</B>) and onomatopoeic predicates (<B>sue</B>) which are formed by following the appropriate particle with a single block of alien text.<p>

<TT>
SUE <- (__LWinit ((S UE) / (S AO)) stringnospaces)</TT><P>

<H3>Spoken punctuation of various kinds</H3>

Used as a left closure for metaphor grouping in predicate phrases.<p>


<TT>
CUI <- (__LWinit (C UI) !(connective))</TT><P>

The form of <B>ga</B> used in the "gasent" sentence construction to mark the subject.<p>

<TT>
GA2 <- (__LWinit (G a) !(connective))</TT><P>

A general left closure marker for many constructions.<p>


<TT>
GE <- (__LWinit (G e) !(connective))</TT><P>

A right closure marking for metaphor grouping in predicate phrases.   Still admits the form <B>cue</B> found in L1 but later revised to <B>geu</B><p>


<TT>
GEU <- (__LWinit ((C UE) / (G EU)) !(connective))</TT><P>

A marker for fronted arguments in one of the sentence forms.<p>


<TT>
GI <- (__LWinit ((G i) / (G OI)) !(connective))</TT><P>

A marker for delayed initial predicates in metaphor grouping.<p>


<TT>
GO <- (__LWinit (G o) !(connective))</TT><P>

A marker for second and further arguments appearing before the predicate (new).<p>


<TT>
GIO <- (__LWinit (G IO) !(connective))</TT><P>

The general spoken right closure.<p>

<TT>
GU <- (__LWinit (G u) !(connective))</TT><P>

spoken right closure for subordinate clauses formed with JI or JIO.  distinct versions
pair with distinct closure markers given below, a device to avoid the need for multiple
closures, if care is taken.<p>


<TT>
GUIZA <- (__LWinit (G UI) (Z a) !(connective))</TT><P>
<TT>
GUIZI <- (__LWinit (G UI) (Z i) !(connective))</TT><P>
<TT>
GUIZU <- (__LWinit (G UI) (Z u) !(connective))</TT><P>
<TT>
GUI <- (!(GUIZA) !(GUIZI) !(GUIZU) (__LWinit (G UI) !(connective)))</TT><P>

spoken right closures for abstract predicates and abstract and event descriptions.<p>

The second and further ones are part of a new proposal.<p>

<TT>
GUO <- (__LWinit (G UO) !(connective))</TT><P>
<TT>
GUOA <- (__LWinit (G UO (Z)? a) !(connective))</TT><P>
<TT>
GUOE <- (__LWinit (G UO e) !(connective))</TT><P>
<TT>
GUOI <- (__LWinit (G UO (Z)? i) !(connective))</TT><P>
<TT>
GUOO <- (__LWinit (G UO o) !(connective))</TT><P>
<TT>
GUOU <- (__LWinit (G UO (Z)? u) !(connective))</TT><P>

The spoken right closure for term lists.<p>


<TT>
GUU <- (__LWinit (G UU) !(connective))</TT><P>

New closer introduced 5/9, for arguments in certain contexts.<p>


<TT>
GUUA <- (__LWinit (G UU a) !(connective))</TT><P>

New closer introduced 5/9, for sentences in certain contexts.<p>


<TT>
GIUO <- (__LWinit (G IU o) !(connective))</TT><P>

The spoken right closure for tightly bound term constructions with JE and JUE.<p>


<TT>
GUE <- (__LWinit (G UE) !(connective))</TT><P>

New closer introduced 5/9, for descriptive predicates in certain contexts.<p>


<TT>
GUEA <- (__LWinit (G UE a) !(connective))</TT><P>

<H3>Clause formers and tightly linked argument formers</H2>

Markers for tightly bound terms.<p>


<TT>
JE <- (__LWinit (J e) !(connective))</TT><P>
<TT>
JUE <- (__LWinit (J UE) !(connective))</TT><P>

Markers for subordinate clauses.  New flavors have been added to match new closers, in a bid
to minimize the need for multiple closures.<p>

<TT>
JIZA <- (__LWinit ((J IE) / (J AE) / (P e) / (J i) / (J a) / (N u J i)) (Z a) !(connective))</TT><P>
<TT>
JIOZA <- (__LWinit ((J IO) / (J AO)) (Z a) !(connective))</TT><P>
<TT>
JIZI <- (__LWinit ((J IE) / (J AE) / (P e) / (J i) / (J a) / (N u J i)) (Z i) !(connective))</TT><P>
<TT>
JIOZI <- (__LWinit ((J IO) / (J AO)) (Z i) !(connective))</TT><P>
<TT>
JIZU <- (__LWinit ((J IE) / (J AE) / (P e) / (J i) / (J a) / (N u J i)) (Z u) !(connective))</TT><P>
<TT>
JIOZU <- (__LWinit ((J IO) / (J AO)) (Z u) !(connective))</TT><P>
<TT>
JI <- (!(JIZA) !(JIZI) !(JIZU) (__LWinit ((J IE) / (J AE) / (P e) / (J i) / (J a) / (N u J i)) !(connective)))</TT><P>
<TT>
JIO <- (!(JIOZA) !(JIOZI) !(JIOZU) (__LWinit ((J IO) / (J AO)) !(connective)))</TT><P>

<H3> Case tags </H3>

Case tags proper.<p>


<TT>
DIO <- (__LWinit ((B EU) / (C AU) / (D IO) / (F OA) / (K AO) / (J UI) / (N EU) / (P OU) / (G OA) / (S AU) / (V EU) / (Z UA) / (Z UE) / (Z UI) / (Z UO) / (Z UU)) !(connective))</TT><P>

Markers of indirect reference, which had the same grammar as case tags in 1989 Loglan but somewhat different grammar here.<p>


<TT>
LAE <- (__LWinit ((L AE) / (L UE)) !(connective))</TT><P>

<H3>Operators on predicates</H3>

Convert an argument to a predicate.  We regard <B>mea</B> as entirely redundant.<p>


<TT>
ME <- (__LWinit ((M EA) / (M e)) !(connective))</TT><P>

Closer for ME predicates, new.<p>

<TT>
MEU <- (__LWinit M EU !(connective))</TT><P>

Conversion and reflexive operators (change order of arguments or identify two of them).  There are two rules because a digit may be suffixed.<p>


<TT>
NU0 <- ((N UO) / (F UO) / (J UO) / (N u) / (F u) / (J u))</TT><P>
<TT>
NU <- (__LWinit ((NU0 !((([ ])+ (NI0 / RA))) ((NI0 / RA))? (freemod)?))+ !(connective))</TT><P>

Operators for construction of abstract predicates and descriptions.  The second and further ones are parts of a new proposal.<p>


<TT>
PO1 <- (__LWinit ((P o) / (P u) / (Z o)))</TT><P>
<TT>
PO1A <- (__LWinit ((P OI a) / (P UI a) / (Z OI a) / (P o Z a) / (P u Z a) / (Z o Z a)))</TT><P>
<TT>
PO1E <- (__LWinit ((P OI e) / (P UI e) / (Z OI e)))</TT><P>
<TT>
PO1I <- (__LWinit ((P OI i) / (P UI i) / (Z OI i) / (P o Z i) / (P u Z i) / (Z o Z i)))</TT><P>
<TT>
PO1O <- (__LWinit ((P OI o) / (P UI o) / (Z OI o)))</TT><P>
<TT>
PO1U <- (__LWinit ((P OI u) / (P UI u) / (Z OI u) / (P o Z u) / (P u Z u) / (Z o Z u)))</TT><P>

Short scope forms of <B>po</B> and its relatives.<p>


<TT>
POSHORT1 <- (__LWinit ((P OI) / (P UI) / (Z OI)))</TT><P>

The above classes packaged as words.<p>


<TT>
PO <- (__LWinit PO1 !(connective))</TT><P>
<TT>
POA <- (__LWinit PO1A !(connective))</TT><P>
<TT>
POE <- (__LWinit PO1E !(connective))</TT><P>
<TT>
POI <- (__LWinit PO1E !(connective))</TT><P>
<TT>
POO <- (__LWinit PO1O !(connective))</TT><P>
<TT>
POU <- (__LWinit PO1U !(connective))</TT><P>
<TT>
POSHORT <- (__LWinit POSHORT1 !(connective))</TT><P>

<H3>Free modifier constructors</H3>

Register markers.<p>


<TT>
DIE <- (__LWinit ((D IE) / (F IE) / (K AE) / (N UE) / (R IE)) !(connective))</TT><P>

Vocative forming operators.  These include the greeting words, for us.  The word <B>sie</B> (sorry, with the intention of apology) is new.  Unmarked vocatives (simple uses of a name word as a free modifier) are now forbidden.<p>


<TT>
HOI <- (__LWinit ((H OI) / (L OI) / (L OA) / (S IA) / (S IE) / (S IU)) !(connective))</TT><P>

The "scare quotes" operator.  It has a numerical suffix to indicate the number of words in its scope.<p>


<TT>
JO <- (__LWinit ((NI0 / RA))? (J o) !(connective))</TT><P>

Spoken parentheses to create a parenthetical remark.<p>


<TT>
KIE <- (__LWinit (K IE) !(connective))</TT><P>
<TT>
KIU <- (__LWinit (K IU) !(connective))</TT><P>

The spoken "smilie" constructor.<p>


<TT>
SOI <- (__LWinit (S OI) !(connective))</TT><P>

A list of free modifier words (attitudinals) including most of the VV words.<p>

Notice that NOUI is phonetically irregular:  a "word" like <B>noia</B> has the vowels grouped in an unexpected way and also has the o in a CV syllable followed by a vowel.  Normally a pause would be forced; this is overridden.<p>

<TT>
UI0 <- (!(Predicate) (UA / UE / UI / UO / UU / OA / OE / OI / OU / OO / IA / II / IO / IU / EA / EE / EI / EO / EU / AA / AE / AI / AO / AU / (B EA) / (B UO) / (C EA) / (C IA) / (C OA) / (D OU) / (F AE) / (F AO) / (F EU) / (G EA) / (K UO) / (K UU) / (R EA) / (N AO) / (N IE) / (P AE) / (P IU) / (S AA) / (S UI) / (T AA) / (T OE) / (V OI) / (Z OU) / (L OI) / (L OA) / (S IA) / (S II) / (T OE) / (S IU) / (C AO) / (C EU) / (S IE) / (S EU)))</TT><P>
<TT>
NOUI <- ((__LWinit N [o] (juncture)? ([ ])* UI0 !(connective)) / (__LWinit UI0 NOI !(connective)))</TT><P>

The above class and the words like <B<tofi</B>, "secondly", packaged as words.<p>

<TT>
UI1 <- (__LWinit (UI0 / (NI F i)) !(connective))</TT><P>

The inverse vocative constructor.<p>

<TT>
HUE <- (__LWinit (H UE) !(connective))</TT><P>

<H3> Negation </H3>

All occurrences of the <B>no</B> of negation as an independent word.<p>


<TT>
NO1 <- (__LWinit !(KOU1) !(NOUI) (N o) !((__LWinit KOU)) !((([ ])* (JIO / JI / JIZA / JIOZA / JIZI / JIOZI / JIZU / JIOZU))) !(connective))</TT><P>

<H3> The large word classes </H3>

Name words.  These include the acronymic names, as noted above.<p>


<TT>
AcronymicName <- (Acronym (&(end) / ',' / &(period) / &(Name) / &(CI)))</TT><P>
<TT>
DJAN <- (Name / AcronymicName)</TT><P>

Predicate words in the grammatical sense.  These include some phonetic cmapua as indicated.  The identity predicates <TT>BI</TT> are a separate word class, actually.  The other phonetic cmapua are either listed in <TT>LWPREDA</TT> or are numerical predicates <TT>NI RA</TT>, and are included in the class <TT>PREDA</TT> of predicate words, at the grammar level if not phonetically.<p>


<TT>
BI <- (__LWinit ((N u))? ((B IA) / (B IE) / (C IE) / (C IO) / (B IA) / (B [i])) !(connective))</TT><P>
<TT>
LWPREDA <- ((H e) / (D UA) / (D UI) / (B UA) / (B UI))</TT><P>
<TT>
PREDA <- (([ ])* &(caprule) (Predicate / LWPREDA / (!([ ]) NI RA)) !(connective))</TT><P>

<H2>Grammar</H2>

<H3>Closing forms</H3>

Right closure words listed above packaged for grammatical use.  They may be preceded by pauses;
each right closure form may be expressed as <B>gu</B> as well as in its full <B>guV</B> (or other) form if it succeeds in closing the right sort of thing in the context where it is used.  They may further be followed by free modifiers.<p>


<TT>
guoa <- ((PAUSE)? (GUOA / GU) (freemod)?)</TT><P>
<TT>
guoe <- ((PAUSE)? (GUOE / GU) (freemod)?)</TT><P>
<TT>
guoi <- ((PAUSE)? (GUOI / GU) (freemod)?)</TT><P>
<TT>
guoo <- ((PAUSE)? (GUOO / GU) (freemod)?)</TT><P>
<TT>
guou <- ((PAUSE)? (GUOU / GU) (freemod)?)</TT><P>
<TT>
guo <- (!(guoa) !(guoi) !(guou) ((PAUSE)? (GUO / GU) (freemod)?))</TT><P>
<TT>
guiza <- ((PAUSE)? (GUIZA / GU) (freemod)?)</TT><P>
<TT>
guizi <- ((PAUSE)? (GUIZI / GU) (freemod)?)</TT><P>
<TT>
guizu <- ((PAUSE)? (GUIZU / GU) (freemod)?)</TT><P>
<TT>
gui <- ((PAUSE)? (GUI / GU) (freemod)?)</TT><P>
<TT>
gue <- ((PAUSE)? (GUE / GU) (freemod)?)</TT><P>
<TT>
guea <- ((PAUSE)? (GUEA / GU) (freemod)?)</TT><P>
<TT>
guu <- ((PAUSE)? (GUU / GU) (freemod)?)</TT><P>
<TT>
guua <- ((PAUSE)? (GUUA / GU) (freemod)?)</TT><P>
<TT>
giuo <- ((PAUSE)? (GIUO / GU) (freemod)?)</TT><P>
<TT>
meu <- ((PAUSE)? (MEU / GU) (freemod)?)</TT><P>

The next one does not take the form <B>gu</B>.<p>

<TT>
geu <- GEU</TT><P>

This packaged form of general <B>gu</B> does not include the alternative form PAUSE found in 1989 Loglan.  Pause/<B>gu</B> equivalence is not implemented.<p>


<TT>
gap <- ((PAUSE)? GU (freemod)?)</TT><P>

<H3>Tightly bound argument lists</H3>

Arguments or modifiers following the predicate may be tightly bound to it.  The basic form is <B>je</B> (argument or modifier), for a first term after the predicate, and <B>jue</B> (argument or modifier) (<B>gue</B>) for second and further terms after the predicate.  A sequence of such arguments can optionally be closed with <B>gue</B>.  Sequences of such arguments can be linked with forethought or afterthought logical or causal connectives.<p>

<TT>
juelink <- (JUE (freemod)? (term / (PA2 (freemod)? (gap)?)))</TT><P>
<TT>
links1 <- (juelink (((freemod)? juelink))* (gue)?)</TT><P>
<TT>
links <- ((links1 / (KA (freemod)? links (freemod)? KI (freemod)? links1)) (((freemod)? A1 (freemod)? links1))*)</TT><P>
<TT>
jelink <- (JE (freemod)? (term / (PA2 (freemod)? (gap)?)))</TT><P>
<TT>
linkargs1 <- (jelink (freemod)? ((links / gue))?)</TT><P>
<TT>
linkargs <- ((linkargs1 / (KA (freemod)? linkargs (freemod)? KI (freemod)? linkargs1)) (((freemod)? A1 (freemod)? linkargs1))*)</TT><P>

<H3>Simpler predicate forms</H3>

Abstraction predicates.  These predicates are built from sentences of general forms and have full syntactical privileges, which was not the case in the grammar of 1989 Loglan, in which an abstraction predicate build from a complex sentence could not participate in any construction of more complicated predicate expressions:  it could not even be tensed.  The abstraction predicate is optionally closed with <B>guo</B>.  Note that there is an entire series of different matching openers and closers for abstractions which can be used to allow more supple handling of nested expressions of this kind; this is expected to be used more in the case of abstract descriptions.<p>


<TT>
abstractpred <- ((POA (freemod)? uttAx (guoa)?) / (POA (freemod)? sentence (guoa)?) / (POE (freemod)? uttAx (guoe)?) / (POE (freemod)? sentence (guoe)?) / (POI (freemod)? uttAx (guoi)?) / (POI (freemod)? sentence (guoi)?) / (POO (freemod)? uttAx (guoo)?) / (POO (freemod)? sentence (guoo)?) / (POU (freemod)? uttAx (guou)?) / (POU (freemod)? sentence (guou)?) / (PO (freemod)? uttAx (guo)?) / (PO (freemod)? sentence (guo)?))</TT><P>

Predicates which are in a sense atomic.  These include the foreign and onomatopoeic predicates constructed from alien text, simple predicate words optionally converted by being prefixed with <TT>NU</TT>, predicates of class <TT>despredE</TT> enclosed in <B>ge</B>...(<B>geu</B>), optionally converted with prefixed <TT>NU</TT>, abstraction predicates as just described above, and expressions <TT>ME</TT> argument (<TT>MEU</TT>).<P>


<TT>
predunit1 <- ((SUE / (NU (freemod)? GE (freemod)? despredE (((freemod)? geu (comma)?))?) / (NU (freemod)? PREDA) / ((comma)? GE (freemod)? descpred (((freemod)? geu (comma)?))?) / abstractpred / (ME (freemod)? argument1 (meu)?) / PREDA) (freemod)?)</TT><P>

Possibly multiply negated instances of the previous class.<p>


<TT>
predunit2 <- (((NO1 (freemod)?))* predunit1)</TT><P>

Instances of the <B>no</B> of negation which are independent words and which do not negate a following
<TT>predunit1</TT>.<p>


<TT>
NO2 <- (!(predunit2) NO1)</TT><P>

An instance of the previous class optionally followed by tightly bound arguments.<p>

<TT>
predunit3 <- ((predunit2 (freemod)? linkargs) / predunit2)</TT><P>

An instance of the previous class or an instance of the previous class converted to an abstraction predicate by being prefixed with short-scope <TT>POSHORT</TT>.  New words <B>poi</B>, <B>pui</B>, <B>zoi</B> have the short scope abstraction function.<p>


<TT>
predunit <- (((POSHORT (freemod)?))? predunit3)</TT><P>

Forethought connected predicates of the most complex kind.  These are also viewed as in a sense atomic.  Note that they can be closed with GUU so as to serve as heads of metaphors.<p>

<TT>
kekpredunit <- (((NO1 (freemod)?))* KA (freemod)? predicate (freemod)? KI (freemod)? predicate (guu)?)</TT><P>

Instances of predunit and kekpredunit linked with <B>ci</B> if there are more than one of them.  This is tightly bound metaphorical modification of predicates.<p>


<TT>
despredA <- ((predunit / kekpredunit) (((freemod)? CI (freemod)? (predunit / kekpredunit)))*)</TT><P>


The result of prepending zero or more (<B>cui</B> <TT>despredC  CA</TT>)'s to an instance of the previous class.<p>


<TT>
despredB <- ((!(PREDA) CUI (freemod)? despredC (freemod)? CA (freemod)? despredB) / despredA)</TT><P>

A simple chain of one or more <TT>despredB</TT>'s:  more loosely bound metaphorical predicate modification.  Note that semantically it groups to the left.<p>

<TT>
despredC <- (despredB (((freemod)? despredB))*)</TT><P>

A sequence of one or more <TT>despredB</TT>'s linked by <TT>CA</TT> connectives (if there are more than one)<p>

<TT>
despredD <- (despredB (((freemod)? CA (freemod)? despredB))*)</TT><P>

A simple chain of <TT>despredD</TT>'s:  this is again a metaphorical modification of predicates, grouping to the left semantically.<p>


<TT>
despredE <- (despredD (((freemod)? despredD))*)</TT><P>

A <TT>despredE</TT> metaphorically modified by a <TT>descpred</TT> following it, marked with <B>go</B>.  This is the kind of predicate which follows a <TT?LE</TT> article to form a description.<p>


<TT>
descpred <- ((despredE (freemod)? GO (freemod)? descpred) / despredE)</TT><P>

The following simple sentence predicate class differs from the simple description predicate class <TT>descpred</TT> only in that a modifier optionally appended with <B>go</B> is of the looser
<TT>barepred</TT> class which can have arguments attached which are not tightly bound with <TT>JE/JUE</TT> links.<p>

<TT>
sentpred <- ((despredE (freemod)? GO (freemod)? barepred) / despredE)</TT><P>

<H3>Modifiers</H3>

This section describes the general construction of sentence modifiers (relative clauses). 
The basic forms are PA3 argument (guua) and PA2 (gap), where the latter is not followed by a barepred (so it is not a tense).  Recall that PA3 is the class of PA words without pauses between PA0 units, while PA2 allows such pauses.  There are reasons for this which can be illustrated with examples.<p>

Further, sentence modifiers can be linked with forethought and afterthought logical and causal connectives in a sensible way.<p>


<TT>
mod1a <- (PA3 (freemod)? argument1 (guua)?)</TT><P>
<TT>
mod1 <- ((PA3 (freemod)? argument1 (guua)?) / (PA2 (freemod)? !(barepred) (gap)?))</TT><P>
<TT>
kekmod <- (((NO1 (freemod)?))* (KA (freemod)? modifier (freemod)? KI (freemod)? mod))</TT><P>
<TT>
mod <- (mod1 / (((NO1 (freemod)?))* mod1) / kekmod)</TT><P>
<TT>
modifier <- (mod ((A1 (freemod)? mod))*)</TT><P>

<H3>Name resolution and serial names</H3>

This section deals with the construction of complex names.  It contains my solution to the false name marker problem.<p>

This is a place at which it is possible but not certain that a phonetic pause occurs (a space between a vowel and a consonant).<p>


<TT>
maybebreak <- (V1 (stress)? ' ' !((([ ])* V1)))</TT><P>

This is a documented break in the flow of speech.<p>


<TT>
realbreak <- (!(maybebreak) letter (stress)? ((([,])? ' ') / period / &(end)))</TT><P>

This is a break in the flow of speech following a consonant.<p>

<TT>
consonantbreak <- (C1 (stress)? ((([,])? ' ') / period / &(end)))</TT><P>

This is a situation in which there is not an immediately following pause and there are <TT>maybebreak</TT>s and no <TT>realbreak</TT>s between the present position and a following <TT>consonantbreak</TT>.<p>

<TT>
badspaces <- (!(([,] ' ')) ((!((maybebreak / realbreak)) .))* maybebreak ((!(realbreak) .))* consonantbreak)</TT><P>

These are the name marker words.  A name word may appear without a leading pause only after one of these.  A name marker is required not be be followed by <TT>badspaces</TT>:  that is, there must be a pause following it immediately or there must be no possible but uncertain pauses between it and a following pause after a consonant:  the problem is that if none of these pauses are real, it would be the case that the entire phrase up to that distant consonant break, clearly not intended to be a name word, would be heard as a name word.<P>

NOTE:  <B>niu</B> should be added to this list.<p>


<TT>
namemarker <- ((([ ])* ((L a) / (H OI) / (L OI) / (L OA) / (S IE) / (S IA) / (S IU) / (C i) / (H UE) / (L IU) / (G AO))) !(badspaces))</TT><P>

The class of names which contain no phonetic string looking like a name marker word and followed by a valid name word.  Name words not in this class are the name words which contain false name markers.<p>



<TT>
nonamemarkers <- (([ ])* ((!((namemarker Name)) Letter))+ !(Letter))</TT><P>

This is <B>ci</B> used as a name marker.<p>

<TT>
CI0 <- ([Cc] i &((([ ])* C1)))</TT><P>

This is the serial name construction.  A serial name is a chain of name words and predunits in which all predunits are marked with <B>ci</B>, anything following a predunit is marked with <B>ci</B>, and any name which contains a false name marker is marked with <B>ci</B>.<p>


<TT>
name <- (DJAN (((CI0 DJAN) / (CI !(badspaces) (comma)? predunit !((&(nonamemarkers) Name))) / (CI (comma)? DJAN) / (&(nonamemarkers) Name)))* (freemod)?)</TT><P>

This is <B>la</B> used as a name marker.<p>


<TT>
LA0 <- (([Ll] a) !(badspaces))</TT><P>

<B>la</B> without a pause followed by something which can be read as a name word is preferred to be read as such.  Notice that for this to happen the name word must be consonant-initial or CANCELPAUSE must be used.<p>


<TT>
LANAME <- (([ ])* LA0 (CANCELPAUSE / (([ ])* &(C1))) name)</TT><P>

<B>la</B> followed by an explicit pause followed by something which can be read as a name word will be parsed as such only if it is not parsed as a description in a different way.<p>

<TT>
LANAME2 <- (([ ])* LA0 ((',' ([ ])+) / (([ ])* &(V1))) name)</TT><P>

<H3>Vocatives</H3>

Here is the construction of vocatives.  Note that the use of an unmarked name as a vocative and therefore a free modifier was outlawed; this was a major cause of false name marker issues.  The first class is <B>hoi</B> used as a name marker.  The second is the vocative class itself.  By preference, one first reads <B>hoi</B> or kin followed without pause (or with cancelled pause) by a name word; then one tries to read <B>hoi</B> or kin followed by a descriptive predicate (which possibly has a name appended to it), then one tries to read
<B>hoi</B> or kin followed by an argument, then one tries to read <B>hoi</B> or kin followed by a pause
followed by a name word, then one tries to read <B>hoi</B> (exactly, not one of its kin) followed by a foreign name, which must be closed by a comma, terminal punctuation, or end of text.<p>


<TT>
HOI0 <- ((([Hh] OI) / ([Ll] OI) / ([Ll] OA) / ([Ss] IA) / ([Ss] IE) / ([Ss] IU)) !(badspaces))</TT><P>
<TT>
voc <- ((([ ])* HOI0 (CANCELPAUSE / (([ ])* &(C1))) name) / (HOI !(badspaces) (freemod)? descpred (guea)? (((((comma)? CI (comma)?) / (comma &(nonamemarkers) !(AcronymicName))) name))?) / (HOI !(badspaces) (freemod)? argument1 (guua)?) / (([ ])* HOI0 ((',' ([ ])+) / (([ ])* &(V1))) name) / (H OI stringnospacesclosedblock))</TT><P>

<H3>Arguments</H3>

We now present the quite complex analysis of arguments.<p>

First is a basic class of constructions with articles.  First we have the constructions of explicit ordered and unordered lists.  Then we have basic constructions with the class of <TT>LE</TT> articles.  Each of these begins with a <TT>LE</TT> article, optionally followed by an argument of class <TT>arg1a</TT> (playing the role of a possessive), optionally followed by a <TT>PA2</TT> tense, optionally followed by a <TT>mex</TT> quantifier, followed by either a <TT>descpred</TT> descriptive predicate or an <TT>arg1a</TT> argument (in this last case the <TT>mex</TT> component must appear).<p>

There is a novelty here.  In 1989 Loglan, <B>lemi hasfa</B> and <B>le la Djan, hasfa</B> were not instances of the same construction.  In the first, <B>lemi</B> was parsed as a <TT>LE</TT> word.  <B>lemi</B> is no longer a <TT>LE</TT> word, and the grammar of these two assertions is the same.  By analogy with the 1989 Loglan word <N>lemina</B>, this rule allows arguments like <B>le la Djan, na hasfa</B>, "John's present house".<p>


<TT>
descriptn <- (!(LANAME) ((LAU wordset1) / (LOU wordset2) / (LE (freemod)? ((((!(mex) arg1a (freemod)?))? ((PA2 (freemod)?))?))? mex (freemod)? descpred) / (LE (freemod)? ((((!(mex) arg1a (freemod)?))? ((PA2 (freemod)?))?))? mex (freemod)? arg1a) / (GE (freemod)? mex (freemod)? descpred) / (LE (freemod)? ((((!(mex) arg1a (freemod)?))? ((PA2 (freemod)?))?))? descpred)))</TT><P>

Abstraction and event descriptions.  Multiple allowed openers and closers allow us to close multiple nested
abstract descriptions with one closer with proper planning.  Note that a <TT>LEFORPO PO (sentence) (GUO)</TT> does <B>not</B> contain a <TT>PO (sentence) (GUO)</TT> substructure:  these are two independent constructions.
Where a <TT>LE</TT> article is applied to a (<TT>PO</TT> predicate) modifying another argument, the (<TT>PO</TT> predicate) should be prefixed with <B>ge</B> to avoid accidental formation of an abstract description.  The distinction between abstract predicates and abstract descriptions avoids any need for double closures of abstract descriptions.<p>


<TT>
abstractn <- ((LEFORPO (freemod)? POA (freemod)? uttAx (guoa)?) / (LEFORPO (freemod)? POA (freemod)? sentence (guoa)?) / (LEFORPO (freemod)? POE (freemod)? uttAx (guoe)?) / (LEFORPO (freemod)? POE (freemod)? sentence (guoe)?) / (LEFORPO (freemod)? POI (freemod)? uttAx (guoi)?) / (LEFORPO (freemod)? POI (freemod)? sentence (guoi)?) / (LEFORPO (freemod)? POO (freemod)? uttAx (guoo)?) / (LEFORPO (freemod)? POO (freemod)? sentence (guoo)?) / (LEFORPO (freemod)? POU (freemod)? uttAx (guou)?) / (LEFORPO (freemod)? POU (freemod)? sentence (guou)?) / (LEFORPO (freemod)? PO (freemod)? uttAx (guo)?) / (LEFORPO (freemod)? PO (freemod)? sentence (guo)?))</TT><P>

A variety of basic argument constructions, including abstract descriptions, all forms with the numerical article <B>lio</B> (note that <TT>lio stringnospaces</TT> allows reference to Arabic numerals), foreign names, names with <B>la</B> followed by no pause or a cancelled pause (attempted first), followed by <TT>descriptn</TT> possibly suffixed with names (attempted second), followed by names with <B>la</B> followed by a pause (read only if no initial segment of the name word parses as a descriptive predicate), and further, quoted words or characters, strong quotations, and quoted Loglan text.<p>

Where a <TT>descriptn</TT> is suffixed with a name, the name may be unmarked (but set off by an initial explicit comma pause) if it is a consonant final name word with no false name markers, and otherwise will be marked with <B>ci</B>.  A construction of this kind, such as <B>la blanu, Djan</B>, is not properly speaking a serial name.<p>


<TT>
arg1 <- (abstractn / (LIO (freemod)? descpred (guea)?) / (LIO (freemod)? argument1 (guua)?) / (LIO (freemod)? mex (gap)?) / (LIO stringnospaces) / LAO / LANAME / (descriptn (guua)? (((((comma)? CI (comma)?) / (comma &(nonamemarkers) !(AcronymicName))) name))?) / LANAME2 / LIU1 / LIE / LI)</TT><P>

Arguments which are atomic in a certain sense:  pronouns, members of the previous class, and members of this same class prefixed with <B>ge</B>.<p>


<TT>
arg1a <- ((DA / TAI / arg1 / (GE (freemod)? arg1a)) (freemod)?)</TT><P>

Subordinate clauses formed with <B>ji</B> or <B>jio</B> or kin.  JI class particles form subordinate clauses with predicates, arguments, or modifiers;  JIO class particles form subordinate clauses with sentences (of particular kinds).  Subordinate clauses can be negated, and they can be linked with afterthought logical connectives.  Such afterthought linked chains of subordinate clauses (including a chain of just one clause) can be closed with <B>gui</B> or <B>gu</B>, or with suffixed closures if introduced with suffixed versions of <B>ji(o)</B>.<p>

<TT>
argmod1 <- ((((__LWinit (N o) ([ ])*))? ((JI (freemod)? predicate) / (JIO (freemod)? sentence) / (JIO (freemod)? uttAx) / (JI (freemod)? modifier) / (JI (freemod)? argument1))) / (((__LWinit (N o) ([ ])*))? (((JIZA (freemod)? predicate) (guiza)?) / ((JIOZA (freemod)? sentence) (guiza)?) / ((JIOZA (freemod)? uttAx) (guiza)?) / ((JIZA (freemod)? modifier) (guiza)?) / (JIZA (freemod)? argument1 (guiza)?))) / (((__LWinit (N o) ([ ])*))? ((JIZI (freemod)? predicate (guizi)?) / (JIOZI (freemod)? sentence (guizi)?) / (JIOZI (freemod)? uttAx (guizi)?) / (JIZI (freemod)? modifier (guizi)?) / (JIZI (freemod)? argument1 (guizi)?))) / (((__LWinit (N o) ([ ])*))? ((JIZU (freemod)? predicate (guizu)?) / (JIOZU (freemod)? sentence (guizu)?) / (JIOZU (freemod)? uttAx (guizu)?) / (JIZU (freemod)? modifier (guizu)?) / (JIZU (freemod)? argument1 (guizu)?))))</TT><P>

This class consists of an arg1a with a subordinate clause (or logically connected subordinate clauses) attached.  The next class arg3 attaches a quantifier.<p>

<TT>
arg2 <- (arg1a (freemod)? (argmod)*)</TT><P>
<TT>
arg3 <- (arg2 / (mex (freemod)? arg2))</TT><P>

Indefinite arguments:  a quantifier followed by a descriptive predicate, then this class with subordinate clause(s) attached.<p>

<TT>
indef1 <- (mex (freemod)? descpred)</TT><P>
<TT>
indef2 <- (indef1 (guua)? (argmod)*)</TT><P>

NOTE: fix the stutter in the naming here?<p>

<TT>
indefinite <- indef2</TT><P>

A string of arguments of class arg3 or indefinite linked with the mixture connective <B>ze</B>.<p>

<TT>
arg4 <- ((arg3 / indefinite) ((ZE2 (freemod)? (arg3 / indefinite)))*)</TT><P>

Forethought connected arguments, followed by possibly multiply negated and indirectly referenced arguments.<p>

<TT>
arg5 <- (arg4 / (KA (freemod)? argument1 (freemod)? KI (freemod)? argx))</TT><P>
<TT>
argx <- (((NO1 (freemod)?))* ((LAE (freemod)?))* arg5)</TT><P>

Arguments of class argx linked with the most tightly binding afterthought logical connectives, the ACI series.<p>

<TT>
arg7 <- (argx (freemod)? ((ACI (freemod)? argx))?)</TT><P>

Arguments of class arg7 linked with the usual A afterthought logical connectives.<p>

An item of this class cannot begin with <B>ge</B> to avoid phonetic ambiguity with the AGE connectives.  This is an example of ambiguity in 1989 Loglan caused by the lexer being invisible to the grammar analysis.<p>

<TT>
arg8 <- (!(GE) (arg7 (freemod)? ((A1 (freemod)? arg7))*))</TT><P>

Arguments linked with the least binding and right grouping AGE afterthought logical connectives; further, optionally  subordinate clauses may be attached to an instance of this class, marked with <B>guu</B>.<p>

<TT>
argument1 <- (((arg8 (freemod)? AGE (freemod)? argument) / arg8) ((GUU (freemod)? argmod))*)</TT><P>

Possibly multiply negated, possibly multiply case tagged arguments.<p>

I drew a distinction between contexts where case tags are appropriate and contexts where they are not which I believe is not drawn by the LIP grammar.<p>


<TT>
argument <- (((NO1 (freemod)?))* ((DIO (freemod)?))* argument1)</TT><P>

These are intended to represent arguments in the first, second, third and fourth argument position after the predicate;  they are all the same class internally, but the distinct class names give useful annotations to the parses.<p>

<TT>
argumentA <- argument</TT><P>
<TT>
argumentB <- argument</TT><P>
<TT>
argumentC <- argument</TT><P>
<TT>
argumentD <- argument</TT><P>

This is an argument actually decorated with at least one case tag.  NOTE:  the argument probably should not be allowed to begin with NO1 here.<p>


<TT>
argxx <- (&((((NO1 (freemod)?))* DIO)) argument)</TT><P>

<H3>Term lists (including word lists for set forms)</H3>

A term attached to predicate is either an argument or a modifier.

<TT>
term <- (argument / modifier)</TT><P>

A term list made up entirely of modifiers.<p>


<TT>
modifiers <- (modifier (((freemod)? modifier))*)</TT><P>

A term list made up entirely of modifiers and arguments with explicit case tags.<p>

<TT>
modifiersx <- ((modifier / argxx) (((freemod)? (modifier / argxx)))*)</TT><P>

An argument which can be read as starting an SVO sentence.

<TT>
firstarg <- (argument1 ((modifiersx (freemod)?))? ((GIO (freemod)? terms))? predicate !(GA2))</TT><P>

A term list with untagged arguments typed with the lettered argument classes (and so with no more than four untagged arguments).  In addition, the second and subsequent untagged arguments appearing as terms cannot
start an SVO sentence.<p>

<TT>
terms <- (((modifiersx)? argumentA (((freemod)? modifiersx))? ((!(firstarg) argumentB))? (((freemod)? modifiersx))? ((!(firstarg) argumentC))? (((freemod)? modifiersx))? ((!(firstarg) argumentD))?) / modifiersx)</TT><P>

In the "official" parser, <TT>firstarg</TT> does  not appear and <TT>!firstarg</TT> annotations in <TT>terms</TT> should be ignored.<p>

The internals of explicit ordered and unordered lists.  These are completely redesigned.<p>


<TT>
word <- (arg1a / indef2)</TT><P>
<TT>
words1 <- (word ((ZEIA word))*)</TT><P>
<TT>
words2 <- (word ((ZEIO word))*)</TT><P>
<TT>
wordset1 <- ((words1)? LUA)</TT><P>
<TT>
wordset2 <- ((words2)? LUO)</TT><P>

Lists of terms following the predicate:  these can be connected with forethought and afterthought connectives and may be optionally closed with <B>guu</B>.  None of the terms may start an SVO sentence (but see note below on removing this condition).  There is the entertaining option of closing a termset with
(<B>go</B> barepred), where the barepred metaphorically modifies the predicate before the termset.<p>
 
To obtain the "official" parser, omit the <TT>!firstarg</TT> annotation.<p>

Closure of termsets with <TT>guu</TT> is handled mostly in contexts in which termsets appear, not in the termset
class itself.<p>

<TT>
termset1 <- (((modifiersx)* ((!(firstarg) terms) / (KA (freemod)? termset2 (freemod)? (guu)? KI (freemod)? termset1))) / (modifiersx)+)</TT><P>
<TT>
termset2 <- (termset1 ((guu &(A1)))? ((A1 (freemod)? termset1 ((guu &(A1)))?))*)</TT><P>
<TT>
termset <- ((terms (freemod)? GO (freemod)? barepred) / termset2)</TT><P>

<H3>More complicated predicates</H3>

This is a basic sentence predicate with a termset attached. <p>

<TT>
barepred <- (sentpred (freemod)? (((termset (guu)?) / (guu &(termset))))?)</TT><P>

This is a tensed predicate.  <TT>PA1</TT> is the form allowing internal pauses and also the option of <B>ga</B>.<p>


<TT>
markpred <- (PA1 (freemod)? barepred)</TT><P>


This is a possibly repeatedly negated <TT>barepred</TT> or <TT>markpred</TT>.  Systematic distinctions drawn between classes of marked and unmarked predicates in the LIP grammar were demonstrably already unnecessary in that grammar.<p>

<TT>
backpred1 <- (((NO2 (freemod)?))* (barepred / markpred))</TT><P>


The scheme for afterthought linkage of sentence predicates with logical connectives and attachment of shared final termsets to such linked predicates in the final version of the LIP grammar is very elegant and left grouping in a way which cannot be implemented with a PEG.  Also, the <TT>ACI</TT> connectives are simply weird in the LIP grammar.  Here we treat the <TT>ACI</TT> connectives as a fully privileged more tightly binding series of connectives (so that <TT>backpred</TT> is actually isomorphic to <TT>predicate2</TT> in some sense) and allow attachment of final termsets in a way which is not as generous as the original arrangement but which is likely to cover all possibilities which will occur in speech.<p>

A <TT>backpred</TT> is a chain of <TT>backpred1</TT>'s linked by <TT>ACI</TT> connectives (if there is more than one) possibly with a shared final termset, in turn optionally linked to a further chain of <TT>backpred</TT>s possibly with a shared final termset.<p>

<TT>
backpred <- (((backpred1 ((ACI (freemod)? backpred1))+ (freemod)? (((termset (guu)?) / (guu &(termset))))?) ((((ACI (freemod)? backpred))+ (freemod)? (((termset (guu)?) / (guu &(termset))))?))?) / backpred1)</TT><P>

A <TT>predicate2</TT> is built from <TT>backpred</TT>s using <TT>A</TT> series connectives in the same double way that <TT>backpred</TT>s are built from <TT>backpred1</TT>s.  It should be noted that the <TT>ACI</TT> and <TT>A</TT> series connectives in all contexts are taken to group to the left, in semantic terms.<p>

A <TT>predicate2</TT> may not start with <b>ge</B> because of a possible ambiguity with the <TT>AGE</TT> connectives.  For this reason, one generally cannot start a sentence predicate with <B>ge</B> (pragmatically, there is no reason to do so).<p>


<TT>
predicate2 <- (!(GE) (((backpred ((A1 !(GE) (freemod)? backpred))+ (freemod)? (((termset (guu)?) / (guu &(termset))))?) ((((A1 (freemod)? predicate2))+ (freemod)? (((termset (guu)?) / (guu &(termset))))?))?) / backpred))</TT><P>

A <TT>predicate1</TT> is a <TT>predicate2</TT> or built by linking <TT>predicate2</TT>'s with the most loosely binding <TT>AGE</TT> series of logical connectives.  This groups to the right, and no shared termset is provided.<p>


<TT>
predicate1 <- ((predicate2 AGE (freemod)? predicate1) / predicate2)</TT><P>

The top level sentence predicate class consists of <TT>predicate1</TT>'s and possibly multiply negated <TT>BI</TT> series logical predicates.<P>

<TT>
identpred <- (((NO1 (freemod)?))* (BI (freemod)? argument1 (guu)?))</TT><P>
<TT>
predicate <- (predicate1 / identpred)</TT><P>


<H3>Sentence forms</H3>

I overhauled the various sentence structures by actually enforcing statements in Notebook 3 that certain terms or termset structures in various grammar rules should consist entirely of modifiers or should contain no more than one argument.  I discovered in parsing Leith that allowing second and further arguments to appear before the predicate is a fruitful source of unintended parses of actually ill-formed utterances:  orphaned final arguments of one sentence become unintended first arguments of the next;  but clearly we need to allow something like this to have SOV word order.  I solved this by separating second and further untagged arguments before a predicate from the subject with the new particle <B>gio</B>.

Further, I stipulated that imperatives cannot be tensed (tensed sentences without subjects are read as gasents with the subject omitted and are in effect observatives) and also stipulated that modifiers before an untensed predicate also give an imperative.<p>

A <TT>subject</TT> is a term list containing at least one argument and no more than one untagged argument.  NOTE:  this should probably appear above in the term lists.<p>

<TT>
subject <- (((modifiers (freemod)?))? ((argxx subject) / (argument ((modifiersx (freemod)?))?)))</TT><P>

A <TT>gasent</TT> is a sentence with the subject delayed to the end:  it consists of a tense followed by a barepred (which may include a final termset) followed by <B>ga</B> followed by terms.  The final term list will either be a subject or contain all the arguments of the predicate (with the first one optionally separated from the others by <B>gio</B>)<p>

<TT>
gasent1 <- (((NO1 (freemod)?))* (PA1 (freemod)? barepred ((GA2 (freemod)? subject))?))</TT><P>
<TT>
gasent2 <- (((NO1 (freemod)?))* (PA1 (freemod)? sentpred (modifiers)? (GA2 (freemod)? subject (freemod)? (GIO)? (freemod)? (terms)?)))</TT><P>

<TT>
gasent <- (gasent2 / gasent1)</TT><P>

A <TT>statement</TT> is either a <TT>gasent</TT> or a <TT>gasent</TT> with fronted modifiers, or a subject, optionally followed by <B>gio</B> and further terms, followed by a predicate.<p>

Fronted modifiers before a gasent are  not allowed by the rule given here:  we follow it by the
rule from the "official" parser.  We are inclined not to allow the form with fronted modifiers, because
it is often what is obtained when a sentence is parsed in an unintended way by the "official" parser.
The modifier can be fronted anyway as an instance of <TT>headterms</TT>, marked with <B>gi</B>.<p>

Under the alternative parser, using the particle GAA by itself or with second and further arguments before the
predicate automatically closes the subject;  this is an afterthought way to deal with a complex subject not easily
closed.  The fact that the particle has a mandatory stress on it is not an accident.<p>

<TT>
statement <- (gasent / (subject (freemod)? ((GIO (freemod)? terms)/GAA freemod? terms?)? predicate))</TT><P>
</TT>

<TT>
statement <- (gasent / (modifiers (freemod)? gasent) / (subject (freemod)? ((GIO (freemod)? terms))? predicate))</TT><P>

A keksent is a sentence or uttAx (see below:  this class is inlined rather than named here) forethought connected to an uttA1, a very general class of sentences and sentence fragments.  Odd and interesting things
can be said using the uttA1 option.<p>

<TT>
keksent <- (((NO1 (freemod)?))* ((KA (freemod)? sentence (freemod)? KI (freemod)? uttA1) / (KA sentence (freemod)? KI (freemod)? uttA1) / (KA (freemod)? headterms (freemod)? sentence (freemod)? KI (freemod)? uttA1)))</TT><P>

This is a sentence-initial negation operator with sentence long scope.<p>

<TT>
neghead <- ((NO1 (freemod)? gap) / (NO2 PAUSE))</TT><P>

A sen1 is a first approximation to the sentence class.  The first and third options [of the second version of the rule, taken from the "official" parser] describe imperatives, in which no argument appears before the untensed predicate.  The other two are familiar sentence classes.  The sen1 can further be negated one or more times (that is what neghead is for).<p>

The first rule does not allow modifiers initial to imperatives (<B>gi</B> can be used to attach them if desired).
The second rule is the rule in the "official" parser which does allow fronted modifiers in this class.<p>

<TT>
sen1 <- (((neghead (freemod)?))* (statement / predicate / keksent))</TT><P>

<TT>
sen1 <- (neghead freemod?)* ((modifiers (freemod)? !(gasent) predicate) / statement / predicate / keksent)</TT><P>

A sentence is one or more sen1's linked by ICA logical connectives (if there is more than one of them).<p>


<TT>
sentence <- (sen1 ((ICA (freemod)? sen1))*)</TT><P>

An uttAx is a sentence (possibly logically connected!) with a shared fronted sequence of arguments (actually to be taken as final arguments).<p>

<TT>
headterms <- ((terms GI))+</TT><P>
<TT>
uttAx <- (headterms (freemod)? sentence (giuo)?)</TT><P>

<H3>Inverse vocatives and free modifiers</H3>

The inverse vocative construction.  This is similar to the vocative, though with the further option of a full statement being tagged with <B>hue</B>.  I allow an argument used as an inverse vocative to be closed with <B>guu</B>; this averted many painful phenomena in the Leith parse, where frequently an inverse vocative intended to capture an argument actually captured an entire sentence.<p>

<TT>
HUE0 <- ([Hh] UE)</TT><P>
<TT>
invvoc <- ((([ ])* HUE0 (CANCELPAUSE / (([ ])* &(C1))) name) / (HUE !(badspaces) (freemod)? descpred (guea)? (((((comma)? CI (comma)?) / (comma &(nonamemarkers) !(AcronymicName))) name))?) / (HUE !(badspaces) (freemod)? statement (giuo)?) / (HUE !(badspaces) (freemod)? argument1 (guu)?) / (([ ])* HUE0 ((',' ([ ])+) / (([ ])* &(V1))) name) / (HUE stringnospacesclosedblock))</TT><P>

The lengthy list of free modifier constructions.  Note that optional free modifiers appear in most medial positions in rules and some final ones (final ones on rules viewed as "atomic", usually).  A very important free modifier is an explicit comma pause [not followed by a name word  without false name markers], which can thus be inserted in many places (including places required to separate vowel initial words from what precedes them).  What the various constructions are can be divined from the list above of their constructors.<p>


<TT>
freemod <- ((NOUI / (SOI (freemod)? descpred (guea)?) / DIE / (NO1 DIE) / (KIE (comma)? utterance0 (comma)? KIU) / invvoc / voc / CANCELPAUSE / (comma !((&(nonamemarkers) Name))) / JO / UI1 / (([ ])* '...' ((([ ])* &(letter)))?) / (([ ])* '--' ((([ ])* &(letter)))?)) (freemod)?)</TT><P>

<H3>Utterances</H3>

This class contains two kinds of fragmentary utterances, usually answers to questions.<p>
<TT>
uttA <- ((A1 / mex) (freemod)?)</TT><P>

This class contains sen1 and uttAx sentences and a menagerie of sentence fragments which may appear as answers to questions.  Note that this may end with terminal punctuation.<p>

<TT>
uttA1 <- ((sen1 / uttAx / links / linkargs / argmod / (modifiers (freemod)? keksent) / terms / uttA / NO1) (freemod)? (period)?)</TT><P>

An uttC is a possibly multiply negated uttA1.  The negations are separated from the utterance negated by a gap or pause.  The PAUSE here may be semantically significant (with latest mods, it won't change the meaning, but it will change the parse tree)!<p>

<TT>
uttC <- ((neghead (freemod)? uttC) / uttA1)</TT><P>

An uttD is a sentence possibly with terminal punctuation not followed by ICI or ICA, or a sequence of
uttC's linked by ICI (if there is more than one uttC).<p>

<TT>
uttD <- ((sentence (period)? !(ICI) !(ICA)) / (uttC ((ICI (freemod)? uttD))*))</TT><P>

An uttE is a sequence of uttD's linked by ICA connectives.  A sentence (sen1's linked by ICA connectives) will be parsed as a single uttD, however, due to the careful definition of uttD.<p>

<TT>
uttE <- (uttD ((ICA (freemod)? uttD))*)</TT><P>

An uttF is a sequence of uttE's linked by I utterance connectives.  These are supposed grouped to the left.<p>

<TT>
uttF <- (uttE ((I (freemod)? uttE))*)</TT><P>

A top level utterance can be constructed in various weird and wonderful ways.  The first class is designed to be quoted or parenthesized;  the second one is constrained to end with end of text.  A free modifier followed by an utterance is an utterance (the only leading appearance of freemods);  a free modifier is an utterance by itself;  uttF's can be linked with IGE to utterances; an uttF is an utterance; ICA followed by an uttF is an utterance; I followed by an utterance is an utterance.  NOTE:  some of these cases need analysis, and there might possibly be order bugs in this rule.<p>

<TT>
utterance0 <- (!(GE) ((!(PAUSE) freemod (period)? utterance0) / (!(PAUSE) freemod (period)?) / (uttF IGE utterance0) / uttF / (I (freemod)? (uttF)?) / (I (freemod)? (period)?) / (ICA (freemod)? uttF)) ((&(I) utterance0))?)</TT><P>
<TT>
utterance <- (!(GE) ((!(PAUSE) freemod (period)? utterance) / (!(PAUSE) freemod (period)? ((&(I) utterance))? end) / (uttF IGE utterance) / (I (freemod)? (period)? ((&(I) utterance))? end) / (uttF ((&(I) utterance))? end) / (I (freemod)? uttF ((&(I) utterance))? end) / (ICA (freemod)? uttF ((&(I) utterance))? end)))</TT><P>
